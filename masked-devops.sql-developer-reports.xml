<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[Masked Devops]]></name>
	<tooltip><![CDATA[Masked Devops SQL Developer Reports]]></tooltip>
	<description><![CDATA[ ]]></description>
		<display id="8ea547aa-0183-1000-801e-c0a83801b45d" type="" style="Chart" enable="true">
		<name><![CDATA[Masked-Devops Session History]]></name>
		<description><![CDATA[Active session history report:
Parameters in lowercase have defaults, if the report is run with all parameters to null,
It will give the last 24hr workload, in intervals of 600 seconds with wait_class as dimension.


p_start_date		yyyy-mm-dd hh24:mi   Default is sysdate-1 in that format		
p_end_date		yyyy-mm-dd hh24:mi   Default is sysdate    in that format	 
p_interval		Default 600	
p_dim		Default=wait_class		

Filters:
P_INST_ID
P_CON_ID
P_SESSION_SID
P_SESSION_SERIAL#
P_SQL_ID
P_SESSION_TYPE
P_USER_ID
P_MODULE
P_PROGRAM
P_MACHINE
P_WAIT_CLASS
P_PLSQL_ENTRY_OBJECT_ID
P_DBA_HIST_ONLY]]></description>
		<tooltip><![CDATA[Active session history report]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[Active Sessions]]></Y1AXIS_TITLE_TEXT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y2AXIS_SCALE_MAXIMUM>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND><![CDATA[true]]></LEGEND>
			<SUBTITLE_TEXT><![CDATA[]]></SUBTITLE_TEXT>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[180.0]]></Y1AXIS_SCALE_MAXIMUM>
			<Y1AXIS_SCALE_INCREMENT_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_INCREMENT_AUTOMATIC>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<STYLE><![CDATA[Regatta]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<XAXIS_SCALE_MAXIMUM><![CDATA[70.0]]></XAXIS_SCALE_MAXIMUM>
			<TITLE_TEXT><![CDATA[]]></TITLE_TEXT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<XAXIS_TITLE_TEXT><![CDATA[Time]]></XAXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<PLOT_DATATIPS_CUMULATIVE_VALUE><![CDATA[false]]></PLOT_DATATIPS_CUMULATIVE_VALUE>
			<XAXIS_TICK_LABEL_AUTO_ROTATE><![CDATA[true]]></XAXIS_TICK_LABEL_AUTO_ROTATE>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[1.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<SUBTITLE><![CDATA[false]]></SUBTITLE>
			<GRADIENT><![CDATA[true]]></GRADIENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<FOOTNOTE><![CDATA[false]]></FOOTNOTE>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<PLOT_DATALABELS><![CDATA[false]]></PLOT_DATALABELS>
			<XAXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></XAXIS_LOGARITHMIC_BASE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<GRID><![CDATA[true]]></GRID>
			<XAXIS_SCALE_INCREMENT><![CDATA[10.0]]></XAXIS_SCALE_INCREMENT>
			<Y1AXIS_SCALE_MINIMUM_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_MINIMUM_AUTOMATIC>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<XAXIS_TITLE><![CDATA[true]]></XAXIS_TITLE>
			<THREED><![CDATA[false]]></THREED>
			<FOOTNOTE_TEXT><![CDATA[]]></FOOTNOTE_TEXT>
			<TITLE><![CDATA[false]]></TITLE>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash as    (select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p, snaps where p.sample_source=10 and snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id     ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p        where p.sample_source=1  and sample_time >= start_date and sample_time <= end_date )
    ,hist as (  select
                     sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 sample_time_ft
                    ,case
                        when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                        when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                        when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                        when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                        when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                        when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                        when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                        when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                        when lower(parms.dim) = 'sql_id'                then ash.sql_id
                        when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                        when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                        when lower(parms.dim) = 'module'                then ash.module
                        when lower(parms.dim) = 'program'               then ash.program
                        when lower(parms.dim) = 'action'                then ash.action
                        when lower(parms.dim) = 'machine'               then ash.machine
                        when lower(parms.dim) = 'event'                 then ash.event
                        when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                        else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    end dim
                from ash cross join parms
                where 1=1
                    ------- additional filters
                    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
                    and ash.con_id          = nvl(parms.con_id, ash.con_id)
                    and ash.session_id      = nvl(parms.session_id, ash.session_id)
                    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
                    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
                    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
                    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
                    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
                    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
                    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
                    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
                    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)

        )
select /*+ NO_PARALLEL */
     to_char(slots.slot,'yyyy-mm-dd hh24:mi:ss') slot
    ,hist.dim
    ,count(hist.dim)*sample_source/inter active_sessions
from slots,hist,parms
where slots.slot = hist.sample_time_ft(+)
group by slots.slot, hist.dim,inter,sample_source
order by slots.slot,hist.dim]]></sql>
			<binds>
				<bind id="p_start_date">
					<prompt><![CDATA[start_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate-1 in that format]]></tooltip>
					<value><![CDATA[2022-09-25 14:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_end_date">
					<prompt><![CDATA[end_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate in that format]]></tooltip>
					<value><![CDATA[2022-09-25 23:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_interval">
					<prompt><![CDATA[interval in seconds]]></prompt>
					<tooltip><![CDATA[time slot in seconds, histogram width, in seconds, default 600]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_dim">
					<prompt><![CDATA[dimension]]></prompt>
					<tooltip><![CDATA[instance_number | con_id | user_id | session_sid | xid | sql_exec_id | sql_exec_id_plan | sql_exec_id_plan_oper | sql_id | current_obj# | module | program | action | machine | event | wait_class   Default wait_class]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[INST_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.inst_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_CON_ID">
					<prompt><![CDATA[CON_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.con_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SID">
					<prompt><![CDATA[SESSION_SID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sid]]></tooltip>
					<value><![CDATA[71]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SERIAL#">
					<prompt><![CDATA[SESSION_SERIAL#]]></prompt>
					<tooltip><![CDATA[V$SESSION.serial#]]></tooltip>
					<value><![CDATA[10164]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sql_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_TYPE">
					<prompt><![CDATA[SESSION_TYPE]]></prompt>
					<tooltip><![CDATA[FOREGROUND/BACKGROUND  default=both]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_USER_ID">
					<prompt><![CDATA[USER_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.user#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MODULE">
					<prompt><![CDATA[MODULE]]></prompt>
					<tooltip><![CDATA[V$SESSION.module]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PROGRAM">
					<prompt><![CDATA[PROGRAM]]></prompt>
					<tooltip><![CDATA[V$SESSION.program]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MACHINE">
					<prompt><![CDATA[MACHINE]]></prompt>
					<tooltip><![CDATA[V$SESSION.machine]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_WAIT_CLASS">
					<prompt><![CDATA[WAIT_CLASS]]></prompt>
					<tooltip><![CDATA[Administrative/Application/Cluster/Commit/Concurrency ...]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PLSQL_ENTRY_OBJECT_ID">
					<prompt><![CDATA[PLSQL_ENTRY_OBJECT_ID]]></prompt>
					<tooltip><![CDATA[DBA_OBJECTS.object_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_DBA_HIST_ONLY">
					<prompt><![CDATA[DBA_HIST_ONLY]]></prompt>
					<tooltip><![CDATA[yes/no  null=no, yes=only data from cdb_hist_active_sess_history]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Report Parms]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[List report parameters plus useful info about the instance and the slot selected.]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as (select /*+ materialize NO_PARALLEL */
                     ash.*
                    ,parms.inter
                    ,count(*)                       over ()  cnt_tot
                    ,count(distinct ash.session_id) over ()  cnt_sid
                    ,count(distinct ash.sql_id)     over ()  cnt_sql_id
                    ,count(distinct xid)            over ()  cnt_xid
                    ,count(distinct sql_exec_id)    over ()  cnt_exec_id
                    ,count(distinct in_parse)       over ()  cnt_in_parse
                    ,count(distinct in_hard_parse)  over ()  cnt_in_hard_parse
                    ,count(distinct in_sql_execution)      over ()  cnt_in_sql_execution
                    ,count(distinct in_plsql_execution)    over ()  cnt_in_plsql_execution
                    ,count(distinct ash.program)    over ()  cnt_program
                    ,count(distinct ash.module)     over ()  cnt_module
                    ,count(distinct ash.machine)    over ()  cnt_machine
                from ( select ash.snap_id ,ash.dbid ,ash.con_id,ash.instance_number ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                       select 0           ,null     ,con_id    ,inst_id             ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end
                     ) ash ,parms)
select 'start_date' parameter   , to_char(start_date,'yyyy-mm-dd hh24:mi')     value                          ,'----','sample source              ' info     ,case when sample_source = 1 then 'v$active_session_history' else 'cdb_hist_active_sess_history' end info_value from parms  union all
select 'end_date                ',to_char(end_date,'yyyy-mm-dd hh24:mi')                                      ,'----','cpu count                  '          ,(select sp.value from v$parameter sp  where name = 'cpu_count')                                                from parms  union all
select 'dim                     ',dim                                                                         ,'----','memory_target              '          ,(select sp.value from v$parameter sp  where name = 'memory_target')                                            from parms  union all
select 'inter                   ',to_char(parms.inter)                                                        ,'----','memory_max_target          '          ,(select sp.value from v$parameter sp  where name = 'memory_max_target')                                        from parms  union all
select 'start slot              ',to_char(cast(:SLOT as date),'yyyy-mm-dd hh24:mi:ss')                        ,'----','sga_target                 '          ,(select sp.value from v$parameter sp  where name = 'sga_target')                                               from parms  union all
select 'end   slot              ',to_char(cast(:SLOT as date)+ parms.inter/24/60/60 ,'yyyy-mm-dd hh24:mi:ss') ,'----','sga_max_target             '          ,(select sp.value from v$parameter sp  where name = 'sga_max_target')                                           from parms  union all
select 'instance_number         ',to_char(parms.instance_number)                                              ,'----','pga_aggregate_target       '          ,(select sp.value from v$parameter sp  where name = 'pga_aggregate_target')                                     from parms  union all
select 'con_id                  ',parms.con_id                                                                ,'----','slot samples               '          ,(select to_char(cnt_tot)        from ash where rownum < 2)                                                     from parms union all
select 'session_id              ',to_char(parms.session_id)                                                   ,'----','slot sessions              '          ,(select to_char(cnt_sid)        from ash where rownum < 2)                                                     from parms union all
select 'session_serial#         ',to_char(parms.session_serial#)                                              ,'----','slot distinct sql count    '          ,(select to_char(cnt_sql_id)     from ash where rownum < 2)                                                     from parms union all
select 'sql_id                  ',parms.sql_id                                                                ,'----','slot transactions          '          ,(select to_char(cnt_xid)        from ash where rownum < 2)                                                     from parms union all
select 'session_type            ',parms.session_type                                                          ,'----','slot exec_id               '          ,(select to_char(cnt_exec_id)    from ash where rownum < 2)                                                     from parms union all
select 'user_id                 ',to_char(parms.user_id)                                                      ,'----','slot in_parse              '          ,(select to_char(cnt_in_parse)               from ash where rownum < 2)                                         from parms union all
select 'module                  ',parms.module                                                                ,'----','slot in_hard_parse         '          ,(select to_char(cnt_in_hard_parse)          from ash where rownum < 2)                                         from parms union all
select 'program                 ',parms.program                                                               ,'----','slot in_sql_execution      '          ,(select to_char(cnt_in_sql_execution)       from ash where rownum < 2)                                         from parms union all
select 'machine                 ',parms.machine                                                               ,'----','slot in_plsql_execution    '          ,(select to_char(cnt_in_plsql_execution) from ash where rownum < 2)                                             from parms union all
select 'wait_class              ',parms.wait_class                                                            ,'----','slot program               '          ,(select to_char(cnt_program) from ash where rownum < 2)                                                        from parms union all
select 'plsql_entry_object_id   ',:P_PLSQL_ENTRY_OBJECT_ID                                                    ,'----','slot module                '          ,(select to_char(cnt_module)  from ash where rownum < 2)                                                        from parms union all
select 'dba_hist_only           ',:P_DBA_HIST_ONLY                                                            ,'----','slot machine               '          ,(select to_char(cnt_machine) from ash where rownum < 2)                                                        from parms union all
select '----','----','----','----','----' from dual]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[Counts of the samples grouped by  slot dim event]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000)     total_wait_time_ms 
	,round(avg(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000,2)   avg_wait_time_ms 
	,count(ash.sample_id)        over (partition by ash.instance_number,ash.con_id,ash.event)           cnt_event
	,count(*)                    over (partition by ash.instance_number,ash.con_id)                     cnt_ash_con
	,count(*)                    over ()                                                                cnt_ash_inst
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
	cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by cnt_event desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions all]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */
    --ash.sample_id
    to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')     sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    ,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.plsql_entry_object_id                            --Object ID of the top-most PL/SQL subprogram on the stack (or NULL if there is no PL/SQL subprogram on the stack)
    ,'SQLDEV:LINK:'||peoi.owner||':'||peoi.object_type||':'||peoi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' top_plsql
    --,ash.plsql_entry_subprogram_id
    ,preoi.procedure_name top_plsql_proc
    --,ash.plsql_object_id                                  --Object ID of the currently executing PL/SQL subprogram (or NULL if executing SQL)
    ,'SQLDEV:LINK:'||poi.owner||':'||poi.object_type||':'||poi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' plsql
    --,ash.plsql_subprogram_id
    ,proi.procedure_name plsql_proc
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    ,ash.in_parse
    ,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,to_char(ash.pga_allocated/1024/1024,'FM999999999.90') pga_allocated_mb
    ,case when ash.temp_space_allocated != 0 then to_char(ash.temp_space_allocated/1024/1024,'FM999999999.90') else to_char(ash.temp_space_allocated) end temp_space_allocated_mb
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
        cross join  parms
        left  outer join cdb_users u            on ash.user_id = u.user_id and ash.con_id = u.con_id
        left  outer join gv$event_name e        on ash.instance_number = e.inst_id and ash.event_id = e.event_id
        left  outer join cdb_objects o          on ash.current_obj# = o.object_id and ash.con_id = o.con_id
        left  outer join cdb_objects peoi       on ash.plsql_entry_object_id = peoi.object_id and ash.con_id = peoi.con_id
        left  outer join cdb_procedures preoi   on ash.plsql_entry_object_id = preoi.object_id and ash.plsql_entry_subprogram_id = preoi.subprogram_id and ash.con_id = preoi.con_id
        left  outer join cdb_objects poi        on ash.plsql_object_id = poi.object_id and ash.con_id = poi.con_id
        left  outer join cdb_procedures proi    on ash.plsql_object_id = proi.object_id and ash.plsql_subprogram_id = proi.subprogram_id and ash.con_id = proi.con_id
        left  outer join gv$datafile f          on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
    ------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id      = nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by sample_time asc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */
	 :DIM dim
    --ash.sample_id
    ,to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')	 sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    --,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    ,ash.plsql_entry_object_id
    ,ash.plsql_entry_subprogram_id
    ,ash.plsql_object_id
    ,ash.plsql_subprogram_id
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    --,ash.in_parse
    --,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,ash.temp_space_allocated
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
    left  outer join gv$event_name e	on ash.instance_number = e.inst_id and ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
    left  outer join gv$datafile f		on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by sample_time asc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                            cnt_ash_con
   	,count(*)                       over ()                                                                                       cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.event
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000)          total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000,2)        avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)  cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                        cnt_ash_con
	,count(*)               over ()                                                                   cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event/plan]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||o.owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,o.subobject_name
    ,o.object_type
    ,ash.current_obj#
    ,sql_opname
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_plan_operation	
    ,sql_plan_options	
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000,2) avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)    cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Plan Line by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/event by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from cdb_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from cdb_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.event
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_event
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from cdb_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join v$event_name e		on ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[ASH text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
     parms as ( select 
                     nvl(to_number(:p_interval),600)                              inter
                    ,cast(:SLOT as date)                                          start_date_slot
                    ,cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 end_date_slot
                    ,sys_context('USERENV', 'DB_NAME')                            db_name
                    ,sys_context('USERENV', 'INSTANCE_NAME')                      instance_name
                    ,sys_context('USERENV', 'INSTANCE')                           instance_number
                    ,(select nvl(dbid,(select dbid from v$database)) from cdb_hist_active_sess_history where sample_time between cast(:SLOT as date)  and cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 and rownum < 2) dbid
               from dual)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(start_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt' ||' -->' output from parms
union all
select output from parms,table(dbms_workload_repository.ash_report_text(dbid,instance_number,start_date_slot,end_date_slot))]]></sql>
			</query>
		</display>
	</display>
	<display id="8db107cc-0183-1000-8003-c0a83801b45d" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops AWR Reports]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[
                -- -----------------------------------------------------------------------------
                -- Author      : Masked DevOps
                -- Date        : Jan 2012
                -- Version     : 0.1
                --
                --!!!Edit this report from the xml file only, not from SQL Developer!!!
                --
                -- SQL Developer report for database administration 
                -- Copyright (C) 2022  Emanuele Moccia
                -- masked.devops@yahoo.com
                -- 
                -- This program is free software: you can redistribute it and/or modify
                -- it under the terms of the GNU General Public License as published by
                -- the Free Software Foundation, either version 3 of the License, or
                -- any later version.
                -- 
                -- This program is distributed in the hope that it will be useful,
                -- but WITHOUT ANY WARRANTY; without even the implied warranty of
                -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                -- GNU General Public License for more details.
                -- 
                -- You should have received a copy of the GNU General Public License
                -- along with this program.  If not, see <https://www.gnu.org/licenses/>.
                -- -----------------------------------------------------------------------------
                with
                     parms as ( select
                                     nvl(:reports_dest_dir,'c:\temp')                                   reports_dest_dir
                                    ,case when instr(:reports_dest_dir,'\') > 0 then '\' else '/' end   slash
                                from dual)
                select
                     snap_id start_snap_id
                    ,to_char(end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  start_snap_date
                    ,db_name
                    ,instance_name
                    ,dbid
                    ,instance_number
                    ,reports_dest_dir
                    --,slash
                from (  select
                             di.db_name
                            ,di.instance_name
                            ,s.snap_id
                            ,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
                            ,s.end_interval_time
                            ,di.dbid
                            ,di.instance_number
                        from dba_hist_snapshot s, dba_hist_database_instance di
                        where 1=1
                            and s.dbid                = di.dbid(+)
                            and s.instance_number     = di.instance_number(+)
                            and s.startup_time        = di.startup_time(+)
                    ) snaps,parms
                where snap_id_prev is not null
                order by end_interval_time ,instance_number, snap_id
                ]]></sql>
			<binds>
				<bind id="reports_dest_dir">
					<prompt><![CDATA[reports_dest_dir]]></prompt>
					<tooltip><![CDATA[reports_dest_dir]]></tooltip>
					<value><![CDATA[C:\temp]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="3232034d-015e-1000-8002-0b0e12972947" type="" style="Table" enable="true">
			<name><![CDATA[End Snap]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[
                            select
                                 s.snap_id end_snap_id
                                ,to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  end_snap_date
                                ,di.db_name
                                ,di.instance_name
                                ,di.dbid
                                ,di.instance_number
                                ,:START_SNAP_ID start_snap_id
                                ,:START_SNAP_DATE  start_snap_date
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_html
                            from dba_hist_snapshot s, dba_hist_database_instance di
                            where 1=1
                                and s.dbid                = di.dbid(+)
                                and s.instance_number     = di.instance_number(+)
                                and s.startup_time        = di.startup_time(+)
                                and s.dbid                = :DBID
                                and s.instance_number     = :INSTANCE_NUMBER
                                and cast(s.end_interval_time as date) > to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss')
                            order by end_interval_time ,instance_name, snap_id
                            ]]></sql>
				<binds>
					<bind id="START_SNAP_ID">
						<prompt><![CDATA[START_SNAP_ID]]></prompt>
						<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_SNAP_DATE">
						<prompt><![CDATA[START_SNAP_DATE]]></prompt>
						<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DB_NAME">
						<prompt><![CDATA[DB_NAME]]></prompt>
						<tooltip><![CDATA[DB_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[Info]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                select
                                     :START_SNAP_ID start_snap_id
                                    ,:END_SNAP_ID end_snap_id
                                    ,:START_SNAP_DATE start_snap_date
                                    ,:END_SNAP_DATE end_snap_date
                                    ,:DB_NAME db_name
                                    ,:INSTANCE_NAME instance_name
                                    ,:INSTANCE_NUMBER instance_number
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  awr_txt
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' awr_html
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        awr_global_txt
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       awr_global_html
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  ash_txt
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' ash_html
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        ash_global_txt
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       ash_global_html
                                    from dual;
                    ]]></sql>
					<binds>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                SELECT
                                     sql_id
                                    ,plan_hash_value
                                    ,last_exec_start_time
                                    ,parsing_schema_name
                                    --,force_matching_signature
                                    ,executions
                                    --,elapsed_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   elapsed_time_sec
                                    ,to_char(case when executions > 0 then trunc(elapsed_time/1000000/executions,4) else 0 end,'99990.990')  avg_time_sec
                                    --,cpu_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   cpu_time_sec
                                    ,buffer_gets
                                    ,disk_reads
                                    ,direct_writes
                                    ,rows_processed
                                    ,fetches
                                    ,end_of_fetch_count
                                    ,substr(sql_text,1,40)  sql_text
                                    ,object_list
                                    --,bind_data
                                    ,module
                                    ,action
                                    ,optimizer_cost
                                    --,optimizer_env
                                    ,priority
                                    ,command_type
                                    ,first_load_time
                                    ,stat_period
                                    ,active_stat_period
                                    ,other
                                    --,sql_plan
                                    ,bind_list
                                    ,con_dbid
                                FROM table((dbms_sqltune.select_workload_repository (
                                    begin_snap          => :START_SNAP_ID,
                                    end_snap            => :END_SNAP_ID,
                                    basic_filter        => null,
                                    object_filter       => null,
                                    ranking_measure1    => 'elapsed_time',
                                    ranking_measure2    => null,
                                    ranking_measure3    => null,
                                    result_percentage   => null,
                                    result_limit        => 1000,
                                    attribute_list      => 'ALL',
                                    recursive_sql       => null,
                                    dbid                => :DBID)
                                    )) ;                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[Tuning task SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off
                                select
                                    q'[
                                        variable sqlset_name    varchar2(60)
                                        variable task_name      varchar2(60)
                                        variable begin_snap     number
                                        variable end_snap       number
                                        variable dbid           number
                                        variable sqlset_limit   number
                                        variable time_limit     number
                                        exec :sqlset_name       := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :task_name         := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :begin_snap        := ]' || :START_SNAP_ID || q'[;
                                        exec :end_snap          := ]' || :END_SNAP_ID || q'[;
                                        exec :dbid              := ]' || :DBID          || q'[;
                                        exec :sqlset_limit      := 1000;
                                        exec :time_limit        := 3600;
                                        declare
                                          l_cursor  dbms_sqltune.sqlset_cursor;
                                          l_sql_tune_task_id  varchar2(100);
                                        begin
                                            begin dbms_sqltune.drop_tuning_task (task_name => :task_name);exception when others then null;end;
                                            begin dbms_sqltune.drop_sqlset(sqlset_name => :sqlset_name);exception when others then null; end;
                                            dbms_sqltune.create_sqlset(sqlset_name => :sqlset_name, description  => 'AWR snapshots workload');
                                            open l_cursor for select value(p) from table (dbms_sqltune.select_workload_repository (begin_snap => :begin_snap,end_snap => :end_snap,basic_filter => null,object_filter => null,ranking_measure1 => null,ranking_measure2 => null,ranking_measure3 => null,result_percentage => null,result_limit => :sqlset_limit,dbid => :dbid)) p;
                                            dbms_sqltune.load_sqlset (sqlset_name => :sqlset_name, populate_cursor => l_cursor);
                                            l_sql_tune_task_id := dbms_sqltune.create_tuning_task (sqlset_name => :sqlset_name,scope => dbms_sqltune.scope_comprehensive,time_limit => :time_limit, --secondstask_name => :task_name,description => 'Tuning task for a SQL tuning set  '|| :sqlset_name);
                                            dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
                                            dbms_sqltune.execute_tuning_task(task_name => :task_name);
                                        end;
                                        /
                                        set long 100000 pagesize 1000 linesize 200
                                        select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;
                                    ]' sql_tuning_advisor
                                from dual
                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_report_html(:DBID,:INSTANCE_NUMBER,:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_report_html(:DBID,:INSTANCE_NUMBER,to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM view]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM run]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 1000000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM',task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'INSTANCE',         value => :INSTANCE_NUMBER);
                                exec dbms_advisor.execute_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report FROM    dual;
                             ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'awr_report_html' awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;


                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'ash_report_html'    awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'addm_report_text'  awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_report_html' awr_report from dual union all
                                                select 'ash_report_html'            from dual union all
                                                select 'addm_report_text'    from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                --AWR
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_global_report_html(:DBID,'',:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                --ASH
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_global_report_html(:DBID,'',to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                -ADDM
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.'||'txt' filename from dual;
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM', task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.execute_task(task_name =>  'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report from dual;
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                prompt All Reports Completed!

                        ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_global_report_html' awr_report from dual union all
                                                select 'ash_global_report_html'            from dual union all
                                                select 'addm_global_report_text'           from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
		</display>
	</display>
</folder>
</displays>