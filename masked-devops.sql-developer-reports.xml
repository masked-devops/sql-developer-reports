<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[Masked Devops]]></name>
	<tooltip><![CDATA[Masked Devops SQL Developer Reports]]></tooltip>
	<description><![CDATA[ ]]></description>
		<display id="9d8d6974-0183-1000-8005-c0a83801a02f" type="" style="Chart" enable="true">
		<name><![CDATA[Masked-Devops Session History]]></name>
		<description><![CDATA[Active session history report:
Parameters in lowercase have defaults, if the report is run with all parameters to null,
It will give the last 24hr workload, in intervals of 600 seconds with wait_class as dimension.


p_start_date		yyyy-mm-dd hh24:mi   Default is sysdate-1 in that format		
p_end_date		yyyy-mm-dd hh24:mi   Default is sysdate    in that format	 
p_interval		Default 600	
p_dim		Default=wait_class		

Filters:
P_INST_ID
P_CON_ID
P_SESSION_SID
P_SESSION_SERIAL#
P_SQL_ID
P_SESSION_TYPE
P_USER_ID
P_MODULE
P_PROGRAM
P_MACHINE
P_WAIT_CLASS
P_PLSQL_ENTRY_OBJECT_ID
P_DBA_HIST_ONLY]]></description>
		<tooltip><![CDATA[Active session history report]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[Active Sessions]]></Y1AXIS_TITLE_TEXT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y2AXIS_SCALE_MAXIMUM>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND><![CDATA[true]]></LEGEND>
			<SUBTITLE_TEXT><![CDATA[]]></SUBTITLE_TEXT>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[180.0]]></Y1AXIS_SCALE_MAXIMUM>
			<Y1AXIS_SCALE_INCREMENT_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_INCREMENT_AUTOMATIC>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<STYLE><![CDATA[Regatta]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<XAXIS_SCALE_MAXIMUM><![CDATA[70.0]]></XAXIS_SCALE_MAXIMUM>
			<TITLE_TEXT><![CDATA[]]></TITLE_TEXT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<XAXIS_TITLE_TEXT><![CDATA[Time]]></XAXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<PLOT_DATATIPS_CUMULATIVE_VALUE><![CDATA[false]]></PLOT_DATATIPS_CUMULATIVE_VALUE>
			<XAXIS_TICK_LABEL_AUTO_ROTATE><![CDATA[true]]></XAXIS_TICK_LABEL_AUTO_ROTATE>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[1.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<SUBTITLE><![CDATA[false]]></SUBTITLE>
			<GRADIENT><![CDATA[true]]></GRADIENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<FOOTNOTE><![CDATA[false]]></FOOTNOTE>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<PLOT_DATALABELS><![CDATA[false]]></PLOT_DATALABELS>
			<XAXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></XAXIS_LOGARITHMIC_BASE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<GRID><![CDATA[true]]></GRID>
			<XAXIS_SCALE_INCREMENT><![CDATA[10.0]]></XAXIS_SCALE_INCREMENT>
			<Y1AXIS_SCALE_MINIMUM_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_MINIMUM_AUTOMATIC>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<XAXIS_TITLE><![CDATA[true]]></XAXIS_TITLE>
			<THREED><![CDATA[false]]></THREED>
			<FOOTNOTE_TEXT><![CDATA[]]></FOOTNOTE_TEXT>
			<TITLE><![CDATA[false]]></TITLE>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash as    (select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p, snaps where p.sample_source=10 and snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id     ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p        where p.sample_source=1  and sample_time >= start_date and sample_time <= end_date )
    ,hist as (  select
                     sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 sample_time_ft
                    ,case
                        when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                        when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                        when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                        when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                        when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                        when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                        when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                        when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                        when lower(parms.dim) = 'sql_id'                then ash.sql_id
                        when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                        when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                        when lower(parms.dim) = 'module'                then ash.module
                        when lower(parms.dim) = 'program'               then ash.program
                        when lower(parms.dim) = 'action'                then ash.action
                        when lower(parms.dim) = 'machine'               then ash.machine
                        when lower(parms.dim) = 'event'                 then ash.event
                        when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                        else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    end dim
                from ash cross join parms
                where 1=1
                    ------- additional filters
                    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
                    and ash.con_id          = nvl(parms.con_id, ash.con_id)
                    and ash.session_id      = nvl(parms.session_id, ash.session_id)
                    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
                    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
                    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
                    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
                    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
                    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
                    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
                    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
                    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)

        )
select /*+ NO_PARALLEL */
     to_char(slots.slot,'yyyy-mm-dd hh24:mi:ss') slot
    ,hist.dim
    ,count(hist.dim)*sample_source/inter active_sessions
from slots,hist,parms
where slots.slot = hist.sample_time_ft(+)
group by slots.slot, hist.dim,inter,sample_source
order by slots.slot,hist.dim]]></sql>
			<binds>
				<bind id="p_start_date">
					<prompt><![CDATA[start_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate-1 in that format]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_end_date">
					<prompt><![CDATA[end_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate in that format]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_interval">
					<prompt><![CDATA[interval in seconds]]></prompt>
					<tooltip><![CDATA[time slot in seconds, histogram width, in seconds, default 600]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_dim">
					<prompt><![CDATA[dimension]]></prompt>
					<tooltip><![CDATA[instance_number | con_id | user_id | session_sid | xid | sql_exec_id | sql_exec_id_plan | sql_exec_id_plan_oper | sql_id | current_obj# | module | program | action | machine | event | wait_class   Default wait_class]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[INST_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.inst_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_CON_ID">
					<prompt><![CDATA[CON_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.con_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SID">
					<prompt><![CDATA[SESSION_SID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sid]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SERIAL#">
					<prompt><![CDATA[SESSION_SERIAL#]]></prompt>
					<tooltip><![CDATA[V$SESSION.serial#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sql_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_TYPE">
					<prompt><![CDATA[SESSION_TYPE]]></prompt>
					<tooltip><![CDATA[FOREGROUND/BACKGROUND  default=both]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_USER_ID">
					<prompt><![CDATA[USER_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.user#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MODULE">
					<prompt><![CDATA[MODULE]]></prompt>
					<tooltip><![CDATA[V$SESSION.module]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PROGRAM">
					<prompt><![CDATA[PROGRAM]]></prompt>
					<tooltip><![CDATA[V$SESSION.program]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MACHINE">
					<prompt><![CDATA[MACHINE]]></prompt>
					<tooltip><![CDATA[V$SESSION.machine]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_WAIT_CLASS">
					<prompt><![CDATA[WAIT_CLASS]]></prompt>
					<tooltip><![CDATA[Administrative/Application/Cluster/Commit/Concurrency ...]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PLSQL_ENTRY_OBJECT_ID">
					<prompt><![CDATA[PLSQL_ENTRY_OBJECT_ID]]></prompt>
					<tooltip><![CDATA[DBA_OBJECTS.object_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_DBA_HIST_ONLY">
					<prompt><![CDATA[DBA_HIST_ONLY]]></prompt>
					<tooltip><![CDATA[yes/no  null=no, yes=only data from dba_hist_active_sess_history]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Report Parms]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[List report parameters plus useful info about the instance and the slot selected.]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as (select /*+ materialize NO_PARALLEL */
                     ash.*
                    ,parms.inter
                    ,count(*)                       over ()  cnt_tot
                    ,count(distinct ash.session_id) over ()  cnt_sid
                    ,count(distinct ash.sql_id)     over ()  cnt_sql_id
                    ,count(distinct xid)            over ()  cnt_xid
                    ,count(distinct sql_exec_id)    over ()  cnt_exec_id
                    ,count(distinct in_parse)       over ()  cnt_in_parse
                    ,count(distinct in_hard_parse)  over ()  cnt_in_hard_parse
                    ,count(distinct in_sql_execution)      over ()  cnt_in_sql_execution
                    ,count(distinct in_plsql_execution)    over ()  cnt_in_plsql_execution
                    ,count(distinct ash.program)    over ()  cnt_program
                    ,count(distinct ash.module)     over ()  cnt_module
                    ,count(distinct ash.machine)    over ()  cnt_machine
                from ( select ash.snap_id ,ash.dbid ,ash.con_id,ash.instance_number ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                       select 0           ,null     ,con_id    ,inst_id             ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end
                     ) ash ,parms)
select 'start_date' parameter   , to_char(start_date,'yyyy-mm-dd hh24:mi')     value                          ,'----','sample source              ' info     ,case when sample_source = 1 then 'v$active_session_history' else 'dba_hist_active_sess_history' end info_value from parms  union all
select 'end_date                ',to_char(end_date,'yyyy-mm-dd hh24:mi')                                      ,'----','cpu count                  '          ,(select sp.value from v$parameter sp  where name = 'cpu_count')                                                from parms  union all
select 'dim                     ',dim                                                                         ,'----','memory_target              '          ,(select sp.value from v$parameter sp  where name = 'memory_target')                                            from parms  union all
select 'inter                   ',to_char(parms.inter)                                                        ,'----','memory_max_target          '          ,(select sp.value from v$parameter sp  where name = 'memory_max_target')                                        from parms  union all
select 'start slot              ',to_char(cast(:SLOT as date),'yyyy-mm-dd hh24:mi:ss')                        ,'----','sga_target                 '          ,(select sp.value from v$parameter sp  where name = 'sga_target')                                               from parms  union all
select 'end   slot              ',to_char(cast(:SLOT as date)+ parms.inter/24/60/60 ,'yyyy-mm-dd hh24:mi:ss') ,'----','sga_max_target             '          ,(select sp.value from v$parameter sp  where name = 'sga_max_target')                                           from parms  union all
select 'instance_number         ',to_char(parms.instance_number)                                              ,'----','pga_aggregate_target       '          ,(select sp.value from v$parameter sp  where name = 'pga_aggregate_target')                                     from parms  union all
select 'con_id                  ',parms.con_id                                                                ,'----','slot samples               '          ,(select to_char(cnt_tot)        from ash where rownum < 2)                                                     from parms union all
select 'session_id              ',to_char(parms.session_id)                                                   ,'----','slot sessions              '          ,(select to_char(cnt_sid)        from ash where rownum < 2)                                                     from parms union all
select 'session_serial#         ',to_char(parms.session_serial#)                                              ,'----','slot distinct sql count    '          ,(select to_char(cnt_sql_id)     from ash where rownum < 2)                                                     from parms union all
select 'sql_id                  ',parms.sql_id                                                                ,'----','slot transactions          '          ,(select to_char(cnt_xid)        from ash where rownum < 2)                                                     from parms union all
select 'session_type            ',parms.session_type                                                          ,'----','slot exec_id               '          ,(select to_char(cnt_exec_id)    from ash where rownum < 2)                                                     from parms union all
select 'user_id                 ',to_char(parms.user_id)                                                      ,'----','slot in_parse              '          ,(select to_char(cnt_in_parse)               from ash where rownum < 2)                                         from parms union all
select 'module                  ',parms.module                                                                ,'----','slot in_hard_parse         '          ,(select to_char(cnt_in_hard_parse)          from ash where rownum < 2)                                         from parms union all
select 'program                 ',parms.program                                                               ,'----','slot in_sql_execution      '          ,(select to_char(cnt_in_sql_execution)       from ash where rownum < 2)                                         from parms union all
select 'machine                 ',parms.machine                                                               ,'----','slot in_plsql_execution    '          ,(select to_char(cnt_in_plsql_execution) from ash where rownum < 2)                                             from parms union all
select 'wait_class              ',parms.wait_class                                                            ,'----','slot program               '          ,(select to_char(cnt_program) from ash where rownum < 2)                                                        from parms union all
select 'plsql_entry_object_id   ',:P_PLSQL_ENTRY_OBJECT_ID                                                    ,'----','slot module                '          ,(select to_char(cnt_module)  from ash where rownum < 2)                                                        from parms union all
select 'dba_hist_only           ',:P_DBA_HIST_ONLY                                                            ,'----','slot machine               '          ,(select to_char(cnt_machine) from ash where rownum < 2)                                                        from parms union all
select '----','----','----','----','----' from dual]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[Counts of the samples grouped by  slot dim event]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000)     total_wait_time_ms 
	,round(avg(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000,2)   avg_wait_time_ms 
	,count(ash.sample_id)        over (partition by ash.instance_number,ash.con_id,ash.event)           cnt_event
	,count(*)                    over (partition by ash.instance_number,ash.con_id)                     cnt_ash_con
	,count(*)                    over ()                                                                cnt_ash_inst
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
	cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by cnt_event desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions all]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */
    --ash.sample_id
    to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')     sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    ,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.plsql_entry_object_id                            --Object ID of the top-most PL/SQL subprogram on the stack (or NULL if there is no PL/SQL subprogram on the stack)
    ,'SQLDEV:LINK:'||peoi.owner||':'||peoi.object_type||':'||peoi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' top_plsql
    --,ash.plsql_entry_subprogram_id
    ,preoi.procedure_name top_plsql_proc
    --,ash.plsql_object_id                                  --Object ID of the currently executing PL/SQL subprogram (or NULL if executing SQL)
    ,'SQLDEV:LINK:'||poi.owner||':'||poi.object_type||':'||poi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' plsql
    --,ash.plsql_subprogram_id
    ,proi.procedure_name plsql_proc
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    ,ash.in_parse
    ,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,to_char(ash.pga_allocated/1024/1024,'FM999999999.90') pga_allocated_mb
    ,case when ash.temp_space_allocated != 0 then to_char(ash.temp_space_allocated/1024/1024,'FM999999999.90') else to_char(ash.temp_space_allocated) end temp_space_allocated_mb
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
        cross join  parms
        left  outer join cdb_users u            on ash.user_id = u.user_id and ash.con_id = u.con_id
        left  outer join gv$event_name e        on ash.instance_number = e.inst_id and ash.event_id = e.event_id
        left  outer join cdb_objects o          on ash.current_obj# = o.object_id and ash.con_id = o.con_id
        left  outer join cdb_objects peoi       on ash.plsql_entry_object_id = peoi.object_id and ash.con_id = peoi.con_id
        left  outer join cdb_procedures preoi   on ash.plsql_entry_object_id = preoi.object_id and ash.plsql_entry_subprogram_id = preoi.subprogram_id and ash.con_id = preoi.con_id
        left  outer join cdb_objects poi        on ash.plsql_object_id = poi.object_id and ash.con_id = poi.con_id
        left  outer join cdb_procedures proi    on ash.plsql_object_id = proi.object_id and ash.plsql_subprogram_id = proi.subprogram_id and ash.con_id = proi.con_id
        left  outer join gv$datafile f          on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
    ------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id      = nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by sample_time asc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */
	 :DIM dim
    --ash.sample_id
    ,to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')	 sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    --,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    ,ash.plsql_entry_object_id
    ,ash.plsql_entry_subprogram_id
    ,ash.plsql_object_id
    ,ash.plsql_subprogram_id
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    --,ash.in_parse
    --,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,ash.temp_space_allocated
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
    left  outer join gv$event_name e	on ash.instance_number = e.inst_id and ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
    left  outer join gv$datafile f		on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by sample_time asc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                            cnt_ash_con
   	,count(*)                       over ()                                                                                       cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.event
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000)          total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000,2)        avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)  cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                        cnt_ash_con
	,count(*)               over ()                                                                   cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event/plan]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||o.owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,o.subobject_name
    ,o.object_type
    ,ash.current_obj#
    ,sql_opname
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_plan_operation	
    ,sql_plan_options	
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000,2) avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)    cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Plan Line by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/event by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps cross join parms where not (snaps.begin_interval_time > parms.end_date or snaps.end_interval_time < parms.start_date) and snaps.instance_number = nvl(parms.instance_number, snaps.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.event
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_event
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join v$event_name e		on ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[ASH text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
     parms as ( select 
                     nvl(to_number(:p_interval),600)                              inter
                    ,cast(:SLOT as date)                                          start_date_slot
                    ,cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 end_date_slot
                    ,sys_context('USERENV', 'DB_NAME')                            db_name
                    ,sys_context('USERENV', 'INSTANCE_NAME')                      instance_name
                    ,sys_context('USERENV', 'INSTANCE')                           instance_number
                    ,(select nvl(dbid,(select dbid from v$database)) from dba_hist_active_sess_history where sample_time between cast(:SLOT as date)  and cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 and rownum < 2) dbid
               from dual)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(start_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt' ||' -->' output from parms
union all
select output from parms,table(dbms_workload_repository.ash_report_text(dbid,instance_number,start_date_slot,end_date_slot))]]></sql>
				<binds>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="9d63a4bf-0183-1000-8001-c0a83801a02f" type="" style="Chart" enable="true">
		<name><![CDATA[Masked Devops AWR Reports + Time Model]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[Hours]]></Y1AXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<STYLE><![CDATA[Default]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<XAXIS_TITLE><![CDATA[true]]></XAXIS_TITLE>
			<THREED><![CDATA[false]]></THREED>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<XAXIS_TITLE_TEXT><![CDATA[End Interval Time]]></XAXIS_TITLE_TEXT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
--https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/V-SESS_TIME_MODEL.html#GUID-B5CF4362-325D-4F22-9A08-0873FA32A5C0
--''Db time'' Statistics Value is not Equal to the Sum of Children Statistic Times (Doc ID 356885.1)
-- 1) background elapsed time
--     2) background cpu time
--           3) RMAN cpu time (backup/restore)
-- 1) DB time
--     2) DB CPU
--     2) connection management call elapsed time
--     2) sequence load elapsed time
--     2) sql execute elapsed time
--     2) parse time elapsed
--           3) hard parse elapsed time
--                 4) hard parse (sharing criteria) elapsed time
--                     5) hard parse (bind mismatch) elapsed time
--           3) failed parse elapsed time
--                 4) failed parse (out of shared memory) elapsed time
--     2) PL/SQL execution elapsed time
--     2) inbound PL/SQL rpc elapsed time
--     2) PL/SQL compilation elapsed time
--     2) Java execution elapsed time
--     2) repeated bind elapsed time
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE')) instance_number
		  from dual)
select
	 to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
	,stat_name
	,case when (value - value_prev) < 0 then 0 else	 (value - value_prev)/1000000/60/60 end value_hr
from (	select
			end_interval_time
			,stat_name
			,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
			,lag(value) over (order by stat_name,end_interval_time) value_prev
			,value
		from dba_hist_sys_time_model hstm
			join dba_hist_snapshot hs on hstm.dbid = hs.dbid and hstm.instance_number = hs.instance_number and hstm.snap_id = hs.snap_id
	),parms
where stat_name =stat_name_prev
	--and stat_name = 'DB time'
	and not regexp_like(stat_name,'DB time|^hard parse|^failed parse|cpu time')
	and end_interval_time between  parms.start_date and parms.end_date
order by end_interval_time asc]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Info]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from (
		select
			 di.db_name
			,di.instance_name
			,s.snap_id
			,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
			,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
			,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
			,di.dbid
			,di.instance_number
			,s.begin_interval_time begin_time
			,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
	)
where  end_interval_time=  to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_report_text(dbid,instance_number,snap_id_prev,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="plsql-dbms_output" enable="true">
			<name><![CDATA[AWR html]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[--select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
--union all
--select output from snaps,table(dbms_workload_repository.awr_report_html(dbid,instance_number,snap_id_prev,snap_id))

begin
    dbms_output.enable (buffer_size => null);
    for awr in (
        with snaps
            as (select *
                from (
                        select
                             di.db_name
                            ,di.instance_name
                            ,s.snap_id
                            ,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
                            ,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
                            ,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
                            ,di.dbid
                            ,di.instance_number
                            ,s.begin_interval_time begin_time
                        from dba_hist_snapshot s
                            left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
                                )
                            where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
                )
    select output from snaps,table(dbms_workload_repository.awr_report_html(snaps.dbid,snaps.instance_number,snaps.snap_id_prev,snaps.snap_id))
    )
    loop
        dbms_output.put_line(awr.output);
    end loop;
end;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR text global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_global_report_text(dbid,'',snap_id_prev ,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR html global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_global_report_html(dbid,'',snap_id_prev ,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
                )
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_report_text(dbid,instance_number,begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH html]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_report_html(dbid,instance_number,begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH text global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_global_report_text(dbid,'',begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH html global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_global_report_html(dbid,'',begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[ADDM text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on
with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'addm_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select dbms_advisor.get_task_report('ADDM:'||dbid||'_'||instance_number||'_'||snap_id,'TEXT','ALL','ALL','SYS') as report  FROM	   snaps,dual;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ADDM findings]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	 find.task_id
	,find.finding_id
	,find.finding_name
	,find.type				finding_type
	,find.impact			finding_impact
	,trim(find.message)		finding_message
	,rec.rec_id
	,rec.type				reccomendation_type
	,rec.benefit_type
	,rec.benefit
	,rat.rationale_id
	,rat.impact_type
	,rat.impact
	,rat.message
from dba_advisor_findings find,dba_advisor_recommendations rec,dba_advisor_rationale rat
where 1=1
	and find.task_id = rec.task_id(+)
	and find.finding_id = rec.finding_id(+)
	and rec.task_id = rat.task_id(+)
	and rec.rec_id = rat.rec_id(+)
	and find.task_id = (select task_id from dba_advisor_tasks where task_name = 'ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:SNAP_ID)
order by find.finding_id,rec.rec_id,rat.rationale_id]]></sql>
			</query>
		</display>
	</display>
	<display id="9e1ec4ee-0183-1000-8002-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops SQL History]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
select /*+ NO_PARALLEL */
     plan_cnt           cnt   
    ,plan_rank          rnk
    ,version_count      vers
    ,snap_id            snap
    ,inst
    ,c.name con_name
    ,sa.sql_id
    ,plan_hash_value
    --,plan_hash_value_prev
    --,plan_hash_value_next
    ,sql_profile
    --,extractvalue(  other_xml, '/*/info[@type = "baseline"]' ) baseline
    ,begin_snap
    ,tot_time_sec
    ,executions
    ,avg_time_sec
    ,avg_cpu_sec
    ,avg_iowait_sec
    ,avg_application_sec
    ,avg_concurrency_sec
    ,avg_cluster_sec
    ,avg_plsql_sec
    ,avg_java_sec
    ,avg_disk_reads
    ,avg_buffer_gets
    ,avg_rows_processed
    ,avg_sorts
    ,avg_fetches
    ,parsing_schema_name
    ,sql_text
    ,bind_data
    ,sa.dbid
    ,sa.con_dbid
    ,sa.con_id
    ,instance_number
    ,inst_id
    ,begin_interval_time
    ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day')   end_interval_time_char
    ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss day') begin_interval_time_char
    ,end_interval_time
    ,p_sql_id
    ,:REPORTS_DEST_DIR
    ,:SQLT_DIR
from (
    select
         count(distinct plan_hash_value)	   over (partition by s.sql_id )					   plan_cnt	-- sql_id/plans total
        ,dense_rank()	over (partition by s.sql_id order by plan_hash_value)					   plan_rank	-- sql_id/plans item
        ,s.snap_id
        ,s.instance_number    inst
        ,s.con_id            
        ,s.sql_id
        ,s.version_count
        ,s.plan_hash_value  
        ,lag(s.plan_hash_value)  over (partition by s.sql_id,con_id,s.con_dbid order by begin_interval_time) plan_hash_value_prev
        ,lead(s.plan_hash_value) over (partition by s.sql_id,con_id,s.con_dbid order by begin_interval_time) plan_hash_value_next
        ,s.sql_profile
        --,begin_interval_time
        ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss day')   begin_snap
        ,to_char(round(elapsed_time_delta/1000000,3),'9999990.990')	tot_time_sec
        ,s.executions_delta                                         executions
        ,to_char(case when executions_delta > 0 then trunc(elapsed_time_delta			/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_time_sec
        ,to_char(case when executions_delta > 0 then lag(trunc(elapsed_time_delta		/1000000/executions_delta,4))	over (partition by s.sql_id order by begin_interval_time) else null end,'9999990.990')	 avg_time_sec_prev
        ,to_char(case when executions_delta > 0 then round(cpu_time_delta				/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_cpu_sec
        ,to_char(case when executions_delta > 0 then round(iowait_delta					/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_iowait_sec
        ,to_char(case when executions_delta > 0 then round(apwait_delta					/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_application_sec
        ,to_char(case when executions_delta > 0 then round(ccwait_delta					/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_concurrency_sec
        ,to_char(case when executions_delta > 0 then round(clwait_delta					/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_cluster_sec
        ,to_char(case when executions_delta > 0 then round(plsexec_time_delta			/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_plsql_sec
        ,to_char(case when executions_delta > 0 then round(javexec_time_delta			/1000000/executions_delta,4)	else 0 end,'99990.990')	 avg_java_sec
        ,case when executions_delta > 0 then round(disk_reads_delta						/executions_delta,3)	else 0 end	 avg_disk_reads
        ,case when executions_delta > 0 then round(buffer_gets_delta					/executions_delta,3)	else 0 end	 avg_buffer_gets
        ,case when executions_delta > 0 then round(rows_processed_delta					/executions_delta,3)	else 0 end	 avg_rows_processed
        ,case when executions_delta > 0 then round(sorts_delta							/executions_delta,3)	else 0 end	 avg_sorts
        ,case when executions_delta > 0 then round(fetches_delta						/executions_delta,3)	else 0 end	 avg_fetches
        ,parsing_schema_name
        ,substr(sql_text,1,1000)	 sql_text
        ,utl_raw.cast_to_varchar2(bind_data) bind_data
        --,module
        --,action
        ,s.dbid
        ,s.con_dbid
        ,s.instance_number
        ,s.instance_number inst_id
        ,s.end_interval_time
        ,s.begin_interval_time
        ,s.sql_id p_sql_id
        from (	select s.snap_id,s.instance_number,s.con_id, s.con_dbid, s.sql_id,null,s.plan_hash_value,							   s.sql_profile,begin_interval_time,end_interval_time, executions_delta,elapsed_time_delta,cpu_time_delta,iowait_delta,apwait_delta,ccwait_delta,clwait_delta,plsexec_time_delta,javexec_time_delta,disk_reads_delta,buffer_gets_delta,rows_processed_delta,s.sorts_delta,s.fetches_delta,s.parsing_schema_name,t.sql_text,s.dbid,s.version_count,s.bind_data 
                from dba_hist_sqlstat s 
                    join dba_hist_snapshot snap on s.snap_id = snap.snap_id and s.dbid = snap.dbid and s.instance_number = snap.instance_number -- pk=snap_id dbid
                    join dba_hist_sqltext t     on s.sql_id = t.sql_id      and s.dbid = t.dbid and s.con_dbid = t.con_dbid   
                union all
                select 0 snap_id,s.inst_id        ,s.con_id, s.con_dbid,s.sql_id,s.last_active_child_address,s.plan_hash_value,null as sql_profile, s.last_active_time ,null              ,executions,elapsed_time,cpu_time,user_io_wait_time,application_wait_time,concurrency_wait_time,cluster_wait_time,plsql_exec_time,java_exec_time,disk_reads,buffer_gets,rows_processed,sorts,fetches,null as parsing_schema_name,sql_fulltext,null,s.version_count,null 
                from gv$sqlstats s  --where s.last_active_time > trunc(sysdate,'HH')
                ) s
    where 1=1
        and s.sql_id =  case 
                            when :SQL_ID is null and :DIM is not null then :DIM 
                            when :SQL_ID is not null                  then :SQL_ID
                            else s.sql_id 
                        end
        and ((s.con_id is not null and s.con_id = :CON_ID)  or :CON_ID is null)
    ) sa
    join (select con_id,name from gv$containers) c on sa.con_id = c.con_id
where 1=1
        and plan_hash_value = case when :PLAN_CHANGE is not null  then case when plan_hash_value != plan_hash_value_prev or plan_hash_value != plan_hash_value_next then plan_hash_value else null end
                             else plan_hash_value
                        end
order by sa.sql_id,sa.begin_interval_time]]></sql>
			<binds>
				<bind id="REPORTS_DEST_DIR">
					<prompt><![CDATA[REPORTS_DEST_DIR]]></prompt>
					<tooltip><![CDATA[Destination forlder for AWR/ASH reports]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQLT_DIR">
					<prompt><![CDATA[SQLT_DIR]]></prompt>
					<tooltip><![CDATA[SQLT_DIR]]></tooltip>
					<value><![CDATA[/home/oracle/sqlt]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[gzhkw1qu6fwxm]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="DIM">
					<prompt><![CDATA[DIM]]></prompt>
					<tooltip><![CDATA[Ignore, parameter from other reports]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CON_ID">
					<prompt><![CDATA[CON_ID]]></prompt>
					<tooltip><![CDATA[CON_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_CHANGE">
					<prompt><![CDATA[PLAN_CHANGE]]></prompt>
					<tooltip><![CDATA[Filter sql with plan changes, any not null value to filter, NULL=no filter]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sql fulltext]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 'gv$sqlstats' dict_view, null dbid,sql_fulltext	   from gv$sqlstats where inst_id = :INSTANCE_NUMBER and sql_id = :SQL_ID and plan_hash_value = :PLAN_HASH_VALUE
union all
select 'dba_hist_sqltext' dict_view,dbid, sql_text	from dba_hist_sqltext where sql_id = :SQL_ID and rownum < 2]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[gv$sql]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */
	--,sql_text
	--,sql_fulltext
	sql_id
	,child_number
	,plan_hash_value
	,sql_profile
	,sql_plan_baseline
	,executions
	,to_char(last_active_time,'yyyy-mm-dd hh24:mi:ss') last_active_time
	,first_load_time
	,parsing_schema_name
	,exact_matching_signature
	,is_obsolete
	,is_bind_sensitive
	,is_bind_aware
	,is_shareable
	,program_id
	,sharable_mem
	,persistent_mem
	,runtime_mem
	,sorts
	,loaded_versions
	,open_versions
	,users_opening
	,fetches
	,px_servers_executions
	,end_of_fetch_count
	,users_executing
	,loads
	,invalidations
	,parse_calls
	,disk_reads
	,direct_writes
	,buffer_gets
	,application_wait_time
	,concurrency_wait_time
	,cluster_wait_time
	,user_io_wait_time
	,plsql_exec_time
	,java_exec_time
	,rows_processed
	,command_type
	,optimizer_mode
	,optimizer_cost
	,optimizer_env
	,optimizer_env_hash_value
	,parsing_user_id
	,parsing_schema_id
	,kept_versions
	,address
	,type_chk_heap
	,hash_value
	,old_hash_value
	,service
	,service_hash
	,module
	,module_hash
	,action
	,action_hash
	,serializable_aborts
	,outline_category
	,cpu_time
	,elapsed_time
	,outline_sid
	,child_address
	,sqltype
	,remote
	,object_status
	,literal_hash_value
	,last_load_time
	,child_latch
	,sql_patch
	,program_line#
	,force_matching_signature
	,bind_data
	,typecheck_mem
	,io_cell_offload_eligible_bytes
	,io_interconnect_bytes
	,physical_read_requests
	,physical_read_bytes
	,physical_write_requests
	,physical_write_bytes
	,optimized_phy_read_requests
	,locked_total
	,pinned_total
	,io_cell_uncompressed_bytes
	,io_cell_offload_returned_bytes
from gv$sql where inst_id = :INSTANCE_NUMBER and sql_id = :SQL_ID
order by child_number]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[binds]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
     sql_plan         as (select ' ' view_name ,to_char(child_number)  ,to_char(bind_pos),to_char(bind_type)  ,bind_name     ,case when c.bind_type = 1 then utl_raw.cast_to_varchar2(c.bind_data) when c.bind_type = 2 then to_char(utl_raw.cast_to_number(c.bind_data)) when c.bind_type = 96 or c.bind_type = 23 then to_char(utl_raw.cast_to_varchar2(c.bind_data)) else 'Not printable try with DBMS_XPLAN.DISPLAY_CURSOR' end bind_data,to_char(p.timestamp,'yyyy-mm-dd hh24:mi:ss')  from gv$sql_plan p,xmltable ( '/*/peeked_binds/bind' passing xmltype(p.other_xml)columns bind_name varchar2(100) path '/bind/@nam',bind_pos number path '/bind/@pos',bind_type number path '/bind/@dty',bind_data raw(2000) path '/bind' ) c where 1=1 and p.other_xml is not null and p.inst_id = :INST_ID and p.sql_id = :SQL_ID  order by child_number, c.bind_pos)
    ,sql_bind_capture as (select ' ' view_name ,to_char(child_number)  ,to_char(position),datatype_string     ,name          ,value_string,to_char(last_captured,'yyyy-mm-dd hh24:mi:ss')      from gv$sql_bind_capture   where inst_id = 1   and sql_id = :SQL_ID  order by child_number, position)
    ,sql              as (select ' ' view_name ,to_char(child_number)  ,to_char(position),datatype_string     ,name          ,value_string,to_char(last_active_time,'yyyy-mm-dd hh24:mi:ss')   from gv$sql,table(dbms_sqltune.extract_binds(bind_data)) where inst_id = :INST_ID and sql_id = :SQL_ID order by child_number, position)
    ,hist_sqlstat     as (select ' ' view_name ,null                   ,to_char(position),datatype_string     ,name          ,value_string ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') from dba_hist_sqlstat dhs join dba_hist_snapshot snap on dhs.snap_id = snap.snap_id  and dhs.instance_number = snap.instance_number cross join table(dbms_sqltune.extract_binds(bind_data)) where end_interval_time > sysdate - 1 and dhs.sql_id = :SQL_ID and dhs.instance_number = :INST_ID order by end_interval_time,position)
    ,hist_sqlbind     as (select ' ' view_name ,null                   ,to_char(position),datatype_string     ,name          ,value_string ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') from dba_hist_sqlbind dhs join dba_hist_snapshot snap on dhs.snap_id = snap.snap_id  and dhs.instance_number = snap.instance_number and dhs.dbid = snap.dbid where  dhs.sql_id = :SQL_ID and dhs.instance_number = :INST_ID order by end_interval_time,dhs.position)
select 'GV$SQL_PLAN peeked'                  view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql_plan                       union all                                                                  
select 'GV$SQL_BIND_CAPTURE'                 view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql_bind_capture               union all                                                                  
select 'GV$SQL'                              view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql                            union all                                                                  
select 'DBA_HIST_SQLSTAT'                    view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from hist_sqlstat                   union all                                                                  
select /*+ NO_PARALLEL */ 'DBA_HIST_SQLBIND' view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from hist_sqlbind]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[exec]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set linesize 20000 heading off pages 0 feedback off heading off long 100000 longchunksize 1000000
col sql_text for a10000 word_wrapped
select 'set linesize 20000 pages 10000 long 100000' from dual;
select 'alter session set statistics_level = all;' from dual;
select 'alter session set current_schema = '||:PARSING_SCHEMA_NAME||';' from dual;
select '--NLS_DATE_FORMAT='||sys_context('USERENV','NLS_DATE_FORMAT') nls_date_format from dual;
select '--alter session set nls_date_format =''yyyy-mm-dd hh24:mi:ss'';' from dual;
prompt
prompt
select '--Declare bind variables' from dual;
select 'variable '||ltrim(name,':')||' '||case when datatype_string = 'DATE' then 'VARCHAR2  ---DATE' else datatype_string end
from  dba_hist_sqlbind hsb
where hsb.sql_id = :SQL_ID and snap_id = :SNAP
order by last_captured,position;
prompt
select '--Exec bind variables' from dual;
select /*+ NO_PARALLEL */ 'exec '||name||' := '||
case sys.anydata.gettypename(value_anydata)
		when null				then	'null'
		when 'SYS.BDOUBLE'		then	to_char(sys.anydata.accessbdouble(value_anydata))
		--when 'SYS.BFILE'		  then	  sys.anydata.AccessBfile(value_anydata)
		when 'SYS.BFLOAT'		then	to_char(sys.anydata.accessbfloat(value_anydata))
		--when 'SYS.BLOB'		  then	  sys.anydata.AccessBlob(value_anydata)
		when 'SYS.CHAR'			then	''''||sys.anydata.accesschar(value_anydata)||''''
		when 'SYS.CLOB'			then	to_char(sys.anydata.accessclob(value_anydata))
		when 'SYS.DATE'			then	 ''''||to_char(sys.anydata.accessdate(value_anydata), 'yyyy-mm-dd hh24:mi:ss')||'''' ||'		--to_date('||name||',''yyyy-mm-dd hh24:mi:ss'')'
		--when 'SYS.INTERVALYM'	  then	  sys.anydata.AccessIntervalYM(value_anydata)
		--when 'SYS.INTERVALDS'	  then	  sys.anydata.AccessIntervalDS(value_anydata)
		--when 'SYS.NCHAR'		  then	  sys.anydata.AccessNchar(value_anydata)
		--when 'SYS.NCLOB'		  then	  sys.anydata.AccessNClob(value_anydata)
		when 'SYS.NUMBER'		then	to_char(sys.anydata.accessnumber(value_anydata))
		--when 'SYS.NVARCHAR2'	  then	  sys.anydata.AccessNVarchar2(value_anydata)
		--when 'SYS.RAW'		  then	  sys.anydata.AccessRaw(value_anydata)
		when 'SYS.TIMESTAMP'	then	''''||to_char(sys.anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss')||''''||'		  --to_timestamp('||name||',''yyyy-mm-dd hh24:mi:ss'')'
		when 'SYS.TIMESTAMPLTZ' then	to_char(sys.anydata.AccessTimestampLTZ(value_anydata),'yyyy-mm-dd hh24:mi:ss')
		when 'SYS.TIMESTAMPTZ'	then	to_char(sys.anydata.AccessTimestampTZ(value_anydata),'yyyy-mm-dd hh24:mi:ss')
		--when 'SYS.UROWID'		  then	  sys.anydata.AccessURowid(value_anydata)
		when 'SYS.VARCHAR'		then	''''||sys.anydata.accessvarchar(value_anydata)||''''
		when 'SYS.VARCHAR2'		then	''''||sys.anydata.accessvarchar2(value_anydata)||''''
		else 'null'
	end || '     --last_captured='|| to_char(last_captured,'yyyy-mm-dd hh24:mi:ss') ||', position='||position
from  dba_hist_sqlbind hsb
where sql_id = :SQL_ID and snap_id = :SNAP and instance_number = :INST and dbid = :DBID and hsb.con_id = :CON_ID
order by last_captured,position;
prompt
prompt
select '--SQL text' from dual;
select sql_text||';' sql_text
from dba_hist_sqltext t
where t.sql_id = :SQL_ID and t.dbid = :DBID and rownum < 2;
prompt
prompt
select 'select * from table(dbms_xplan.display_cursor(null,null,''allstats last +peeked_binds +alias +bytes''));' from dual;
select 'select * from table(dbms_xplan.display_cursor('''||:SQL_ID||''',null,''advanced''));' from dual;
select 'select * from table(dbms_xplan.display_awr('''||:SQL_ID||''',null,null,''advanced''));' from dual;

prompt
prompt
prompt]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[display awr]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[--select * from table(dbms_xplan.display_awr( :SQL_ID,:PLAN_HASH_VALUE,:DBID,'advanced'));
--select 'select * from table(dbms_xplan.display_awr('''||:SQL_ID||''', '||:PLAN_HASH_VALUE||', '||:DBID||', ''advanced''));' "Run in the pdb" from dual;
set serveroutput on size unlimited
set lines 10000
declare
    l_cursor        pls_integer;
    l_reports       dbms_sql.varchar2_table;   
    l_output        varchar2(1000);   
    l_rows          number;
begin
    l_cursor := dbms_sql.open_cursor(security_level => 2);
    dbms_sql.parse( c => l_cursor,
                        statement     => 'select plan_table_output output from table(dbms_xplan.display_awr( :SQL_ID,:PLAN_HASH_VALUE,:DBID,''advanced''))',
                        language_flag => dbms_sql.native,
                        container     => :CON_NAME);
    dbms_sql.bind_variable(l_cursor, ':SQL_ID', :SQL_ID);                   
    dbms_sql.bind_variable(l_cursor, ':PLAN_HASH_VALUE', :PLAN_HASH_VALUE);                   
    dbms_sql.bind_variable(l_cursor, ':DBID', :DBID);                   
    l_rows := dbms_sql.execute(c => l_cursor);
    dbms_sql.define_column(l_cursor, 1, l_output, 1000); 
    loop 
        if dbms_sql.fetch_rows(l_cursor) > 0 then 
            -- get column values of the row 
            dbms_sql.column_value(l_cursor, 1, l_output); 
            dbms_output.put_line(l_output); 
        else 
            -- no more rows 
            exit; 
        end if; 
    end loop;  
    dbms_sql.close_cursor(c => l_cursor);
END;
/]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[display cursor]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select * from table(dbms_xplan.display_cursor( :SQL_ID,:CHILD_NUMBER,'advanced'))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[load sql_plan_baseline]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set linesize 20000 heading off pages 0 feedback off heading off long 100000 longchunksize 1000000
col sql_text for a10000 word_wrapped
select '--!!!Create baseline first to have the steps to modify/export.!!!'||chr(10)||chr(10) from dual;


select
	'set serveroutput on;'||chr(10)||
	'exec dbms_sqltune.drop_sqlset(sqlset_name=>'''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''');'||chr(10)||
	'exec dbms_sqltune.create_sqlset(sqlset_name => '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''', description => '':SNAP='||:SNAP||',:SQL_ID='||:SQL_ID||',:PLAN_HASH_VALUE='||:PLAN_HASH_VALUE||''');'||chr(10)||
	'declare'||chr(10)||
	chr(9)||'cur       sys_refcursor;'||chr(10)||
	chr(9)||'l_plan    pls_integer;'||chr(10)||
	'begin	'||chr(10)||
	chr(9)||'open cur for select value(p) from table(dbms_sqltune.select_workload_repository(begin_snap=> '||to_char(:SNAP-1)||',end_snap => '||:SNAP||',basic_filter => ''sql_id = '''''||:SQL_ID||''''' or plan_hash_value = '''''||:PLAN_HASH_VALUE||''''''',attribute_list=>''ALL'', dbid => '||:DBID||') ) p;'||chr(10)||
	chr(9)||'dbms_sqltune.load_sqlset( sqlset_name=> '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''', populate_cursor=>cur);'||chr(10)||
	chr(9)||'close cur;'||chr(10)||
	chr(9)||'execute immediate ''alter session set tracefile_identifier=load_plans_from_sqlset'';'||chr(10)||
	chr(9)||'dbms_spm.configure(''spm_tracing'',1); -- trace on'||chr(10)||
    chr(9)||'l_plan := dbms_spm.load_plans_from_sqlset(sqlset_name => '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''',basic_filter=>''plan_hash_value = '''''||:PLAN_HASH_VALUE||''''''');'||chr(10)||
	chr(9)||'dbms_spm.configure(''spm_tracing'',0); -- trace off'||chr(10)||
	chr(9)||'dbms_output.put_line(''Plans Loaded: '' || l_plan);'||chr(10)||
	'end;'||chr(10)||
	'/'||chr(10)
    sql_text
from dual;

select 'select * from table(dbms_sqltune.select_sqlset('''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||'''));'||chr(10) sql_text from dual; 
select 'select * from   dba_sql_plan_baselines;'||chr(10) sql_text from dual;

select
    '-- If replace with a hinted plan run:'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    'variable l_rc number'||chr(10)||
    'exec :l_rc := dbms_spm.load_plans_from_cursor_cache(sql_id => ''xxxxx'',plan_hash_value => ''000000'',sql_handle => '''||sql_handle||''',fixed => ''YES'' );'||chr(10)||
    'print :l_rc'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    'exec :l_rc := dbms_spm.drop_sql_plan_baseline (sql_handle => '''||sql_handle||''',plan_name  => '''||plan_name||''');'||chr(10)||
    'print :l_rc'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    chr(10)
from dba_sql_plan_baselines, (select :SQL_ID sql_id from dual) sql
where 1=1 
and (  signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sqlstats where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql_monitor where sql_id=sql.sql_id)
    );
    
    
select
    '-- If export baseline run:'||chr(10)||
    '--SOURCE'||chr(10)||
    'exec dbms_spm.create_stgtab_baseline(''STGTAB'', ''SYSTEM'');'||chr(10)||
    'variable l_rc number'||chr(10)||
    'exec :l_rc := dbms_spm.pack_stgtab_baseline(''STGTAB'', ''SYSTEM'', sql_handle => '''||sql_handle||''', plan_name => '''||plan_name||''' );'||chr(10)||
    'print :l_rc'||chr(10)||
    'create or replace directory DPDIR as ''/oraback/Adhoc/exports'';'||chr(10)||
    'expdp \''/ as sysdba\'' TABLES=system.stgtab  dumpfile=${ORACLE_SID}.stgtab.$(date ''+%Y-%m-%d_%H%M%S'').dmp  logfile=${ORACLE_SID}.stgtab.$(date ''+%Y-%m-%d_%H%M%S'').log directory=dpdir'||chr(10)||
    'scp /oraback/Adhoc/exports/NWMU.stgtab.2016-06-13_113507.dmp  v06summ5t:/oraback/Adhoc/exports'||chr(10)||
    'drop table system.stgtab;'||chr(10)||
    '--TARGET'||chr(10)||
    'create or replace directory DPDIR as ''/oraback/Adhoc/exports'';'||chr(10)||
    'impdp \''/ as sysdba\'' TABLES=system.stgtab  dumpfile=ORCL.stgtab.YYYY-MM-DD_HH24MISS.dmp  logfile=${ORACLE_SID}.stgtab.import.$(date ''+%Y-%m-%d_%H%M%S'').log directory=dpdir'||chr(10)||
    'var x number;'||chr(10)||
    'exec :x := dbms_spm.unpack_stgtab_baseline(''STGTAB'', ''SYSTEM'');'||chr(10)||
    chr(10)
from dba_sql_plan_baselines, (select :SQL_ID sql_id from dual) sql
where 1=1 
and (  signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sqlstats where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql_monitor where sql_id=sql.sql_id)
    );]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sql_profile hint]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */ hint
from (select p.name, p.signature, p.category,
			 row_number() over (partition by sd.signature, sd.category order by sd.signature) row_num,
			 extractValue(value(t), '/hint') hint
	  from sys.sqlobj$data sd, dba_sql_profiles p, table(xmlsequence(extract(xmltype(sd.comp_data),'/outline_data/hint'))) t
	  where sd.obj_type = 1
	  and p.signature = sd.signature
	  and p.name like nvl(:SQL_PROFILE,name)
)]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[load sql_profile]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select	/*+ NO_PARALLEL */  																		chr(10)||
'--ORA-13786 -> run as sysdba'||chr(10)||
'set serveroutput on echo on'||chr(10)||
'variable tuning_task varchar2(100)																 '||chr(10)||
'variable sql_id	  varchar2(100)																 '||chr(10)||
'variable profile	  varchar2(100)																 '||chr(10)||
'exec :tuning_task := ''tuning_task_'||:SQL_ID||''';											 '||chr(10)||
'exec :profile	   := ''profile_'||:SQL_ID||''';												 '||chr(10)||
'exec :SQL_ID	   := '''||:SQL_ID||''';														 '||chr(10)||
'-- drop tuning task'||chr(10)||
'exec begin dbms_sqltune.drop_tuning_task(task_name => :tuning_task); exception when others then null; end;'||chr(10)||
'-- drop sql profile'||chr(10)||
'--exec dbms_sqltune.drop_sql_profile (name => :profile, ignore => true);						 '||chr(10)||
'-- create tuning task																			 '||chr(10)||
'begin																							 '||chr(10)||
'  :tuning_task := dbms_sqltune.create_tuning_task (											 '||chr(10)||
case when :SNAP > 0 then '						   begin_snap  => '||(:SNAP -1)||', end_snap => '||:SNAP||','||chr(10) else null end ||
'						   sql_id	   => :sql_id,												 '||chr(10)||
'						   scope	   => dbms_sqltune.scope_comprehensive,						 '||chr(10)||
'						   time_limit  => 60,													 '||chr(10)||
'						   task_name   => :tuning_task,											 '||chr(10)||
'						   description => ''Tuning task for statement ''||:SQL_ID||''.'');		 '||chr(10)||
'  dbms_output.put_line(''sql_tune_task_id: '' || :tuning_task);								 '||chr(10)||
'  dbms_sqltune.execute_tuning_task(:tuning_task);												 '||chr(10)||
'  dbms_output.put_line(:tuning_task);															 '||chr(10)||
'end;																							 '||chr(10)||
'/																								 '||chr(10)||
'set long 80000 pages 1000 line 200																 '||chr(10)||
'col report format a130																			 '||chr(10)||
'select dbms_sqltune.report_tuning_task(:tuning_task) report from dual;									'||chr(10)||
'select rat.attr1 from sys.wri$_adv_tasks tsk, sys.wri$_adv_rationale rat where tsk.name = :tuning_task and rat.task_id = tsk.id ;'||chr(10)||
'begin																							 '||chr(10)||
'	 dbms_sqltune.accept_sql_profile( task_name => :tuning_task,								 '||chr(10)||
'									 task_owner =>	sys_context(''USERENV'', ''SESSION_USER''),	 '||chr(10)||
'									 name => :profile,											 '||chr(10)||
'									 description => ''profile for '||:SQL_ID||''',				 '||chr(10)||
'									 --category => ''TEST'',									 '||chr(10)||
'									 replace => TRUE,											 '||chr(10)||
'									 force_match => TRUE,										 '||chr(10)||
'									 profile_type => DBMS_SQLTUNE.PX_PROFILE					 '||chr(10)||
'	 );																							 '||chr(10)||
'end;																							 '||chr(10)||
'/																								 '||chr(10)||
'col created for a30																			 '||chr(10)||
'select name,status,created from dba_sql_profiles where name = :profile;						 '||chr(10)||
																									chr(10)	  load_profile
from dual]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[stats]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with 
     parms as (select :SQL_ID sql_id from dual)
    ,plans as (select distinct hsp.sql_id,hsp.plan_hash_value,hsp.con_id from dba_hist_sql_plan hsp ,parms where hsp.sql_id = parms.sql_id  union all select distinct vsp.sql_id,vsp.plan_hash_value,vsp.con_id from gv$sql_plan vsp,parms where vsp.sql_id = parms.sql_id)
select  
     p.plan_hash_value
    ,p.id plan_id
    ,p.object# object_id
    ,p.object_owner
    ,p.object_name
    ,p.operation ||'  '||p.options operation_options
    --,p.object_type
    ,case when p.object_type like 'INDEX%' then p.object_type||'('||idx.table_name||')' else p.object_type end object_type
    ,case when p.object_type like 'TABLE%' then to_char(tbl.last_analyzed,'yyyy-mm-dd hh24:mi:ss') when p.object_type like 'INDEX%' then to_char(idx.last_analyzed,'yyyy-mm-dd hh24:mi:ss') else null end last_analyzed
    ,case when p.object_type like 'TABLE%' then tbl.num_rows when p.object_type like 'INDEX%' then idx.num_rows else null end num_rows
    ,case when p.object_type like 'INDEX%' then idx.distinct_keys else null end idx_distinct_keys
    ,case when p.object_type like 'TABLE%' then round((tbl.blocks+tbl.empty_blocks)*8192/1024/1024) else null end  size_mb 
    ,case when p.object_type like 'TABLE%' then round((tbl.empty_blocks)*8192/1024/1024) else null end  empty_mb 
    ,case when p.object_type like 'TABLE%' then round((tbl.blocks*8192/1024/1024) - (tbl.num_rows*tbl.avg_row_len/1024/1024)) else null end empty_below_hwm_mb
from (select hsp.sql_id,hsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,hsp.con_id from dba_hist_sql_plan hsp ,plans  where hsp.sql_id = plans.sql_id and hsp.plan_hash_value = plans.plan_hash_value and hsp.con_id = plans.con_id
      union
      select vsp.sql_id,vsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,vsp.con_id from gv$sql_plan vsp,plans         where vsp.sql_id = plans.sql_id and vsp.plan_hash_value = plans.plan_hash_value and vsp.con_id = plans.con_id
      ) p
         left  outer join cdb_tables tbl    on p.object_owner = tbl.owner and p.object_name  = tbl.table_name and p.con_id  = tbl.con_id and  p.object_type like 'TABLE%'
         left  outer join cdb_indexes idx   on p.object_owner = idx.owner and p.object_name  = idx.index_name and p.con_id  = idx.con_id and  p.object_type like 'INDEX%'
where 1=1 
    and p.object_name is not null
    and p.plan_hash_value = :PLAN_HASH_VALUE
order by sql_id,plan_hash_value,id]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[tables_stats_cols]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with 
    function raw_to_num(i_raw raw) return number        is m_n number;          begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_float(i_raw raw) return float       is m_n float;           begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_date(i_raw raw) return date         is m_n date;            begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_varchar2(i_raw raw) return varchar2 is m_n varchar2(10000); begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    parms as (select :SQL_ID sql_id from dual)
    ,plans as (select distinct hsp.sql_id,hsp.plan_hash_value,hsp.con_id from dba_hist_sql_plan hsp ,parms where hsp.sql_id = parms.sql_id  union all select distinct vsp.sql_id,vsp.plan_hash_value,vsp.con_id from gv$sql_plan vsp,parms where vsp.sql_id = parms.sql_id)
select  
     p.plan_hash_value
    ,p.id plan_id
    ,p.object# object_id
    ,p.object_owner
    ,p.object_name
    ,p.operation ||'  '||p.options operation_options
	,tbls.column_name
	,tbls.histogram
	,tbls.num_distinct
	,tbls.num_buckets
	,to_char(tbls.last_analyzed,'yyyy-mm-dd hh24:mi:ss') last_analyzed
	,tbls.avg_col_len
	,tbls.user_stats
	,tbls.num_nulls
    ,case tbc.data_type when 'VARCHAR2' then to_char(raw_to_varchar2(tbls.low_value))  when 'DATE' then to_char(raw_to_date(tbls.low_value),'yyyy-mm-dd hh24:mi:ss')  when 'NUMBER' then to_char(raw_to_num(tbls.low_value)) when 'FLOAT' then to_char(raw_to_float(tbls.low_value)) end low_value
	--,tbls.low_value
    ,case tbc.data_type when 'VARCHAR2' then to_char(raw_to_varchar2(tbls.high_value))  when 'DATE' then to_char(raw_to_date(tbls.high_value),'yyyy-mm-dd hh24:mi:ss')  when 'NUMBER' then to_char(raw_to_num(tbls.high_value)) when 'FLOAT' then to_char(raw_to_float(tbls.high_value)) end high_value
	--,tbls.high_value
	,tbls.density
	,tbls.sample_size
	,tbls.global_stats
from (select hsp.sql_id,hsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,hsp.con_id from dba_hist_sql_plan hsp ,plans  where hsp.sql_id = plans.sql_id and hsp.plan_hash_value = plans.plan_hash_value and hsp.con_id = plans.con_id
      union
      select vsp.sql_id,vsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,vsp.con_id from gv$sql_plan vsp,plans         where vsp.sql_id = plans.sql_id and vsp.plan_hash_value = plans.plan_hash_value and vsp.con_id = plans.con_id
      ) p
         left  outer join cdb_tab_col_statistics tbls    on p.object_owner = tbls.owner and p.object_name  = tbls.table_name  and p.con_id  = tbls.con_id and  p.object_type like 'TABLE%'
         join cdb_tab_columns tbc                        on tbls.owner = tbc.owner      and tbls.table_name  = tbc.table_name and tbls.column_name  = tbc.column_name and tbls.con_id  = tbc.con_id  
         --left  outer join cdb_indexes idx   on p.object_owner = idx.owner and p.object_name  = idx.index_name and p.con_id  = idx.con_id and  p.object_type like 'INDEX%'
where 1=1 
    and p.object_name is not null
    and p.plan_hash_value = :PLAN_HASH_VALUE
order by plan_hash_value,id
;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[indexes]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */ distinct
                    i.table_owner
                    ,i.table_name
                    ,i.owner index_owner
                    ,i.index_name
                    ,i.index_type
                    ,i.partitioned
                    ,c.column_name
                    ,c.column_position
                    ,p.options
                    ,p.access_predicates
                    ,p.filter_predicates
                    ,p.position
                    ,i.blevel
                    ,i.leaf_blocks
                    ,i.distinct_keys
                    ,i.avg_leaf_blocks_per_key
                    ,i.avg_leaf_blocks_per_key
                    ,i.avg_data_blocks_per_key
                    ,i.clustering_factor
                    ,i.status
                    ,i.num_rows
                    ,i.sample_size
                    ,to_char(i.last_analyzed,'yyyy-mm-dd hh24:mi:ss') last_analyzed
                from cdb_indexes i
                    left outer join cdb_ind_columns c	 on i.index_name = c.index_name  and i.owner = c.index_owner and i.con_id = c.con_id
                    left outer join dba_hist_sql_plan p  on i.index_name = p.object_name and i.con_id = p.con_id and i.owner = p.object_owner
                where 1=1
                    and p.sql_id=:SQL_ID
                    and p.plan_hash_value = :PLAN_HASH_VALUE
                    and object_type like '%INDEX%' and object_name is not null
                order by p.position,i.table_owner,i.table_name,i.index_name,c.column_position,c.column_name]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[stats_history]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with hsp as (	  select /*+ no_merge */ distinct object_owner,object_name,object#
				from  dba_hist_sql_plan
				where dbid = :DBID and sql_id = :SQL_ID and plan_hash_value = :PLAN_HASH_VALUE and object# is not null),
	 st	 as (	select obj#,savtime,rowcnt from sys.wri$_optstat_ind_history si
				union
				select obj#,savtime,rowcnt from sys.wri$_optstat_tab_history st)
select /*+ leading(hsp st o) NO_PARALLEL */
	 hsp.object_owner
	,hsp.object_name
	,hsp.object#
	--,o.object_type
	,to_char (savtime,'yyyy-mm-dd hh24:mi:ss') savtime
	,rowcnt
from hsp
	 left outer join  st			on hsp.object# = st.obj#
	 left outer join  cdb_objects o on hsp.object# = o.object_id
order by hsp.object_owner,hsp.object_name,savtime]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[AWR reports]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set trimspool on
set pages 10000
set linesize 1000
set long 1000000
set longchunksize 1000000
set feedback off
set heading off
set sqlprompt ''
set echo off verify off time off timing off
set termout off
col reports_dest_dir new_value reports_dest_dir
select nvl(:REPORTS_DEST_DIR,'c:\temp')  reports_dest_dir  from dual;

col slash new_value slash
select case when instr('&REPORTS_DEST_DIR.','\') > 0 then '\' else '/' end   slash from dual;

col awr_report new_value awr_report
col ash_report new_value ash_report
select
     '&REPORTS_DEST_DIR.&SLASH.'||'awr_sql_report.'||:SNAP||'-'||to_char(:SNAP - 1)||'.html'  awr_report
    ,'&REPORTS_DEST_DIR.&SLASH.'||'ash_sql_report.'||:SNAP||'-'||to_char(:SNAP - 1)||'.html'  ash_report
from dual;
    

spool &AWR_REPORT
select * from table(dbms_workload_repository.awr_sql_report_html(:DBID, :INSTANCE_NUMBER, :SNAP -1, :SNAP, :SQL_ID));
spool off

set termout off
spool &ASH_REPORT
select * from table(dbms_workload_repository.ash_global_report_html(:DBID, :INSTANCE_NUMBER, to_date(:BEGIN_INTERVAL_TIME_CHAR,'yyyy-mm-dd hh24:mi:ss day'), to_date(:END_INTERVAL_TIME_CHAR,'yyyy-mm-dd hh24:mi:ss day'), l_sql_id=> :SQL_ID));
spool off

set termout on heading on
select	'&AWR_REPORT'  as "AWR Report" from dual;
select	'&ASH_REPORT'  as "ASH Report" from dual;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[SQLT]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set trimspool on
set pages 10000
set linesize 1000
set long 1000000
set longchunksize 1000000
set feedback off
set heading off
set sqlprompt ''
set echo off verify off time off timing off
set termout off

col sqlt_dir new_value sqlt_dir
select nvl(:SQLT_DIR,'/oracle/sqlt')  sqlt_dir  from dual;

col slash new_value slash
select case when instr('&SQLT_DIR.','\') > 0 then '\' else '/' end   slash from dual;

set termout on
select '
--Connect as the parsing_shema_name and run SQLT scripts
sqlplus /nolog
DEFINE SCHEMA = '||:PARSING_SCHEMA_NAME||'
DEFINE SCHEMA_PWD = xxxxx
DEFINE SQL_ID = '||:SQL_ID||'
DEFINE TNS = <TNS_ENTRY>
DEFINE SQLTXPLAIN_PWD = xxxxx
grant sqlt_user_role to '||'&'||'SCHEMA;
grant execute on dbms_export_extension to '||'&'||'SCHEMA;
connect '||'&'||'SCHEMA/'||'&'||'SCHEMA_PWD@'||'&'||'TNS
@&SQLT_DIR.&SLASH.run&SLASH.sqlhc.sql
@&SQLT_DIR.&SLASH.run&SLASH.sqltxtract.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD
@&SQLT_DIR.&SLASH.run&SLASH.sqltxecute.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD
@&SQLT_DIR.&SLASH.run&SLASH.sqltxtrxec.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD  @--sqltxtrxec.sql [SQL_ID]|[HASH_VALUE] [sqltxplain_password]
@&SQLT_DIR.&SLASH.utl&SLASH.coe_load_sql_baseline.sql
@&SQLT_DIR.&SLASH.utl&SLASH.coe_load_sql_profile.sql
@&SQLT_DIR.&SLASH.utl&SLASH.coe_xfr_sql_profile.sql       
'
from dual;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[dbms_sqltune]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set pagesize 0 lines 200 long 1000000 heading off feedback off sqlprompt '' trimspool on trim on echo off verify off time off timing off
set termout off
col snap                new_value snap
col sql_id              new_value sql_id
col dbid                new_value dbid
col plan_hash_value     new_value plan_hash_value
col con_name            new_value con_name

select
     :SNAP                    SNAP
    ,:SQL_ID                  SQL_ID
    ,:DBID                    DBID
    ,:PLAN_HASH_VALUE         PLAN_HASH_VALUE
    ,:CON_NAME                CON_NAME
from dual;;

set termout on


PROMPT  --dbms_sqltune.create_tuning_task
PROMPT   --To be run on the container with the snapshots
PROMPT   set serveroutput on size unlimited
PROMPT   variable sql_id          varchar2(13)
PROMPT   variable task_name       varchar2(60)
PROMPT   variable plan_hash_value number
PROMPT   variable begin_snap      number
PROMPT   variable end_snap        number
PROMPT   variable dbid            number
PROMPT   variable con_name        varchar2(128)
PROMPT   exec :sql_id             := '&SQL_ID';;
PROMPT   exec :task_name          := '&SQL_ID'||'_tuning_task';;
PROMPT   exec :begin_snap         := &SNAP - 1;;
PROMPT   exec :end_snap           := &SNAP;;
PROMPT   exec :plan_hash_value    := &PLAN_HASH_VALUE;;
PROMPT   exec :dbid               := &DBID;;
PROMPT   exec :con_name           := '&CON_NAME';;
PROMPT   declare
PROMPT       l_sql_tune_task_id  varchar2(100);;
PROMPT   begin
PROMPT       begin dbms_sqltune.drop_tuning_task (task_name => :task_name); exception when others then null;end;;
PROMPT       l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT                             begin_snap  => :begin_snap,
PROMPT                             end_snap    => :end_snap,
PROMPT                             sql_id      => :sql_id,
PROMPT                             --con_name    => :con_name, only if using container snapshots
PROMPT                             scope       => dbms_sqltune.scope_comprehensive,
PROMPT                             dbid        => :DBID,
PROMPT                             time_limit  => 300,
PROMPT                             task_name   => :task_name,
PROMPT                             description => 'Tuning task for statement '||:sql_id||' in AWR.');;
PROMPT   --    l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT   --                          sql_id      => :sql_id,
PROMPT   --                          plan_hash_value => :plan_hash_value,
PROMPT   --                          --con_name    => :con_name, only if using container snapshots
PROMPT   --                          scope       => dbms_sqltune.scope_comprehensive,
PROMPT   --                          time_limit  => 300,
PROMPT   --                          task_name   => :task_name,
PROMPT   --                          description => 'Tuning task for statement '||:sql_id||' in Shared pool.');;
PROMPT       dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);;
PROMPT       dbms_output.put_line('task_name: ' || :task_name);;
PROMPT       dbms_sqltune.execute_tuning_task(task_name => :task_name);;
PROMPT   end;;
PROMPT   /
PROMPT   set long 1000000 pagesize 10000 linesize 2000
PROMPT   select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[dbms_advisor]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set pagesize 0 lines 200 long 1000000 heading off feedback off sqlprompt '' trimspool on trim on echo off verify off time off timing off
set termout off
col sql_id              new_value sql_id
col con_name            new_value con_name
col parsing_schema_name new_value parsing_schema_name

select
     :SNAP                    SNAP
    ,:SQL_ID                  SQL_ID
    ,:CON_NAME                CON_NAME
    ,:PARSING_SCHEMA_NAME     PARSING_SCHEMA_NAME
    ,:CON_NAME                CON_NAME
from dual;
set termout on

PROMPT   --To be run on the container where it was parsed
select  '--&CON_NAME' from dual;
PROMPT   variable task_name      varchar2(60)
PROMPT   variable sql_id         varchar2(13)
PROMPT   variable username       varchar2(30)
PROMPT   exec :sql_id            := '&SQL_ID';;
PROMPT   exec :task_name         := '&SQL_ID'||'_access_advisor';;
PROMPT   exec :username          := '&PARSING_SCHEMA_NAME';;
PROMPT   declare
PROMPT     l_sql_id          varchar2(13) := :sql_id;;
PROMPT     l_task_name       varchar2(60) := :task_name;;
PROMPT     l_sql_fulltext    clob;;
PROMPT     l_advisor_name    varchar2(30) := dbms_advisor.sqlaccess_advisor;;
PROMPT   begin
PROMPT     begin dbms_advisor.delete_task(l_task_name); exception when others then null; end;;
PROMPT     select sql_text     into  l_sql_fulltext from dba_hist_sqltext where sql_id = l_sql_id and rownum < 2;;
PROMPT     dbms_advisor.quick_tune(l_advisor_name, l_task_name,l_sql_fulltext,:username);;
PROMPT   end;;
PROMPT   /
PROMPT   --read report
PROMPT   set lines 130
PROMPT   col execution_end   for a22
PROMPT   col advisor_name    for a20
PROMPT   col task_name       for a30
PROMPT   col command         for a20
PROMPT   col message         for a20
PROMPT   col action_message  for a40
PROMPT   select
PROMPT       to_char(dat.execution_end,'yyyy-mm-dd hh24:mi:ss') execution_end
PROMPT       ,dat.task_name
PROMPT       ,dat.advisor_name
PROMPT       ,daf.type                               finding_type
PROMPT       ,daf.impact
PROMPT       ,dar.rank
PROMPT       ,dar.type                               reccomendation_type
PROMPT       ,dar.benefit
PROMPT       ,'Message : ' ||daf.message             message
PROMPT       ,'Command To correct: ' ||daa.command   command
PROMPT       ,'Action Message : ' ||daa.message      action_message
PROMPT   from cdb_advisor_tasks dat,cdb_advisor_findings daf ,cdb_advisor_actions daa,cdb_advisor_recommendations dar
PROMPT   where 1=1
PROMPT       and dat.owner = daf.owner(+)
PROMPT       and dat.task_id = daf.task_id(+)
PROMPT       and dat.con_id = daf.con_id(+)
PROMPT       and daf.task_id = dar.task_id(+)
PROMPT       and daf.finding_id = dar.finding_id(+)
PROMPT       and daf.con_id = dar.con_id(+)
PROMPT       and dat.task_id = daa.task_id(+)
PROMPT       and dat.con_id = daa.con_id(+)
PROMPT       and dar.rec_id = daa.rec_id(+)
PROMPT       and dar.con_id = daa.con_id(+)
PROMPT       and dat.task_name = :task_name
PROMPT   order by  dat.execution_end
PROMPT   ;;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR sqltune sql_id]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     sql_id
    ,plan_hash_value
    --,force_matching_signature
    --,substr(sql_text,1,40)  sql_text
    --,object_list
    --,bind_data
    ,parsing_schema_name
    --,elapsed_time
    ,to_char(round(elapsed_time/1000000,3),'9999990.990') elapsed_time_ms
    ,executions
    ,to_char(case when executions > 0 then round(elapsed_time/1000000/executions,3)	else null end,'999999990.990') elapsed_time_avg_ms
    --,cpu_time
    ,to_char(round(cpu_time/1000000,3),'9999990.990') cpu_time_ms
    ,buffer_gets
    ,disk_reads
    ,direct_writes
    ,rows_processed
    ,fetches
    ,end_of_fetch_count
    ,module
    ,action
    ,optimizer_cost
    --,optimizer_env
    --,priority
    --,command_type
    ,first_load_time
    ,stat_period
    ,active_stat_period
    ,other
    --,sql_plan
    --,bind_list
    ,con_dbid
    ,last_exec_start_time
FROM table((dbms_sqltune.select_workload_repository (
    begin_snap          => :SNAP - 1,
    end_snap            => :SNAP,
    basic_filter        => 'sql_id='''||:SQL_ID||'''',    --'sql_id='''||'bxycjsjr7uuh5'||'''', 'parsing_schema_name <> ''SYS''',
    object_filter       => null,                                --Currently not supported.
    ranking_measure1    => 'elapsed_time',                      --ranking_measure(n) Defines an ORDER BY clause on the selected SQL.
    ranking_measure2    => null,
    ranking_measure3    => null,
    result_percentage   => null,                                --Specifies a filter that picks the top n% according to the supplied ranking measure.
    result_limit        => 10000000,
    attribute_list      => 'ALL',                               -- SQL statement attributes to return in the result. BASIC TYPICAL  ALL 
    recursive_sql       => null,                                --Specifies the filter that includes recursive SQL in the SQL tuning set (HAS_RECURSIVE_SQL) or excludes it (NO_RECURSIVE_SQL).
    dbid                => :DBID)
    ))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR sqltune all]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     sql_id
    ,plan_hash_value
    --,force_matching_signature
    --,substr(sql_text,1,40)  sql_text
    --,object_list
    --,bind_data
    ,parsing_schema_name
    --,elapsed_time
    ,to_char(round(elapsed_time/1000000,3),'9999990.990') elapsed_time_ms
    ,executions
    ,to_char(case when executions > 0 then round(elapsed_time/1000000/executions,3)	else null end,'999999990.990') elapsed_time_avg_ms
    --,cpu_time
    ,to_char(round(cpu_time/1000000,3),'9999990.990') cpu_time_ms
    ,buffer_gets
    ,disk_reads
    ,direct_writes
    ,rows_processed
    ,fetches
    ,end_of_fetch_count
    ,module
    ,action
    ,optimizer_cost
    --,optimizer_env
    --,priority
    --,command_type
    ,first_load_time
    ,stat_period
    ,active_stat_period
    ,other
    --,sql_plan
    --,bind_list
    ,con_dbid
    ,last_exec_start_time
FROM table((dbms_sqltune.select_workload_repository (
    begin_snap          => :SNAP - 1,
    end_snap            => :SNAP,
    --basic_filter        => 'sql_id='''||:SQL_ID||'''',    --'sql_id='''||'bxycjsjr7uuh5'||'''', 'parsing_schema_name <> ''SYS''',
    object_filter       => null,                                --Currently not supported.
    ranking_measure1    => 'elapsed_time',                      --ranking_measure(n) Defines an ORDER BY clause on the selected SQL.
    ranking_measure2    => null,
    ranking_measure3    => null,
    result_percentage   => null,                                --Specifies a filter that picks the top n% according to the supplied ranking measure.
    result_limit        => 10000000,
    attribute_list      => 'ALL',                               -- SQL statement attributes to return in the result. BASIC TYPICAL  ALL 
    recursive_sql       => null,                                --Specifies the filter that includes recursive SQL in the SQL tuning set (HAS_RECURSIVE_SQL) or excludes it (NO_RECURSIVE_SQL).
    dbid                => :DBID)
    ))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[avg]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set pagesize 0 lines 200 long 1000000 heading off feedback off sqlprompt '' trimspool on trim on echo off verify off time off timing off
set termout off
col snap                new_value snap
col sql_id              new_value sql_id
col dbid                new_value dbid
col plan_hash_value     new_value plan_hash_value
col con_name            new_value con_name

select
     :SNAP                    SNAP
    ,:SQL_ID                  SQL_ID
    ,:DBID                    DBID
    ,:PLAN_HASH_VALUE         PLAN_HASH_VALUE
    ,:CON_NAME                CON_NAME
from dual;;

set termout on


PROMPT  --dbms_sqltune.create_tuning_task
PROMPT   --To be run on the container with the snapshots
PROMPT   set serveroutput on size unlimited
PROMPT   variable sql_id          varchar2(13)
PROMPT   variable task_name       varchar2(60)
PROMPT   variable plan_hash_value number
PROMPT   variable begin_snap      number
PROMPT   variable end_snap        number
PROMPT   variable dbid            number
PROMPT   variable con_name        varchar2(128)
PROMPT   exec :sql_id             := '&SQL_ID';;
PROMPT   exec :task_name          := '&SQL_ID'||'_tuning_task';;
PROMPT   exec :begin_snap         := &SNAP - 1;;
PROMPT   exec :end_snap           := &SNAP;;
PROMPT   exec :plan_hash_value    := &PLAN_HASH_VALUE;;
PROMPT   exec :dbid               := &DBID;;
PROMPT   exec :con_name           := '&CON_NAME';;
PROMPT   declare
PROMPT       l_sql_tune_task_id  varchar2(100);;
PROMPT   begin
PROMPT       begin dbms_sqltune.drop_tuning_task (task_name => :task_name); exception when others then null;end;;
PROMPT       l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT                             begin_snap  => :begin_snap,
PROMPT                             end_snap    => :end_snap,
PROMPT                             sql_id      => :sql_id,
PROMPT                             --con_name    => :con_name, only if using container snapshots
PROMPT                             scope       => dbms_sqltune.scope_comprehensive,
PROMPT                             dbid        => :DBID,
PROMPT                             time_limit  => 300,
PROMPT                             task_name   => :task_name,
PROMPT                             description => 'Tuning task for statement '||:sql_id||' in AWR.');;
PROMPT   --    l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT   --                          sql_id      => :sql_id,
PROMPT   --                          plan_hash_value => :plan_hash_value,
PROMPT   --                          --con_name    => :con_name, only if using container snapshots
PROMPT   --                          scope       => dbms_sqltune.scope_comprehensive,
PROMPT   --                          time_limit  => 300,
PROMPT   --                          task_name   => :task_name,
PROMPT   --                          description => 'Tuning task for statement '||:sql_id||' in Shared pool.');;
PROMPT       dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);;
PROMPT       dbms_output.put_line('task_name: ' || :task_name);;
PROMPT       dbms_sqltune.execute_tuning_task(task_name => :task_name);;
PROMPT   end;;
PROMPT   /
PROMPT   set long 1000000 pagesize 10000 linesize 2000
PROMPT   select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;]]></sql>
			</query>
		</display>
	</display>
	<display id="8dc29dde-0183-1000-8009-c0a83801b45d" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops Trace File Reader]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
select 
     to_char(dtf.change_time,'yyyy-mm-dd hh24:mi:ss') change_time                           
    ,to_char(dtf.modify_time,'yyyy-mm-dd hh24:mi:ss') modify_time                           
    ,dtf.adr_home                                             
    ,dtf.trace_filename                    
    ,sql_trace
    ,optimizer_trace
    ,dtf.con_id
from v$diag_trace_file dtf
    full outer join v$diag_app_trace_file datf on dtf.adr_home = datf.adr_home and dtf.trace_filename = datf.trace_filename and dtf.con_id = datf.con_id
where 1=1
order by change_time
;]]></sql>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Trace File Content]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select  
     to_char(timestamp,'yyyy-mm-dd hh24:mi:ss') timestamp                           
    ,adr_home 
    ,trace_filename 
    ,line_number 
    ,payload 
    ,record_type 
    ,section_name 
    ,session_id 
    ,serial# 
    ,record_level 
    ,parent_level 
    ,section_id 
    ,component_name 
    ,operation_name 
    ,file_name 
    ,function_name 
    ,thread_id 
    ,con_uid 
    ,container_name 
    ,con_id  
from v$diag_trace_file_contents dtfc
where 1=1
    and adr_home = :ADR_HOME
    and trace_filename = :TRACE_FILENAME
order by timestamp,trace_filename,line_number]]></sql>
			</query>
		</display>
	</display>
	<display id="8db107cc-0183-1000-8003-c0a83801b45d" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops AWR Reports]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[
                -- -----------------------------------------------------------------------------
                -- Author      : Masked DevOps
                -- Date        : Jan 2012
                -- Version     : 0.1
                --
                --!!!Edit this report from the xml file only, not from SQL Developer!!!
                --
                -- SQL Developer report for database administration 
                -- Copyright (C) 2022  Emanuele Moccia
                -- masked.devops@yahoo.com
                -- 
                -- This program is free software: you can redistribute it and/or modify
                -- it under the terms of the GNU General Public License as published by
                -- the Free Software Foundation, either version 3 of the License, or
                -- any later version.
                -- 
                -- This program is distributed in the hope that it will be useful,
                -- but WITHOUT ANY WARRANTY; without even the implied warranty of
                -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                -- GNU General Public License for more details.
                -- 
                -- You should have received a copy of the GNU General Public License
                -- along with this program.  If not, see <https://www.gnu.org/licenses/>.
                -- -----------------------------------------------------------------------------
                with
                     parms as ( select
                                     nvl(:reports_dest_dir,'c:\temp')                                   reports_dest_dir
                                    ,case when instr(:reports_dest_dir,'\') > 0 then '\' else '/' end   slash
                                from dual)
                select
                     snap_id start_snap_id
                    ,to_char(end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  start_snap_date
                    ,db_name
                    ,instance_name
                    ,dbid
                    ,instance_number
                    ,reports_dest_dir
                    --,slash
                from (  select
                             di.db_name
                            ,di.instance_name
                            ,s.snap_id
                            ,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
                            ,s.end_interval_time
                            ,di.dbid
                            ,di.instance_number
                        from dba_hist_snapshot s, dba_hist_database_instance di
                        where 1=1
                            and s.dbid                = di.dbid(+)
                            and s.instance_number     = di.instance_number(+)
                            and s.startup_time        = di.startup_time(+)
                    ) snaps,parms
                where snap_id_prev is not null
                order by end_interval_time ,instance_number, snap_id
                ]]></sql>
			<binds>
				<bind id="reports_dest_dir">
					<prompt><![CDATA[reports_dest_dir]]></prompt>
					<tooltip><![CDATA[reports_dest_dir]]></tooltip>
					<value><![CDATA[C:\temp]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="3232034d-015e-1000-8002-0b0e12972947" type="" style="Table" enable="true">
			<name><![CDATA[End Snap]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[
                            select
                                 s.snap_id end_snap_id
                                ,to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  end_snap_date
                                ,di.db_name
                                ,di.instance_name
                                ,di.dbid
                                ,di.instance_number
                                ,:START_SNAP_ID start_snap_id
                                ,:START_SNAP_DATE  start_snap_date
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_html
                            from dba_hist_snapshot s, dba_hist_database_instance di
                            where 1=1
                                and s.dbid                = di.dbid(+)
                                and s.instance_number     = di.instance_number(+)
                                and s.startup_time        = di.startup_time(+)
                                and s.dbid                = :DBID
                                and s.instance_number     = :INSTANCE_NUMBER
                                and cast(s.end_interval_time as date) > to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss')
                            order by end_interval_time ,instance_name, snap_id
                            ]]></sql>
				<binds>
					<bind id="START_SNAP_ID">
						<prompt><![CDATA[START_SNAP_ID]]></prompt>
						<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_SNAP_DATE">
						<prompt><![CDATA[START_SNAP_DATE]]></prompt>
						<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DB_NAME">
						<prompt><![CDATA[DB_NAME]]></prompt>
						<tooltip><![CDATA[DB_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[Info]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                select
                                     :START_SNAP_ID start_snap_id
                                    ,:END_SNAP_ID end_snap_id
                                    ,:START_SNAP_DATE start_snap_date
                                    ,:END_SNAP_DATE end_snap_date
                                    ,:DB_NAME db_name
                                    ,:INSTANCE_NAME instance_name
                                    ,:INSTANCE_NUMBER instance_number
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  awr_txt
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' awr_html
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        awr_global_txt
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       awr_global_html
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  ash_txt
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' ash_html
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        ash_global_txt
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       ash_global_html
                                    from dual;
                    ]]></sql>
					<binds>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                SELECT
                                     sql_id
                                    ,plan_hash_value
                                    ,last_exec_start_time
                                    ,parsing_schema_name
                                    --,force_matching_signature
                                    ,executions
                                    --,elapsed_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   elapsed_time_sec
                                    ,to_char(case when executions > 0 then trunc(elapsed_time/1000000/executions,4) else 0 end,'99990.990')  avg_time_sec
                                    --,cpu_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   cpu_time_sec
                                    ,buffer_gets
                                    ,disk_reads
                                    ,direct_writes
                                    ,rows_processed
                                    ,fetches
                                    ,end_of_fetch_count
                                    ,substr(sql_text,1,40)  sql_text
                                    ,object_list
                                    --,bind_data
                                    ,module
                                    ,action
                                    ,optimizer_cost
                                    --,optimizer_env
                                    ,priority
                                    ,command_type
                                    ,first_load_time
                                    ,stat_period
                                    ,active_stat_period
                                    ,other
                                    --,sql_plan
                                    ,bind_list
                                    ,con_dbid
                                FROM table((dbms_sqltune.select_workload_repository (
                                    begin_snap          => :START_SNAP_ID,
                                    end_snap            => :END_SNAP_ID,
                                    basic_filter        => null,
                                    object_filter       => null,
                                    ranking_measure1    => 'elapsed_time',
                                    ranking_measure2    => null,
                                    ranking_measure3    => null,
                                    result_percentage   => null,
                                    result_limit        => 1000,
                                    attribute_list      => 'ALL',
                                    recursive_sql       => null,
                                    dbid                => :DBID)
                                    )) ;                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[Tuning task SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off
                                select
                                    q'[
                                        variable sqlset_name    varchar2(60)
                                        variable task_name      varchar2(60)
                                        variable begin_snap     number
                                        variable end_snap       number
                                        variable dbid           number
                                        variable sqlset_limit   number
                                        variable time_limit     number
                                        exec :sqlset_name       := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :task_name         := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :begin_snap        := ]' || :START_SNAP_ID || q'[;
                                        exec :end_snap          := ]' || :END_SNAP_ID || q'[;
                                        exec :dbid              := ]' || :DBID          || q'[;
                                        exec :sqlset_limit      := 1000;
                                        exec :time_limit        := 3600;
                                        declare
                                          l_cursor  dbms_sqltune.sqlset_cursor;
                                          l_sql_tune_task_id  varchar2(100);
                                        begin
                                            begin dbms_sqltune.drop_tuning_task (task_name => :task_name);exception when others then null;end;
                                            begin dbms_sqltune.drop_sqlset(sqlset_name => :sqlset_name);exception when others then null; end;
                                            dbms_sqltune.create_sqlset(sqlset_name => :sqlset_name, description  => 'AWR snapshots workload');
                                            open l_cursor for select value(p) from table (dbms_sqltune.select_workload_repository (begin_snap => :begin_snap,end_snap => :end_snap,basic_filter => null,object_filter => null,ranking_measure1 => null,ranking_measure2 => null,ranking_measure3 => null,result_percentage => null,result_limit => :sqlset_limit,dbid => :dbid)) p;
                                            dbms_sqltune.load_sqlset (sqlset_name => :sqlset_name, populate_cursor => l_cursor);
                                            l_sql_tune_task_id := dbms_sqltune.create_tuning_task (sqlset_name => :sqlset_name,scope => dbms_sqltune.scope_comprehensive,time_limit => :time_limit, --secondstask_name => :task_name,description => 'Tuning task for a SQL tuning set  '|| :sqlset_name);
                                            dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
                                            dbms_sqltune.execute_tuning_task(task_name => :task_name);
                                        end;
                                        /
                                        set long 100000 pagesize 1000 linesize 200
                                        select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;
                                    ]' sql_tuning_advisor
                                from dual
                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_report_html(:DBID,:INSTANCE_NUMBER,:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_report_html(:DBID,:INSTANCE_NUMBER,to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM view]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM run]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 1000000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM',task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'INSTANCE',         value => :INSTANCE_NUMBER);
                                exec dbms_advisor.execute_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report FROM    dual;
                             ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'awr_report_html' awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;


                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'ash_report_html'    awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'addm_report_text'  awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_report_html' awr_report from dual union all
                                                select 'ash_report_html'            from dual union all
                                                select 'addm_report_text'    from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                --AWR
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_global_report_html(:DBID,'',:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                --ASH
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_global_report_html(:DBID,'',to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                -ADDM
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.'||'txt' filename from dual;
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM', task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.execute_task(task_name =>  'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report from dual;
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                prompt All Reports Completed!

                        ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_global_report_html' awr_report from dual union all
                                                select 'ash_global_report_html'            from dual union all
                                                select 'addm_global_report_text'           from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
		</display>
	</display>
	<display id="a2e43d03-0183-1000-803b-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops I/O]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select 
         end_interval_time
        ,rpad(to_char(round(max(decode(event_name,'db file scattered read',avg_wait_ms,null)),2),'99990.990'),8,' ')          ||lpad('('||max(decode(event_name,'db file scattered read',total_waits,null))||')',15,' ')          db_file_scat_read_20_ms         --'control file parallel write',      15_ms
        ,rpad(to_char(round(max(decode(event_name,'db file sequential read',avg_wait_ms,null)),2),'99990.990'),8,' ')         ||lpad('('||max(decode(event_name,'db file sequential read',total_waits,null))||')',15,' ')         db_file_seq_read_20_ms          --'control file sequential read',     20_ms
        ,rpad(to_char(round(max(decode(event_name,'db file parallel read',avg_wait_ms,null)),2),'99990.990'),8,' ')           ||lpad('('||max(decode(event_name,'db file parallel read',total_waits,null))||')',15,' ')           db_file_paral_read_20_ms        --'db file parallel read',            20_ms
        ,rpad(to_char(round(max(decode(event_name,'direct path read',avg_wait_ms,null)),2),'99990.990'),8,' ')                ||lpad('('||max(decode(event_name,'direct path read',total_waits,null))||')',15,' ')                drct_path_read_Read_20_ms       --'db file scattered read',           20_ms
        ,rpad(to_char(round(max(decode(event_name,'direct path read temp',avg_wait_ms,null)),2),'99990.990'),8,' ')           ||lpad('('||max(decode(event_name,'direct path read temp',total_waits,null))||')',15,' ')           drct_path_read_temp_20_ms       --'db file sequential read',          20_ms
        ,rpad(to_char(round(max(decode(event_name,'direct path write',avg_wait_ms,null)),2),'99990.990'),8,' ')               ||lpad('('||max(decode(event_name,'direct path write',total_waits,null))||')',15,' ')               drct_path_write_15_ms           --'direct path read Read',            20_ms
        ,rpad(to_char(round(max(decode(event_name,'direct path write temp',avg_wait_ms,null)),2),'99990.990'),8,' ')          ||lpad('('||max(decode(event_name,'direct path write temp',total_waits,null))||')',15,' ')          drct_path_write_temp_15_ms      --'direct path read temp',            20_ms
        ,rpad(to_char(round(max(decode(event_name,'log file parallel write',avg_wait_ms,null)),2),'99990.990'),8,' ')         ||lpad('('||max(decode(event_name,'log file parallel write',total_waits,null))||')',15,' ')         log_file_paral_write_15_ms      --'direct path write',                15_ms
        ,rpad(to_char(round(max(decode(event_name,'control file parallel write',avg_wait_ms,null)),2),'99990.990'),8,' ')     ||lpad('('||max(decode(event_name,'control file parallel write',total_waits,null))||')',15,' ')     ctrl_file_parallel_write_15_ms  --'direct path write temp',           15_ms
        ,rpad(to_char(round(max(decode(event_name,'control file sequential read',avg_wait_ms,null)),2),'99990.990'),8,' ')    ||lpad('('||max(decode(event_name,'control file sequential read',total_waits,null))||')',15,' ')    ctrl_file_seq_read_20_ms        --'log file parallel write',          15_ms
        ,rpad(to_char(round(max(decode(event_name,'cell smart table scan',avg_wait_ms,null)),2),'99990.990'),8,' ')           ||lpad('('||max(decode(event_name,'cell smart table scan',total_waits,null))||')',15,' ')           cell_smart_table_scan_1_ms      --'cell smart table scan',            1_ms
        ,rpad(to_char(round(max(decode(event_name,'cell single block physical read',avg_wait_ms,null)),2),'99990.990'),8,' ') ||lpad('('||max(decode(event_name,'cell single block physical read',total_waits,null))||')',15,' ') cell_sngl_blk_phys_read_1_ms    --'cell single block physical read    1_ms
        ,rpad(to_char(round(max(decode(event_name,'cell multiblock physical read',avg_wait_ms,null)),2),'99990.990'),8,' ')   ||lpad('('||max(decode(event_name,'cell multiblock physical read',total_waits,null))||')',15,' ')   cell_mltblk_phys_read_6_ms      --'cell multiblock physical read',    6_ms
from (select end_interval_time
            ,event_name
            ,wait_class
            ,(total_waits - total_waits_prev) total_waits
            ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
            ,round(case when (total_waits - total_waits_prev) > 0
                  then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000
                  else 0
                  end,2)  avg_wait_ms
      from (
            select
               to_char(end_interval_time,'yyyy-mm-dd hh24 day') end_interval_time
              ,event_name
              ,lag(event_name) over (order by event_name,end_interval_time) event_name_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event_name,end_interval_time) total_waits_prev
              ,time_waited_micro
              ,lag(time_waited_micro) over (order by event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event se join dba_hist_snapshot snap on se.dbid = snap.dbid  and se.instance_number = snap.instance_number  and se.snap_id = snap.snap_id
                cross join parms
            where 1=1
                and snap.end_interval_time between parms.start_date and parms.end_date
                and snap.instance_number = parms.instance_number
            ) last
      where event_name = event_name_prev
      order by end_interval_time desc, time_waited_ms desc
    )
group by end_interval_time
--having max(decode(event_name,'db file sequential read',avg_wait_ms,null)),2),'99990.990'),8,' ') > 20
order by end_interval_time asc]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[P_START_DATE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[P_END_DATE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[IOPS]]></name>
			<description><![CDATA[IOPS - (Input/Output Operations Per Second) -  This is the sum of Physical Read Total IO Requests and Physical Write Total IO Requests ]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
	 parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,:P_INST_ID instance_number from dual)
    ,metrics as (
        select 
             end_interval_time
            ,metric_name
            ,metric_unit
            ,average    
        from dba_hist_sysmetric_summary	 hss 
            join dba_hist_snapshot dhs on hss.snap_id = dhs.snap_id and  hss.dbid = dhs.dbid and hss.instance_number = dhs.instance_number
            cross join parms
        where 1=1
            and hss.instance_number = nvl(parms.instance_number, hss.instance_number)
            and hss.metric_name in ('Physical Read IO Requests Per Sec', 'Physical Write Total IO Requests Per Sec')
            and dhs.end_interval_time between  parms.start_date and parms.end_date)
select
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi') end_interval_time
    ,metric_name || ' - ' ||metric_type metric
    --,metric_name
    --,metric_type
  	,value
  	--,value/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end value
from metrics m 
unpivot (value FOR metric_type IN (average AS 'AVERAGE'))
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[Throughput]]></name>
			<description><![CDATA[Throughput - This is the sum of Physical read total bytes and Physical write total bytes]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
	 parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,:P_INST_ID instance_number from dual)
    ,metrics as (
        select 
             end_interval_time
            ,metric_name
            ,metric_unit
            ,average/1024/1024 MB    
        from dba_hist_sysmetric_summary	 hss 
            join dba_hist_snapshot dhs on hss.snap_id = dhs.snap_id and  hss.dbid = dhs.dbid and hss.instance_number = dhs.instance_number
            cross join parms
        where 1=1
            and hss.instance_number = nvl(parms.instance_number, hss.instance_number)
            and hss.metric_name in ('Physical Read Total Bytes Per Sec', 'Physical Write Total Bytes Per Sec')
            and dhs.end_interval_time between  parms.start_date and parms.end_date)
select
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi') end_interval_time
    ,metric_name || ' - ' ||metric_type metric
    --,metric_name
    --,metric_type
  	,value
  	--,value/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end value
from metrics m 
unpivot (value FOR metric_type IN (MB AS 'MB'))
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[System Statistics redologs]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day')                       end_interval_time
      --,instance_number
      ,round((redo_write_time*10)/redo_writes,2)                                    avg_write_time_ms
      ,user_commits                                     
      ,trunc(redo_write_time*10/1000)                                               redo_write_time_tot_sec 
      ,round((redo_blocks_written*(select max(blocksize) from v$log)/1024/1024))    redo_blocks_written_mb
      ,round(redo_size/1024/1024)                                                   redo_size_mb
      ,redo_writes
      ,round((redo_blocks_written*(select max(blocksize) from v$log)/1024)/redo_writes) avg_block_written_kb
from (select         
           end_interval_time
          ,instance_number
          ,max(decode(stat_name,'redo blocks written',value,null))               redo_blocks_written
          ,max(decode(stat_name,'redo buffer allocation retries',value,null))    redo_buffer_allocation_retries
          ,max(decode(stat_name,'redo entries',value,null))                      redo_entries
          ,max(decode(stat_name,'redo log space requests',value,null))           redo_log_space_requests
          ,max(decode(stat_name,'redo log space wait time',value,null))          redo_log_space_wait_time
          ,max(decode(stat_name,'redo log switch interrupts',value,null))        redo_log_switch_interrupts
          ,max(decode(stat_name,'redo ordering marks',value,null))               redo_ordering_marks
          ,max(decode(stat_name,'redo write time',value,null))                   redo_write_time
          ,max(decode(stat_name,'redo writes',value,null))                       redo_writes
          ,max(decode(stat_name,'redo synch writes',value,null))                 redo_synch_writes
          ,max(decode(stat_name,'redo synch time',value,null))                   redo_synch_time
          ,max(decode(stat_name,'redo size',value,null))                         redo_size
          ,max(decode(stat_name,'redo wastage',value,null))                      redo_wastage
          ,max(decode(stat_name,'user commits',value,null))                      user_commits
      from (select instance_number,end_interval_time,stat_name,(value - value_prev)  value
                   ,trunc(((value - value_prev))/3600,2)             per_second
            from (
                  select end_interval_time
                    ,stat.instance_number
                    ,stat_name
                    ,lag(stat_name) over (order by stat.instance_number,stat_name,end_interval_time)     stat_name_prev
                    ,lag(value)     over (order by stat.instance_number,stat_name,end_interval_time)     value_prev
                    ,lag(stat.instance_number)     over (order by stat.instance_number,stat_name,end_interval_time)     instance_number_prev
                    ,value
                  from dba_hist_sysstat stat join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
                    cross join parms
                  where 1=1 
                    and snap.end_interval_time between parms.start_date and parms.end_date
                    and snap.instance_number = parms.instance_number
            )
            where stat_name=stat_name_prev and instance_number = instance_number_prev
      )
      group by instance_number,end_interval_time
      order by end_interval_time,instance_number 
)
order by end_interval_time,instance_number]]></sql>
			</query>
		</display>
	</display>
	<display id="a30ab51f-0183-1000-8046-c0a838017079" type="" style="Chart" enable="true">
		<name><![CDATA[Masked Devops CPU]]></name>
		<description><![CDATA[V$SYSMETRIC_SUMMARY displays a summary of all system metric values for the long-duration system metrics. 
The average, maximum value, minimum value, and the value of one standard deviation for the last hour are displayed for each metric item.]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[CPU %]]></Y1AXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<Y1AXIS_REFOBJ_COUNT><![CDATA[1]]></Y1AXIS_REFOBJ_COUNT>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<Y1AXIS_REFOBJ_LINE_VALUE><![CDATA[\,0.0]]></Y1AXIS_REFOBJ_LINE_VALUE>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y1AXIS_REFOBJ_VISIBLE><![CDATA[\,false]]></Y1AXIS_REFOBJ_VISIBLE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<STYLE><![CDATA[Default]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_REFOBJ_TEXT><![CDATA[\,]]></Y1AXIS_REFOBJ_TEXT>
			<Y1AXIS_REFOBJ_WIDTH><![CDATA[\,THINNEST]]></Y1AXIS_REFOBJ_WIDTH>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			<Y1AXIS_REFOBJ_COLOR><![CDATA[\,-16777216]]></Y1AXIS_REFOBJ_COLOR>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE')) instance_number
		  from dual)
select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi day')  end_interval_time
    ,metric
    ,value
from (
    select   
         stats.*
        ,to_char(round((user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')    user_pct
        ,to_char(round((sys_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')     sys_pct
        ,to_char(round((idle_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')    idle_pct
    from (  select end_interval_time
                ,max(decode(stat_name,'SYS_TIME', value-value_prev, null))      sys_time
                ,max(decode(stat_name,'USER_TIME', value-value_prev, null))     user_time
                ,max(decode(stat_name,'IDLE_TIME', value-value_prev, null))     idle_time
                ,max(decode(stat_name,'IOWAIT_TIME', value-value_prev, null))   iowait_time
                ,max(decode(stat_name,'LOAD', value, null))                     load
            from (
                    select 
                        end_interval_time
                        ,stat_name
                        ,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
                        ,lag(value) over (order by stat_name,end_interval_time) value_prev
                        ,value        
                    from dba_hist_osstat stat join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
                        cross join parms
                    where 1=1 
                        and snap.end_interval_time between parms.start_date and parms.end_date
                        and snap.instance_number = parms.instance_number
            )
            where stat_name =stat_name_prev
            group by end_interval_time
        ) stats
    )
unpivot (value FOR metric IN ( 
                            -- sys_time
                            --,user_time
                            --,idle_time
                            --,iowait_time
                            --,load
                             user_pct
                            ,sys_pct
                            --,idle_pct
                            )
    )  
order by end_interval_time,metric]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[P_START_DATE]]></tooltip>
					<value><![CDATA[2022-09-26 23:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[P_END_DATE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[sysmetric_summary]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
	 parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,:P_INST_ID instance_number from dual)
select *
from (select
			 to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
			,metric_name
			,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
		from dba_hist_sysmetric_summary	 hss 
                join dba_hist_snapshot dhs on hss.snap_id = dhs.snap_id and  hss.dbid = dhs.dbid and hss.instance_number = dhs.instance_number
            cross join parms
		where 1=1
            and (  (hss.metric_name = 'Background CPU Usage Per Sec' and hss.group_id = 2)
                or (hss.metric_name = 'CPU Usage Per Sec'            and hss.group_id = 2)
                or (hss.metric_name = 'Host CPU Usage Per Sec'       and hss.group_id = 2)
                )
            and hss.instance_number = nvl(parms.instance_number, hss.instance_number)
            and dhs.end_interval_time between  parms.start_date and parms.end_date
)
order by end_interval_time]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[osstat + sys_time_model]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE')) instance_number
		  from dual)
select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi day')  end_interval_time
    --,(select value from dba_hist_sysstat natural join dba_hist_snapshot where  stat_name = 'logons current' and end_interval_time = stats.end_interval_time) sessions
    --,to_char(round((sys_time+user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')   "%busy"
    ,to_char(round((user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')             "user%"
    ,to_char(round((sys_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')              "sys%"
    ,to_char(round((idle_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')             "idle%"
    ,to_char(round((iowait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')           "iowait_time%"
    ,to_char(round((rsrc_mgr_cpu_wait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90') "rsrc_mgr_cpu_wait_time%"
    ,to_char(round((os_cpu_wait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')      "os_cpu_wait_time%"
    ,to_char(round(load,3),'99990.90')                                                                          "load: active sessions"
    ,to_char(round(db_cpu_to_cpu_count,3),'99990.90')                                                           "db_cpu%"      
    ,to_char(round(db_cpu_to_os_cpu/num_cpus,3),'99990.90')                                                     "db_cpu_to_os%"      
    ,to_char(round(bg_cpu_to_cpu_count,3),'99990.90')                                                           "bg_cpu%"      
    ,to_char(round(rman_cpu_to_cpu_count,3),'99990.90')                                                         "rma_cpu%"      
    ,to_char(round(db_time_to_cpu_count,3),'99990.90')                                                          "db_time%"      
    ,num_cpus                                                                                                   "ncpus"        
    ,num_cpu_cores                                                                                              "ncores"     
    ,num_cpu_sockets                                                                                            "nsockets"       
    ,to_char(round(physical_memory_bytes/1024/1024 ,3),'99990.90')                                              "physical_memory_mb"
    ,to_char(round(free_memory_bytes    /1024/1024 ,3),'99990.90')                                              "free_memory_mb"    
    ,to_char(round(inactive_memory_bytes/1024/1024 ,3),'99990.90')                                              "inactive_memory_mb"
    ,to_char(round(vm_in_bytes          /1024/1024 ,3),'99990.90')                                              "vm_in_mb"          
    ,to_char(round(vm_out_bytes         /1024/1024 ,3),'99990.90')                                              "vm_out_mb"        
    ,to_char(round(swap_free_bytes      /1024/1024 ,3),'99990.90')                                              "swap_free_mb"     
from (  select 
             end_interval_time
            ,max(decode(stat_name,'SYS_TIME',    value-value_prev, null))   sys_time
            ,max(decode(stat_name,'USER_TIME',   value-value_prev, null))   user_time
            ,max(decode(stat_name,'IDLE_TIME',   value-value_prev, null))   idle_time
            ,max(decode(stat_name,'IOWAIT_TIME', value-value_prev, null))   iowait_time
            ,max(decode(stat_name,'LOAD',             value, null))         load
            ,max(decode(stat_name,'OS_CPU_WAIT_TIME', value, null))         os_cpu_wait_time
            ,max(decode(stat_name,'RSRC_MGR_CPU_WAIT_TIME', value-value_prev, null))   rsrc_mgr_cpu_wait_time
            ,max(decode(stat_name,'NUM_CPUS',         value, null))         num_cpus            
            ,max(decode(stat_name,'NUM_CPU_CORES',    value, null))         num_cpu_cores            
            ,max(decode(stat_name,'NUM_CPU_SOCKETS',  value, null))         num_cpu_sockets      
            ,max(decode(stat_name,'PHYSICAL_MEMORY_BYTES',  value, null))   physical_memory_bytes      
            ,max(decode(stat_name,'FREE_MEMORY_BYTES',  value, null))       free_memory_bytes      
            ,max(decode(stat_name,'INACTIVE_MEMORY_BYTES',  value, null))   inactive_memory_bytes      
            ,max(decode(stat_name,'VM_IN_BYTES',  value, null))             vm_in_bytes      
            ,max(decode(stat_name,'VM_OUT_BYTES',  value, null))            vm_out_bytes      
            ,max(decode(stat_name,'SWAP_FREE_BYTES',  value, null))         swap_free_bytes      
            ,max(decode(stat_name,'DB CPU',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          db_cpu_to_cpu_count    
            ,max(decode(stat_name,'DB CPU',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/1*100 else 0 end
                , null))          db_cpu_to_os_cpu
            ,max(decode(stat_name,'background cpu time',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          bg_cpu_to_cpu_count    
            ,max(decode(stat_name,'RMAN cpu time (backup/restore)',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          rman_cpu_to_cpu_count    
            ,max(decode(stat_name,'DB time',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          db_time_to_cpu_count    
        from (
                select 
                     begin_interval_time
                    ,end_interval_time
                    ,stat_name
                    ,lag(stat.stat_name) over (order by stat.stat_name,end_interval_time) stat_name_prev
                    ,lag(value) over (order by stat.stat_name,end_interval_time) value_prev
                    ,value
                from  dba_hist_snapshot  snap
                    left outer join dba_hist_osstat  stat on snap.dbid = stat.dbid and snap.instance_number = stat.instance_number and snap.snap_id = stat.snap_id
                    cross join parms
                where 1=1 
                    and snap.end_interval_time between parms.start_date and parms.end_date
                    and snap.instance_number = parms.instance_number
                union all
                select 
                     begin_interval_time
                    ,end_interval_time
                    ,stat_name
                    ,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
                    ,lag(value) over (order by stat_name,end_interval_time) value_prev
                    ,value
                from dba_hist_snapshot hs
                    join dba_hist_sys_time_model hstm on hs.dbid = hstm.dbid and hs.instance_number = hstm.instance_number and hstm.snap_id = hs.snap_id
                    cross join parms
                where 1=1
                    and hs.end_interval_time between parms.start_date and parms.end_date
                    and hs.instance_number = parms.instance_number
                    and stat_name in ( 'DB time','DB CPU','background cpu time','RMAN cpu time (backup/restore)')
        )
        where stat_name =stat_name_prev
        group by end_interval_time
    ) stats
order by end_interval_time]]></sql>
			</query>
		</display>
	</display>
</folder>
</displays>