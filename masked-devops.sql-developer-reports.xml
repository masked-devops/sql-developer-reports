<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[Masked Devops]]></name>
	<tooltip><![CDATA[Masked Devops SQL Developer Reports]]></tooltip>
	<description><![CDATA[ ]]></description>
		<display id="9d63a4bf-0183-1000-8001-c0a83801a02f" type="" style="Chart" enable="true">
		<name><![CDATA[Masked Devops AWR Reports + Time Model]]></name>
		<description><![CDATA[View Time Model graph, AWR,ASH,ADDM reports]]></description>
		<tooltip><![CDATA[View Time Model graph, AWR,ASH,ADDM reports]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[Hours]]></Y1AXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<STYLE><![CDATA[Default]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<XAXIS_TITLE><![CDATA[true]]></XAXIS_TITLE>
			<THREED><![CDATA[false]]></THREED>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<XAXIS_TITLE_TEXT><![CDATA[End Interval Time]]></XAXIS_TITLE_TEXT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
--https://docs.oracle.com/en/database/oracle/oracle-database/19/refrn/V-SESS_TIME_MODEL.html#GUID-B5CF4362-325D-4F22-9A08-0873FA32A5C0
--''Db time'' Statistics Value is not Equal to the Sum of Children Statistic Times (Doc ID 356885.1)
-- 1) background elapsed time
--     2) background cpu time
--           3) RMAN cpu time (backup/restore)
-- 1) DB time
--     2) DB CPU
--     2) connection management call elapsed time
--     2) sequence load elapsed time
--     2) sql execute elapsed time
--     2) parse time elapsed
--           3) hard parse elapsed time
--                 4) hard parse (sharing criteria) elapsed time
--                     5) hard parse (bind mismatch) elapsed time
--           3) failed parse elapsed time
--                 4) failed parse (out of shared memory) elapsed time
--     2) PL/SQL execution elapsed time
--     2) inbound PL/SQL rpc elapsed time
--     2) PL/SQL compilation elapsed time
--     2) Java execution elapsed time
--     2) repeated bind elapsed time
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select
	 to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
	,stat_name
	,case when (value - value_prev) < 0 then 0 else	 (value - value_prev)/1000000/60/60 end value_hr
from (	select
			end_interval_time
			,stat_name
			,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
			,lag(value) over (order by stat_name,end_interval_time) value_prev
			,value
		from dba_hist_sys_time_model hstm
			join dba_hist_snapshot hs on hstm.dbid = hs.dbid and hstm.instance_number = hs.instance_number and hstm.snap_id = hs.snap_id
	),parms
where stat_name =stat_name_prev
	--and stat_name = 'DB time'
	and not regexp_like(stat_name,'DB time|^hard parse|^failed parse|cpu time')
	and end_interval_time between  parms.start_date and parms.end_date
order by end_interval_time asc]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Info]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from (
		select
			 di.db_name
			,di.instance_name
			,s.snap_id
			,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
			,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
			,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
			,di.dbid
			,di.instance_number
			,s.begin_interval_time begin_time
			,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
	)
where  end_interval_time=  to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_report_text(dbid,instance_number,snap_id_prev,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="plsql-dbms_output" enable="true">
			<name><![CDATA[AWR html]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[--select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
--union all
--select output from snaps,table(dbms_workload_repository.awr_report_html(dbid,instance_number,snap_id_prev,snap_id))

begin
    dbms_output.enable (buffer_size => null);
    for awr in (
        with snaps
            as (select *
                from (
                        select
                             di.db_name
                            ,di.instance_name
                            ,s.snap_id
                            ,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
                            ,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
                            ,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
                            ,di.dbid
                            ,di.instance_number
                            ,s.begin_interval_time begin_time
                        from dba_hist_snapshot s
                            left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
                                )
                            where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
                )
    select output from snaps,table(dbms_workload_repository.awr_report_html(snaps.dbid,snaps.instance_number,snaps.snap_id_prev,snaps.snap_id))
    )
    loop
        dbms_output.put_line(awr.output);
    end loop;
end;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR text global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_global_report_text(dbid,'',snap_id_prev ,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR html global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'awr_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.awr_global_report_html(dbid,'',snap_id_prev ,snap_id))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
                )
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_report_text(dbid,instance_number,begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH html]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_report_html(dbid,instance_number,begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH text global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_global_report_text(dbid,'',begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH html global]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||' -->' output from snaps
union all
select output from snaps,table(dbms_workload_repository.ash_global_report_html(dbid,'',begin_time,end_time))]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[ADDM text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on
with snaps
as (select *
	from (
			select
				 di.db_name
				,di.instance_name
				,s.snap_id
				,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
				,to_char(s.begin_interval_time,'yyyy-mm-dd hh24:mi:ss') begin_interval_time
				,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
				,di.dbid
				,di.instance_number
				,s.begin_interval_time begin_time
				,s.end_interval_time   end_time
			from dba_hist_snapshot s
                left outer join dba_hist_database_instance di on s.dbid = di.dbid and s.instance_number = di.instance_number and s.startup_time = di.startup_time
		)
	where  end_interval_time = to_char(:END_INTERVAL_TIME,'yyyy-mm-dd hh24:mi:ss')
	)
select '<!-- '|| 'addm_report'||'.'||db_name||'.'||instance_name||'.'||to_char(begin_time,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||' -->' output from snaps
union all
select dbms_advisor.get_task_report('ADDM:'||dbid||'_'||instance_number||'_'||snap_id,'TEXT','ALL','ALL','SYS') as report  FROM	   snaps,dual;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ADDM findings]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	 find.task_id
	,find.finding_id
	,find.finding_name
	,find.type				finding_type
	,find.impact			finding_impact
	,trim(find.message)		finding_message
	,rec.rec_id
	,rec.type				reccomendation_type
	,rec.benefit_type
	,rec.benefit
	,rat.rationale_id
	,rat.impact_type
	,rat.impact
	,rat.message
from dba_advisor_findings find,dba_advisor_recommendations rec,dba_advisor_rationale rat
where 1=1
	and find.task_id = rec.task_id(+)
	and find.finding_id = rec.finding_id(+)
	and rec.task_id = rat.task_id(+)
	and rec.rec_id = rat.rec_id(+)
	and find.task_id = (select task_id from dba_advisor_tasks where task_name = 'ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:SNAP_ID)
order by find.finding_id,rec.rec_id,rat.rationale_id]]></sql>
			</query>
		</display>
	</display>
	<display id="8dc29dde-0183-1000-8009-c0a83801b45d" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops Read Trace File]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[Read Trace files in instance DIAG]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
select 
     to_char(dtf.change_time,'yyyy-mm-dd hh24:mi:ss') change_time                           
    ,to_char(dtf.modify_time,'yyyy-mm-dd hh24:mi:ss') modify_time                           
    ,dtf.adr_home                                             
    ,dtf.trace_filename                    
    ,sql_trace
    ,optimizer_trace
    ,dtf.con_id
from v$diag_trace_file dtf
    full outer join v$diag_app_trace_file datf on dtf.adr_home = datf.adr_home and dtf.trace_filename = datf.trace_filename and dtf.con_id = datf.con_id
where 1=1
order by change_time
;]]></sql>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Trace File Content]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select  
     to_char(timestamp,'yyyy-mm-dd hh24:mi:ss') timestamp                           
--    ,adr_home 
--    ,trace_filename 
    ,line_number 
    ,payload 
    ,record_type 
    ,section_name 
    ,session_id 
    ,serial# 
    ,record_level 
    ,parent_level 
    ,section_id 
    ,component_name 
    ,operation_name 
    ,file_name 
    ,function_name 
    ,thread_id 
    ,con_uid 
    ,container_name 
    ,con_id  
from v$diag_trace_file_contents dtfc
where 1=1
    and adr_home = :ADR_HOME
    and trace_filename = :TRACE_FILENAME
order by timestamp,trace_filename,line_number]]></sql>
				<binds>
					<bind id="ADR_HOME">
						<prompt><![CDATA[ADR_HOME]]></prompt>
						<tooltip><![CDATA[ADR_HOME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TRACE_FILENAME">
						<prompt><![CDATA[TRACE_FILENAME]]></prompt>
						<tooltip><![CDATA[TRACE_FILENAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="a30ab51f-0183-1000-8046-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops CPU]]></name>
		<description><![CDATA[V$SYSMETRIC_SUMMARY displays a summary of all system metric values for the long-duration system metrics. 
The average, maximum value, minimum value, and the value of one standard deviation for the last hour are displayed for each metric item.]]></description>
		<tooltip><![CDATA[Operating System CPU, Database CPU]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi')  end_interval_time
    --,(select value from dba_hist_sysstat natural join dba_hist_snapshot where  stat_name = 'logons current' and end_interval_time = stats.end_interval_time) sessions
    --,to_char(round((sys_time+user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')   "%busy"
    ,to_char(round((user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')             "user%"
    ,to_char(round((sys_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')              "sys%"
    ,to_char(round((idle_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')             "idle%"
    ,to_char(round((iowait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')           "iowait_time%"
    ,to_char(round((rsrc_mgr_cpu_wait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90') "rsrc_mgr_cpu_wait_time%"
    ,to_char(round((os_cpu_wait_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.90')      "os_cpu_wait_time%"
    ,to_char(round(load,3),'99990.90')                                                                          "load: active sessions"
    ,' '                                                                                                        "-->"
    ,to_char(round(db_cpu_to_cpu_count,3),'99990.90')                                                           "stm_db_cpu%"      
    ,to_char(round(db_cpu_to_os_cpu/num_cpus,3),'99990.90')                                                     "stm_db_cpu_to_os%"      
    ,to_char(round(bg_cpu_to_cpu_count,3),'99990.90')                                                           "stm_bg_cpu%"      
    ,to_char(round(rman_cpu_to_cpu_count,3),'99990.90')                                                         "stm_rman_cpu%"      
    ,to_char(round(db_time_to_cpu_count,3),'99990.90')                                                          "stm_db_time%"      
    ,' '                                                                                                        "<--"
    ,num_cpus                                                                                                   "ncpus"        
    ,num_cpu_cores                                                                                              "ncores"     
    ,num_cpu_sockets                                                                                            "nsockets"       
    ,to_char(round(physical_memory_bytes/1024/1024 ,3),'99990.90')                                              "physical_memory_mb"
    ,to_char(round(free_memory_bytes    /1024/1024 ,3),'99990.90')                                              "free_memory_mb"    
    ,to_char(round(inactive_memory_bytes/1024/1024 ,3),'99990.90')                                              "inactive_memory_mb"
    ,to_char(round(vm_in_bytes          /1024/1024 ,3),'99990.90')                                              "vm_in_mb"          
    ,to_char(round(vm_out_bytes         /1024/1024 ,3),'99990.90')                                              "vm_out_mb"        
    ,to_char(round(swap_free_bytes      /1024/1024 ,3),'99990.90')                                              "swap_free_mb"     
    ,parms.start_date 
    ,parms.end_date 
    ,parms.instance_number                           inst_id
from (  select 
             end_interval_time
            ,max(decode(stat_name,'SYS_TIME',    value-value_prev, null))   sys_time
            ,max(decode(stat_name,'USER_TIME',   value-value_prev, null))   user_time
            ,max(decode(stat_name,'IDLE_TIME',   value-value_prev, null))   idle_time
            ,max(decode(stat_name,'IOWAIT_TIME', value-value_prev, null))   iowait_time
            ,max(decode(stat_name,'LOAD',             value, null))         load
            ,max(decode(stat_name,'OS_CPU_WAIT_TIME', value, null))         os_cpu_wait_time
            ,max(decode(stat_name,'RSRC_MGR_CPU_WAIT_TIME', value-value_prev, null))   rsrc_mgr_cpu_wait_time
            ,max(decode(stat_name,'NUM_CPUS',         value, null))         num_cpus            
            ,max(decode(stat_name,'NUM_CPU_CORES',    value, null))         num_cpu_cores            
            ,max(decode(stat_name,'NUM_CPU_SOCKETS',  value, null))         num_cpu_sockets      
            ,max(decode(stat_name,'PHYSICAL_MEMORY_BYTES',  value, null))   physical_memory_bytes      
            ,max(decode(stat_name,'FREE_MEMORY_BYTES',  value, null))       free_memory_bytes      
            ,max(decode(stat_name,'INACTIVE_MEMORY_BYTES',  value, null))   inactive_memory_bytes      
            ,max(decode(stat_name,'VM_IN_BYTES',  value, null))             vm_in_bytes      
            ,max(decode(stat_name,'VM_OUT_BYTES',  value, null))            vm_out_bytes      
            ,max(decode(stat_name,'SWAP_FREE_BYTES',  value, null))         swap_free_bytes      
            ,max(decode(stat_name,'DB CPU',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          db_cpu_to_cpu_count    
            ,max(decode(stat_name,'DB CPU',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/1*100 else 0 end
                , null))          db_cpu_to_os_cpu
            ,max(decode(stat_name,'background cpu time',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          bg_cpu_to_cpu_count    
            ,max(decode(stat_name,'RMAN cpu time (backup/restore)',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          rman_cpu_to_cpu_count    
            ,max(decode(stat_name,'DB time',  
                case when value - value_prev > 0 then (value - value_prev)/1000000/((cast(end_interval_time as date) - cast(begin_interval_time as date))*24*60*60)/(select value from v$parameter where name = 'cpu_count')*100 else 0 end
                , null))          db_time_to_cpu_count    
        from (
                select 
                     begin_interval_time
                    ,end_interval_time
                    ,stat_name
                    ,lag(stat.stat_name) over (order by stat.stat_name,end_interval_time) stat_name_prev
                    ,lag(value) over (order by stat.stat_name,end_interval_time) value_prev
                    ,value
                from  dba_hist_snapshot  snap
                    left outer join dba_hist_osstat  stat on snap.dbid = stat.dbid and snap.instance_number = stat.instance_number and snap.snap_id = stat.snap_id
                    cross join parms
                where 1=1 
                    and snap.end_interval_time between parms.start_date and parms.end_date
                    and snap.instance_number = parms.instance_number
                union all
                select 
                     begin_interval_time
                    ,end_interval_time
                    ,stat_name
                    ,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
                    ,lag(value) over (order by stat_name,end_interval_time) value_prev
                    ,value
                from dba_hist_snapshot hs
                    join dba_hist_sys_time_model hstm on hs.dbid = hstm.dbid and hs.instance_number = hstm.instance_number and hstm.snap_id = hs.snap_id
                    cross join parms
                where 1=1
                    and hs.end_interval_time between parms.start_date and parms.end_date
                    and hs.instance_number = parms.instance_number
                    and stat_name in ( 'DB time','DB CPU','background cpu time','RMAN cpu time (backup/restore)')
        )
        where stat_name =stat_name_prev
        group by end_interval_time
    ) stats,parms
order by end_interval_time]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[2022-09-25 00:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[2022-09-25 23:59]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[sysmetric_summary avg]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Autumn]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
parms as (select 
                 to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi')        start_date
                ,to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi')	        end_date
                ,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE')) instance_number
		  from dual)
select
    end_interval_time
        ,metric_name
        ,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
    from dba_hist_sysmetric_summary stat 
        join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
    where 1=1 
        and snap.end_interval_time between :START_DATE and :END_DATE
        and (  (stat.metric_name = 'Background CPU Usage Per Sec' and stat.group_id = 2)
            or (stat.metric_name = 'CPU Usage Per Sec'            and stat.group_id = 2)
            or (stat.metric_name = 'Host CPU Usage Per Sec'       and stat.group_id = 2)
            )
order by end_interval_time]]></sql>
				<binds>
					<bind id="P_START_DATE">
						<prompt><![CDATA[P_START_DATE]]></prompt>
						<tooltip><![CDATA[P_START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_END_DATE">
						<prompt><![CDATA[P_END_DATE]]></prompt>
						<tooltip><![CDATA[P_END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[sysmetric_summary max]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[select
     end_interval_time
    ,metric_name
    ,maxval/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end maxval
from dba_hist_sysmetric_summary stat 
    join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
where 1=1 
    and snap.end_interval_time between :START_DATE and :END_DATE
    and (  (stat.metric_name = 'Background CPU Usage Per Sec' and stat.group_id = 2)
        or (stat.metric_name = 'CPU Usage Per Sec'            and stat.group_id = 2)
        or (stat.metric_name = 'Host CPU Usage Per Sec'       and stat.group_id = 2)
        )
order by end_interval_time]]></sql>
				<binds>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[CPU %]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     end_interval_time
    ,metric
    ,value
from (
    select   
         stats.*
        ,to_char(round((user_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')    user_pct
        ,to_char(round((sys_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')     sys_pct
        ,to_char(round((idle_time)/(sys_time + user_time + idle_time + iowait_time )*100,3),'99990.990')    idle_pct
    from (  select end_interval_time
                ,max(decode(stat_name,'SYS_TIME', value-value_prev, null))      sys_time
                ,max(decode(stat_name,'USER_TIME', value-value_prev, null))     user_time
                ,max(decode(stat_name,'IDLE_TIME', value-value_prev, null))     idle_time
                ,max(decode(stat_name,'IOWAIT_TIME', value-value_prev, null))   iowait_time
                ,max(decode(stat_name,'LOAD', value, null))                     load
            from (
                    select 
                        end_interval_time
                        ,stat_name
                        ,lag(stat_name) over (order by stat_name,end_interval_time) stat_name_prev
                        ,lag(value) over (order by stat_name,end_interval_time) value_prev
                        ,value        
                    from dba_hist_osstat stat 
                        join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
                    where 1=1 
                        and snap.end_interval_time between :START_DATE and :END_DATE
                        and snap.instance_number = :INST_ID
            )
            where stat_name =stat_name_prev
            group by end_interval_time
        ) stats
    )
unpivot (value FOR metric IN ( 
                            -- sys_time
                            --,user_time
                            --,idle_time
                            --,iowait_time
                            --,load
                             user_pct
                            ,sys_pct
                            --,idle_pct
                            )
    )  
order by end_interval_time,metric]]></sql>
				<binds>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INST_ID">
						<prompt><![CDATA[INST_ID]]></prompt>
						<tooltip><![CDATA[INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="aceb24cd-0183-1000-8065-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops Read Alert Log]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[Read Alert Log and trace files in it]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
		  from dual)
select
   to_char(originating_timestamp,'yyyy-mm-dd hh24:mi:ss') originating_timestamp
    --,addr                          
    --,indx                          
    --,inst_id                       
    --,adr_path_idx                  
    --,adr_home                      
    --,normalized_timestamp          
    --,organization_id               
    --,component_id                  
    --,host_id                      --DNS hostname of originating host                       
    --,host_address                 --IP of other network address of the originating host for the mesaage              
    --,message_type                  
    ,message_level                 
    --,message_id                    
    --,message_group                 
    --,client_id                     
    --,module_id                     
    --,process_id                   --ID of the process that originated the message                  
    --,thread_id                     
    --,user_id                       
    --,instance_id                   
    --,detailed_location            --Absolute pathname of supplemental detail file on the originating host             
    --,upstream_comp_id              
    --,downstream_comp_id            
    --,execution_context_id          
    --,execution_context_sequence    
    --,error_instance_id             
    --,error_instance_sequence       
    ,message_text                  
    --,message_arguments            --Arguments to be bound with the generic text of the message             
    --,supplemental_attributes       
    --,supplemental_details          
    --,partition                     
    --,record_id                     
    --,filename                      
    --,problem_key                   
    --,version    
from v$diag_alert_ext
    cross join parms
where 1=1
	and originating_timestamp between  parms.start_date and parms.end_date
order by originating_timestamp
;]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Info]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 'Click on Read Trace File report to see the content of the trace mentioned in the message.' info from dual
union all
select 'Click on this tab again when finished to read the trace files.' info from dual]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Read Trace File]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select  
     to_char(timestamp,'yyyy-mm-dd hh24:mi:ss') timestamp                           
    --,adr_home 
    ,trace_filename 
    ,payload 
    ,record_level 
    ,parent_level 
    ,record_type 
    ,section_id 
    ,section_name 
    ,component_name 
    ,operation_name 
    ,file_name 
    ,function_name 
    ,line_number 
    ,thread_id 
    ,session_id 
    ,serial# 
    ,con_uid 
    ,container_name 
    ,con_id  
from v$diag_trace_file_contents dtfc
where 1=1
    and instr(trim(regexp_substr(:MESSAGE_TEXT,'(\s)(\S*)(.trc)')), trace_filename) > 0
    and instr(trim(regexp_substr(:MESSAGE_TEXT,'(\s)(\S*)(.trc)')), adr_home) > 0
order by timestamp,trace_filename,line_number]]></sql>
				<binds>
					<bind id="MESSAGE_TEXT">
						<prompt><![CDATA[MESSAGE_TEXT]]></prompt>
						<tooltip><![CDATA[MESSAGE_TEXT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="adbe0d79-0183-1000-8073-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops AWR Sysstat]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select name,class,statistic#,stat_id,start_date,end_date,instance_number 
from v$statname,parms 
order by name]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[2022-09-23 00:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[2022-09-29 00:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[Graph]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	  end_interval_time
	 ,stat_name
	,case when (value-value_prev) < 0 or (value-value_prev) is null then 0 else (value-value_prev) end  value
from (
        select
            end_interval_time
            ,hs.stat_name
            ,lag(hs.stat_name) over (order by hs.stat_name,end_interval_time) stat_name_prev
            ,lag(value) over (order by hs.stat_name,end_interval_time) value_prev
            ,value
        from dba_hist_sysstat hs 
            join dba_hist_snapshot snap on hs.dbid = snap.dbid and hs.instance_number = snap.instance_number  and hs.snap_id = snap.snap_id 
        where 1=1
            and hs.stat_name = :NAME
            and end_interval_time between  :START_DATE and :END_DATE
)
where stat_name = stat_name_prev
order by end_interval_time]]></sql>
				<binds>
					<bind id="NAME">
						<prompt><![CDATA[NAME]]></prompt>
						<tooltip><![CDATA[NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[stat value]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	  end_interval_time
	 ,stat_name
	,case when (value-value_prev) < 0 or (value-value_prev) is null then 0 else (value-value_prev) end  value
from (
        select
            end_interval_time
            ,hs.stat_name
            ,lag(hs.stat_name) over (order by hs.stat_name,end_interval_time) stat_name_prev
            ,lag(value) over (order by hs.stat_name,end_interval_time) value_prev
            ,value
        from dba_hist_sysstat hs 
            join dba_hist_snapshot snap on hs.dbid = snap.dbid and hs.instance_number = snap.instance_number  and hs.snap_id = snap.snap_id 
        where 1=1
            and hs.stat_name = :NAME
            and end_interval_time between  :START_DATE and :END_DATE
)
where stat_name = stat_name_prev
order by end_interval_time]]></sql>
			</query>
		</display>
	</display>
	<display id="ade35797-0183-1000-808c-c0a838017079" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops Session Browser]]></name>
		<description><![CDATA[Browse session details and history]]></description>
		<tooltip><![CDATA[Browse session details and history]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
    parms as (select 
                 :P_SESSION_SID         p_session_sid 
                ,:P_SESSION_SERIAL#     p_session_serial#
                ,:P_INST_ID             p_inst_id
                ,:P_STATUS              p_status
                ,:P_REPORTS_DIR         p_reports_dir
              from dual)
select
	 s.inst_id
    ,s.con_id
	,s.username
	,s.sid
	,s.serial#
    ,p.spid "OSpid"
	,s.status
	,s.state
    ,s.pq_status--||'->' ||case ps.degree when null then 0 else ps.degree end parallel
    ,ps.degree
	,to_char(s.logon_time,'yyyy-mm-dd hh24:mi:ss') logon
	,s.sql_exec_id
	,s.sql_id
	,sql.plan_hash_value
	,to_char(sql_exec_start,'yyyy-mm-dd hh24:mi:ss') sql_exec_start
	,s.prev_sql_id
	,to_char(prev_exec_start,'yyyy-mm-dd hh24:mi:ss') prev_exec_start
	,s.module
	,s.program
    ,s.osuser||'@'||s.machine||'(client_pid='||s.process ||' client_port='||s.port||') -> server_pid='||p.spid "client->server"
	,substr(sql.sql_text,1,1100) sql_text
	,s.wait_time -- 0= STILL WAITING
	,s.event
	,s.lockwait
	,trunc(s.seconds_in_wait/60) min_in_wait
	,s.final_blocking_session
	,s.row_wait_obj#
	,case	when s.row_wait_obj# > 0 then o.owner||'.'||o.object_name ||'-'||o.object_type else null end wait_obj
	,substr(sql_prev.sql_text,1,1100) sql_text_prev
	,'alter system kill session '''||s.sid||','||s.serial#||',@'||s.inst_id||''';' kill_session
	,s.paddr
	,s.saddr
	,s.logon_time
	,to_char(s.logon_time,'yyyy-mm-dd hh24:mi:ss')	logon_time_char
    ,:P_REPORTS_DIR         p_reports_dir
from gv$session s
	left outer join dba_objects o	on s.row_wait_obj# = o.object_id
	left outer join gv$sql sql		on s.inst_id = sql.inst_id and s.sql_id = sql.sql_id and s.sql_child_number = sql.child_number
	left outer join gv$sql sql_prev on s.inst_id = sql_prev.inst_id and	 s.prev_sql_id = sql_prev.sql_id and s.prev_child_number = sql_prev.child_number
	left outer join gv$process p	on s.paddr = p.addr and s.inst_id = p.inst_id
    left outer join gv$px_session ps on s.inst_id = ps.inst_id and s.sid = ps.sid and s.serial# = ps.serial#
    cross join parms
where 1=1
	and s.sid =		nvl(parms.p_session_sid,      s.sid)
	and s.serial# = nvl(parms.p_session_serial#,  s.serial#)
	and s.inst_id = nvl(parms.p_inst_id,          s.inst_id)
	and s.status  = nvl(parms.p_status,           s.status)
    --and s.machine = nvl(:P_STATUS,  s.machine)
    --and s.module  = nvl(:P_MODULE,  s.module)
    --and s.machine = nvl(:P_PROGRAM, s.machine)]]></sql>
			<binds>
				<bind id="P_SESSION_SID">
					<prompt><![CDATA[P_SESSION_SID]]></prompt>
					<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SERIAL#">
					<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
					<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_STATUS">
					<prompt><![CDATA[P_STATUS]]></prompt>
					<tooltip><![CDATA[ACTIVE | INACTIVE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_REPORTS_DIR">
					<prompt><![CDATA[P_REPORTS_DIR]]></prompt>
					<tooltip><![CDATA[P_REPORTS_DIR]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[session]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
   s.username
   ,s.sid
   ,s.serial#
   ,s.module
   ,s.program
   ,s.action
   ,to_char(s.logon_time, 'yyyy-mm-dd hh24:mi:ss') logon_time
   ,s.status
   ,s.server
   ,s.state
   ,s.wait_class
   ,s.event
   ,s.wait_time
   ,s.seconds_in_wait
   ,s.lockwait
   ,s.blocking_session
   ,s.sql_id
   ,s.sql_child_number
   ,s.osuser
   ,s.machine
   ,s.row_wait_block#
   ,s.row_wait_row#
   ,s.last_call_et
   ,s.pdml_enabled
   ,s.failover_type
   ,s.failover_method
   ,s.failed_over
   ,s.resource_consumer_group
   ,s.pdml_status
   ,s.pddl_status
   ,s.pq_status
   ,s.current_queue_duration
   ,s.client_identifier
   ,s.blocking_session_status
   ,s.blocking_instance
   ,s.seq#
   ,s.event#
   ,s.p1text
   ,s.p1
   ,s.p1raw
   ,s.p2text
   ,s.p2
   ,s.p2raw
   ,s.p3text
   ,s.p3
   ,s.p3raw
   ,s.wait_class_id
   ,s.wait_class#
   ,s.service_name
   ,s.sql_trace
   ,s.sql_trace_waits
   ,s.sql_trace_binds
   ,s.audsid
   ,s.paddr
   ,s.user#
   ,s.username
   ,s.command
   ,s.ownerid
   ,s.taddr
   ,s.server
   ,s.schema#
   ,s.process
   ,s.terminal
   ,s.type
   ,s.sql_address
   ,s.sql_hash_value
   ,s.prev_sql_addr
   ,s.prev_hash_value
   ,s.prev_sql_id
   ,s.prev_child_number
   ,s.plsql_entry_object_id
   ,s.plsql_entry_subprogram_id
   ,s.plsql_object_id
   ,s.plsql_subprogram_id
   ,s.module_hash
   ,s.action_hash
   ,s.client_info
   ,s.fixed_table_sequence
   ,s.row_wait_obj#
   ,s.row_wait_file#
   ,s.saddr
   ,s.schemaname
   ,round (bitand (s.ownerid, 65535)) parent_session_sid
   ,round (bitand (s.ownerid, 16711680) / 65536) parent_session_instid
from gv$session s
where 1=1
	and s.inst_id = :INST_ID
    and s.sid = :SID
	and s.serial# = :SERIAL#]]></sql>
				<binds>
					<bind id="INST_ID">
						<prompt><![CDATA[INST_ID]]></prompt>
						<tooltip><![CDATA[INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SID">
						<prompt><![CDATA[SID]]></prompt>
						<tooltip><![CDATA[SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SERIAL#">
						<prompt><![CDATA[SERIAL#]]></prompt>
						<tooltip><![CDATA[SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[process]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     p.pid oracle_pid      -- oracle pid
    ,p.spid os_pid     -- dedicated_server os pid
    ,p.username  os_user
    ,p.traceid
    ,p.background
    ,p.latchwait
    ,p.latchspin
    ,trunc(p.pga_used_mem/1024/1024,2) pga_used_mem_mb
    ,trunc(p.pga_alloc_mem/1024/1024,2)  pga_alloc_mem_mb
    ,trunc(p.pga_freeable_mem/1024/1024,2) pga_freeable_mem_mb
    ,trunc(p.pga_max_mem/1024/1024,2) pga_max_mem_mb
from gv$process p
where 1=1
    and p.addr = :PADDR
	and p.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[transaction]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	 to_char(t.start_date,'yyyy-dd-mm hh24:mi:ss') start_date
	,t.xidusn		  -- segment number
	,r.segment_name
	,r.tablespace_name
	,t.used_urec	   used_urec_records
	,t.used_ublk	   used_ublk_blocks
	,trunc(t.used_ublk*8192/1024/1024)	used_ublk_mb
	,t.log_io			 "Logical I/O"
	,t.phy_io			 "Physical I/O"
	,t.cr_get			 "consistent gets"
	,t.cr_change		 "consistent change"
	,t.space
	,t.recursive
	,t.noundo
	,t.ptx parallel
	,t.name
	,xid
from gv$session s
		join gv$transaction t	 on s.inst_id = t.inst_id and s.saddr = t.ses_addr
			left outer join dba_rollback_segs r on t.xidusn = r.segment_id
where 1=1
	and s.sid = :SID
	and s.inst_id = :INST_ID
order by t.start_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[session_longops]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select s.sid
	,s.serial#
	,s.inst_id
	,sl.username
	--,s.lockwait
	,sl.opname
	,sl.target
	,sl.target_desc
	,s.machine
	,to_char(start_time,'yyyy-mm-dd hh24:mi:ss') start_time
	,round(sl.elapsed_seconds/60) || 'min ' || mod(sl.elapsed_seconds,60)||'sec' elapsed
	,round(sl.time_remaining/60)  || 'min ' || mod(sl.time_remaining,60)||'sec' remaining
	,round(sl.sofar/sl.totalwork*100, 2) prog_pct
	,substr(sql.sql_text,1,20)	sql_text
	,sl.message
	,sl.context
	,qcsid
from gv$session s
	join gv$session_longops sl	on s.sid = sl.sid and s.serial# = sl.serial# and s.inst_id = sl.inst_id
	left outer join gv$sql sql	on s.sql_id = sql.sql_id and s.sql_child_number = sql.child_number and s.inst_id = sql.inst_id
where 1=1
	and sl.totalwork != 0
	and sl.sofar  != sl.totalwork
	and sl.sid = :SID
	and sl.inst_id = :INST_ID
order by time_remaining]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[ASH history]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
  --ash.sample_id
  to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
  ,ash.con_id
  --,ash.is_awr_sample
  ,ash.session_id
  ,ash.session_serial#
  ,ash.sql_exec_id
  ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')	 sql_exec_start
  ,ash.session_type
  --,ash.flags
  ,u.username
  ,ash.user_id
  ,ash.sql_id
  ,ash.is_sqlid_current
  ,ash.sql_child_number
  --,ash.sql_opcode
  ,ash.sql_opname
  --,ash.force_matching_signature
  ,ash.top_level_sql_id
  --,ash.top_level_sql_opcode
  --,ash.sql_plan_hash_value
  ,ash.sql_plan_line_id
  ,ash.sql_plan_operation
  ,ash.sql_plan_options
  ,ash.plsql_entry_object_id
  ,ash.plsql_entry_subprogram_id
  ,ash.plsql_object_id
  ,ash.plsql_subprogram_id
  --,ash.qc_instance_id
  --,ash.qc_session_id
  --,ash.qc_session_serial#
  --,ash.px_flags
  ,ash.event
  --,ash.event_id
  --,ash.event#
  ,ash.seq#
  ,ash.p1text
  ,ash.p1
  ,ash.p2text
  ,ash.p2
  ,ash.p3text
  ,ash.p3
  ,ash.wait_class
  --,ash.wait_class_id
  ,ash.wait_time
  ,ash.session_state
  ,ash.time_waited
  ,ash.blocking_session_status
  ,ash.blocking_session
  ,ash.blocking_session_serial#
  ,ash.blocking_inst_id
  ,ash.blocking_hangchain_info
  ,o.object_name
  ,f.name datafile
  --,ash.current_obj#
  --,ash.current_file#
  ,ash.current_block#
  ,ash.current_row#
  --,ash.top_level_call#
  ,ash.top_level_call_name
  ,ash.consumer_group_id
  ,ash.xid
  ,ash.remote_instance#
  --,ash.time_model
  --,ash.in_connection_mgmt
  --,ash.in_parse
  --,ash.in_hard_parse
  --,ash.in_sql_execution
  --,ash.in_plsql_execution
  --,ash.in_plsql_rpc
  --,ash.in_plsql_compilation
  --,ash.in_java_execution
  --,ash.in_bind
  --,ash.in_cursor_close
  --,ash.in_sequence_load
  --,ash.capture_overhead
  --,ash.replay_overhead
  --,ash.is_captured
  --,ash.is_replayed
  --,ash.service_hash
  ,ash.program
  ,ash.module
  ,ash.action
  ,ash.client_id
  ,ash.machine
  ,ash.port
  ,ash.ecid
  --,ash.dbreplay_file_id
  --,ash.dbreplay_call_counter
  --,ash.tm_delta_time
  --,ash.tm_delta_cpu_time
  --,ash.tm_delta_db_time
  --,ash.delta_time
  --,ash.delta_read_io_requests
  --,ash.delta_write_io_requests
  --,ash.delta_read_io_bytes
  --,ash.delta_write_io_bytes
  --,ash.delta_interconnect_io_bytes
  ,ash.pga_allocated
  ,ash.temp_space_allocated
  ,substr(sqlt.sql_text,1,100) sqltext
from gv$active_session_history ash
		left  outer join gv$sqlstats sqlt	on ash.inst_id = sqlt.inst_id and ash.sql_id = sqlt.sql_id and ash.sql_plan_hash_value = sqlt.plan_hash_value and ash.con_id = sqlt.con_id
		left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
		left  outer join gv$event_name e	on ash.inst_id = e.inst_id and ash.event_id = e.event_id
		left  outer join cdb_objects o		on ash.current_obj# = o.object_id and ash.con_id = o.con_id
		left  outer join gv$datafile f		on ash.inst_id = f.inst_id and ash.current_file# = f.file#
where 1=1
	------- additional filters
	and ash.inst_id = :INST_ID
	and ash.session_id = :SID
	and ash.session_serial# = :SERIAL#
    and ash.sample_time >= :LOGON_TIME
order by ash.sample_id]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[ASH report]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set trimspool on
set pages 10000
set linesize 1000
set long 1000000
set longchunksize 1000000
set feedback off
set heading off
set sqlprompt ''
set echo off verify off time off timing off
select 'Open the file paths below in a browser.' from dual;
select 'Reports creation in progress...' from dual;
set termout off
col reports_dest_dir new_value reports_dest_dir
select nvl(:P_REPORTS_DIR,'c:\temp')  reports_dest_dir  from dual;

col slash new_value slash
select case when instr('&REPORTS_DEST_DIR.','\') > 0 then '\' else '/' end   slash from dual;

col awr_report new_value awr_report
col ash_report new_value ash_report
select
     '&REPORTS_DEST_DIR.&SLASH.'||'awr_sql_report.'||:SID||'.html'  awr_report
    ,'&REPORTS_DEST_DIR.&SLASH.'||'ash_sql_report.'||:SID||'.html'  ash_report
from dual;
    

--spool &AWR_REPORT
--select * from table(dbms_workload_repository.awr_sql_report_html(:DBID, :INSTANCE_NUMBER, :SNAP -1, :SNAP, :SQL_ID));
--spool off

set termout off
spool &ASH_REPORT
select output from table(
dbms_workload_repository.ash_report_html(
   l_dbid			=> (select dbid from v$database),
   l_inst_num		=> :INST_ID,
   l_btime			=> to_date(:LOGON_TIME_CHAR,'yyyy-mm-dd hh24:mi:ss'),
   l_etime			=> sysdate,
   l_slot_width		=> 300, --seconds
   l_sid			=> :SID
));
spool off

set termout on heading on
--select	'&AWR_REPORT'  as "AWR Report" from dual;
select	'&ASH_REPORT'  as "ASH Report" from dual;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[SQL execs]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
     sqlt.inst_id
    ,ash.sql_exec_id
    ,ash.sql_id
	,max(xid)
    ,count(*)
	,extract(day from ((max(ash.sample_time)-min(ash.sample_time))))*24*60*60 + extract (hour from ((max(ash.sample_time)-min(ash.sample_time))))*60*60 + extract (minute from ((max(ash.sample_time)-min(ash.sample_time))))*60 + extract (second from ((max(ash.sample_time)-min(ash.sample_time)))) elapsed_sec
	,to_char(min(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') start_time
	,to_char(max(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') end_time
	,sql_text
from gv$active_session_history ash
		left outer join gv$sqlstats sqlt on ash.sql_id = sqlt.sql_id and ash.sql_plan_hash_value = sqlt.plan_hash_value and ash.inst_id = sqlt.inst_id
where 1=1
	and ash.inst_id = :INST_ID
	and ash.session_id = :SID
	and ash.session_serial# = :SERIAL#
	and ash.sample_time >= :P_LOGON_TIME
group by ash.sql_exec_id,ash.sql_id,sqlt.sql_text,sqlt.inst_id
order by start_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[SQL execs events]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
     sqlt.inst_id
    ,ash.sql_exec_id
    ,ash.sql_id
    ,sql_plan_hash_value
	,case
		when ash.session_state = 'ON CPU' then 'ON CPU'
		when ash.session_state = 'WAITING' then ash.event
		else 'WAIT'
     end event
	,ash.in_parse p
	,ash.in_hard_parse hp
	,max(xid)
	,count(*)
	,extract(day from ((max(ash.sample_time)-min(ash.sample_time))))*24*60*60 + extract (hour from ((max(ash.sample_time)-min(ash.sample_time))))*60*60 + extract (minute from ((max(ash.sample_time)-min(ash.sample_time))))*60 + extract (second from ((max(ash.sample_time)-min(ash.sample_time)))) elapsed_sec
	,to_char(min(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') start_time
	,to_char(max(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') end_time
	,sql_text
from gv$active_session_history ash
		left outer join gv$sqlstats sqlt on ash.sql_id = sqlt.sql_id and ash.sql_plan_hash_value = sqlt.plan_hash_value and ash.inst_id = sqlt.inst_id
where 1=1
	and ash.inst_id = :INST_ID
	and ash.session_id = :SID
	and ash.session_serial# = :SERIAL#
	and ash.sample_time >= :P_LOGON_TIME
group by ash.sql_exec_id,ash.sql_id,sql_plan_hash_value,ash.wait_class, ash.in_parse, ash.in_hard_parse,sqlt.inst_id
	, case
		when ash.session_state = 'ON CPU' then 'ON CPU'
		when ash.session_state = 'WAITING' then ash.event
		else 'WAIT'
	end
	,sqlt.sql_text
order by start_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[SQL execs plan]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
     sqlt.inst_id
    ,ash.sql_exec_id
    ,ash.sql_id
    ,sql_plan_hash_value
    ,sql_plan_line_id
    ,sql_opname
	,case
		when ash.session_state = 'ON CPU' then 'ON CPU'
		when ash.session_state = 'WAITING' then ash.event
		else 'WAIT'
     end event
	,max(xid)
	,count(*)
	,extract(day from ((max(ash.sample_time)-min(ash.sample_time))))*24*60*60 + extract (hour from ((max(ash.sample_time)-min(ash.sample_time))))*60*60 + extract (minute from ((max(ash.sample_time)-min(ash.sample_time))))*60 + extract (second from ((max(ash.sample_time)-min(ash.sample_time)))) elapsed_sec
	,to_char(min(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') start_time
	,to_char(max(ash.sample_time),'yyyy-mm-dd hh24:mi:ss') end_time
	,sql_text
from gv$active_session_history ash
		left outer join gv$sqlstats sqlt on ash.sql_id = sqlt.sql_id and ash.sql_plan_hash_value = sqlt.plan_hash_value and ash.inst_id = sqlt.inst_id
where 1=1
	and ash.inst_id = :INST_ID
	and ash.session_id = :SID
	and ash.session_serial# = :SERIAL#
	and ash.sample_time >= :P_LOGON_TIME
group by ash.sql_exec_id,ash.sql_id,sql_plan_hash_value,sql_plan_line_id,sql_opname,sqlt.inst_id
	, case
		when ash.session_state = 'ON CPU' then 'ON CPU'
		when ash.session_state = 'WAITING' then ash.event
		else 'WAIT'
	end
	,sqlt.sql_text
order by start_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sess_io]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from gv$sess_io si
where 1=1
	and sid	 = :SID
	and si.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[session_wait]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select SID,SEQ#,EVENT,P1TEXT,P1,rawtohex(P1RAW) P1RAW,P2TEXT,P2,rawtohex(P2RAW) P2RAW,P3TEXT,P3,rawtohex(P3RAW) P3RAW,WAIT_TIME,SECONDS_IN_WAIT,STATE
from gv$session_wait sw
where 1=1
	and sid=:SID
	and sw.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[session_event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select event, total_waits, total_timeouts, round(time_waited/1000000,3) time_waited_sec, average_wait average_wait_hsec,max_wait max_wait_hsec
from gv$session_event se
where 1=1
	and sid = :SID
	and se.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[open_cursor]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     rawtohex(saddr) saddr
    ,sid
    ,user_name
    ,rawtohex(address) address
    ,hash_value
    ,to_char(last_sql_active_time,'yyyy-mm-dd hh24:mi:ss') last_sql_active_time
    ,sql_exec_id
    ,cursor_type
    ,sql_text
from gv$open_cursor oc
where 1=1
	and oc.sid = :SID
	and oc.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[access]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select sid, owner, type, object
from gv$access a
where 1=1
	and a.sid = :SID
	and a.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[lock]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select  s.sid
	,s.serial#
	,s.username
	,decode(l.type,'RW','RW - Row Wait Enqueue', 'TM','TM - DML Enqueue', 'TX','TX - Trans Enqueue', 'UL','UL - User',l.type||'System') res
	,u.name object_owner
	,substr(t.name,1,30) object_name
	,l.id1
	,l.id2
	,decode(l.lmode,1,'No Lock', 2,'Row Share', 3,'Row Exclusive', 4,'Share', 5,'Shr Row Excl', 6,'Exclusive',null) lmode
	,decode(l.request,1,'No Lock', 2,'Row Share', 3,'Row Excl', 4,'Share', 5,'Shr Row Excl', 6,'Exclusive',l.request) request
	,l.ctime --Time since current mode was granted, in seconds
	, decode(l.block,0, 'Not Blocking',1, 'Blocking',2, 'Global') block --A value of either 0 or 1, depending on whether or not the lock in question is the blocker.
	,substr(sql.sql_text,1,1100) sql_text
	--,'alter system kill session '''||s.sid||','||s.serial#||''';' kill_session
	, s.osuser||'@'||s.machine||' (SID='||s.sid||' username='||s.username||' module='||s.module||' program='||s.program||')' osuser
from gv$lock l
		left outer join gv$session s	on l.inst_id = s.inst_id and l.sid = s.sid
		left outer join sys.obj$ t		on l.id1 = t.obj#
			left outer join sys.user$ u		on u.user# = t.owner#
		left outer join gv$sql sql		on l.inst_id = sql.inst_id and s.sql_id = sql.sql_id and s.sql_child_number = sql.child_number
where 1=1
	and s.sid = :SID
	and s.serial# = :SERIAL#
	and l.inst_id = :INST_ID
order by username,l.ctime]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sesstat]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT
	a.SID,
	DECODE (b.CLASS,
	1, 'User',
	2, 'Redo',
	4, 'Enqueue',
	8, 'Cache',
	16, 'OS',
	32, 'ParallelServer',
	64, 'SQL',
	128, 'Debug',
	72, 'SQL & Cache',
	40, 'ParallelServer & Cache'
	) CLASS,
	b.NAME, a.VALUE
FROM gv$sesstat a
		join gv$statname b on a.inst_id = b.inst_id and a.statistic# = b.statistic#
where 1=1
	and sid = :SID
	and a.inst_id = nvl(:INST_ID, a.inst_id)]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[session_wait_history]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
	 seq# --Sequence of wait events; 1 is the most recent
	,event
	,wait_time
	,p1
	,p2
	,p3
	,time_since_last_wait_micro
from	 gv$session_wait_history swh
where 1=1
	and SID = :SID
	and swh.inst_id = :INST_ID
order by seq#]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sort_usage]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select s.username, 
    s.sid,  
    u.sql_id,  --wrong from temp lobs?
    u.tablespace, 
    u.contents, 
    u.segtype,
    --u.segfile#,
    u.extents, 
    u.blocks,
    trunc((u.blocks * t.block_size)/1024/1024,3) as Mb,
    s.osuser||'@'||s.machine||'(pid='||s.process ||' port='||s.port||')' client,
    trunc(pga_used_mem/1024/1024,2)      pga_used_mem,
    trunc(pga_alloc_mem/1024/1024,2)     pga_alloc_mem,
    trunc(pga_freeable_mem/1024/1024,2)  pga_freeable_mem,
    trunc(pga_max_mem/1024/1024,2)       pga_max_mem,
    substr(sql.sql_text,1,1100)          sql_text
from gv$session s
    left outer join gv$sort_usage u on  s.inst_id = u.inst_id and s.saddr = u.session_addr
    left outer join gv$process p on  s.inst_id = p.inst_id and s.paddr = p.addr
    left outer join dba_tablespaces t on u.tablespace = t.tablespace_name
    left outer join gv$sql sql on s.inst_id = sql.inst_id and s.sql_id = sql.sql_id and s.sql_child_number = sql.child_number
where 1=1
    and u.blocks is not null
	and s.sid = :SID
	and s.inst_id = :INST_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[parallel]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     ps.qcsid
    ,ps.qcsid                                                       "Parent SID"
    --,ps.sid
    ,decode(ps.server_set,'',' --', ps.sid)                         "Child SID"
    ,ps.inst_id                                                     "Inst"
    ,ps.server_group                                                "Group"
    ,ps.server_set                                                  "Set"
    ,ps.degree                                                      "Degree"
    ,req_degree                                                     "Req Degree"
    ,decode(ps.server_set,'',s.program,'  PX Slave')                "Program"
    ,ps.degree ||decode(ps.degree,'',' --','/')||ps.req_degree      "DOP/REQ"
    ,decode(ps.server_set,'','Coordinator Process', ps.server_set)  "Server Set"
    ,nvl(p.server_name,' --')                                       "PX Server"
    ,nvl(p.status,' --')                                            "PX Server Status"
    ,to_char(sl.start_time,'yyyy-mm-dd hh24:mi:ss')                    start_time
    ,round(sl.elapsed_seconds/60) || 'min ' || mod(sl.elapsed_seconds,60)||'sec' elapsed
    ,round(sl.time_remaining/60)  || 'min ' || mod(sl.time_remaining,60)||'sec' remaining
    ,round(sl.sofar/sl.totalwork*100, 2) prog_pct
    ,sl.opname
    ,sl.sql_plan_line_id
    ,sl.sql_plan_operation
    ,sl.sql_plan_options
    ,sl.message
    --,substr(sql.sql_text,1,100) sql_text
from gv$px_session ps 
        left outer join gv$px_process p          on ps.sid = p.sid and ps.serial# = p.serial# and ps.inst_id = p.inst_id
        left outer join gv$session s             on ps.sid = s.sid and ps.serial# = s.serial# and ps.inst_id = s.inst_id
            left outer join gv$session_longops sl    on s.sid = sl.sid and s.serial# = sl.serial# and s.inst_id = sl.inst_id and sl.totalwork != 0 and sl.sofar  != sl.totalwork
            left outer join gv$sql sql               on s.sql_id = sql.sql_id and s.sql_child_number = sql.child_number and s.inst_id = sql.inst_id
where 1=1
	and ps.sid = :SID
	and ps.serial# = :SERIAL#
	and ps.inst_id = :INST_ID    
order by qcsid, qcinst_id, server_group, server_set]]></sql>
			</query>
		</display>
		<display id="null" type="" style="plsql-dbms_output" enable="true">
			<name><![CDATA[sesstat int]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[--set serveroutput on size unlimited 
declare 
    type stat_rec           is record (class varchar2(50), value number);
    type assoc_stat_rec     is table of stat_rec index by varchar2(64);
    l_rec                   stat_rec;
    l_assoc_stat_rec_pre    assoc_stat_rec;   
    l_assoc_stat_rec_post   assoc_stat_rec;   
    l_idx                   varchar2(64);
    l_diff                  number;
    l_sleep                 number := 5;
    l_sid                   number := :SID;          
begin
    for x in (select a.sid, decode (b.class, 1, 'User', 2, 'Redo', 4, 'Enqueue', 8, 'Cache', 16, 'OS', 32, 'ParallelServer', 64, 'SQL', 128, 'Debug', 72, 'SQL and Cache', 40, 'ParallelServer and Cache' ) class, b.name, a.value from gv$sesstat a join gv$statname b on a.inst_id = b.inst_id and a.statistic# = b.statistic# where 1=1 and sid = l_sid)
    loop l_rec.class := x.class; l_rec.value := x.value;l_assoc_stat_rec_pre(x.name):= l_rec; end loop;
    sys.dbms_lock.sleep(3);
    for x in (select a.sid, decode (b.class, 1, 'user', 2, 'redo', 4, 'enqueue', 8, 'cache', 16, 'os', 32, 'parallelserver', 64, 'sql', 128, 'debug', 72, 'sql and cache', 40, 'parallelserver and cache' ) class, b.name, a.value from gv$sesstat a join gv$statname b on a.inst_id = b.inst_id and a.statistic# = b.statistic# where 1=1 and sid = l_sid)
    loop l_rec.class := x.class;l_rec.value := x.value;l_assoc_stat_rec_post(x.name):= l_rec; end loop;
    l_idx := l_assoc_stat_rec_pre.first;
    while (l_idx is not null)
        loop
        begin
            if l_assoc_stat_rec_pre(l_idx).value != l_assoc_stat_rec_post(l_idx).value then
                l_diff := l_assoc_stat_rec_post(l_idx).value - l_assoc_stat_rec_pre(l_idx).value;
                dbms_output.put_line(rpad(l_idx,64) ||' = '|| l_diff);
            end if;
            l_idx := l_assoc_stat_rec_pre.next(l_idx);
        exception
            when others then
                dbms_output.put_line(l_idx || ': error');
                l_idx := l_assoc_stat_rec_pre.next(l_idx);
        end;
        end loop;
end;]]></sql>
			</query>
		</display>
<item  reload="false"  reloadparent="false" removeFromParent="false" className="oracle.dbtools.raptor.report.addin.DrillReportAction" classArgs="fea64347-0159-1000-8001-0b0e1297e47e" toolbar="false" ><title>Emanuele SQL Monitoring</title></item>	</display>
	<display id="b2b2acfc-0183-1000-801e-c0a83801440a" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops AWR Reports]]></name>
		<description><![CDATA[Create AWR/ASH/ADDM report files]]></description>
		<tooltip><![CDATA[Create AWR/ASH/ADDM report files]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[
                -- -----------------------------------------------------------------------------
                -- Author      : Masked DevOps
                -- Date        : Jan 2012
                -- Version     : 0.1
                --
                --!!!Edit this report from the xml file only, not from SQL Developer!!!
                --
                -- SQL Developer report for database administration 
                -- Copyright (C) 2022  Emanuele Moccia
                -- masked.devops@yahoo.com
                -- 
                -- This program is free software: you can redistribute it and/or modify
                -- it under the terms of the GNU General Public License as published by
                -- the Free Software Foundation, either version 3 of the License, or
                -- any later version.
                -- 
                -- This program is distributed in the hope that it will be useful,
                -- but WITHOUT ANY WARRANTY; without even the implied warranty of
                -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                -- GNU General Public License for more details.
                -- 
                -- You should have received a copy of the GNU General Public License
                -- along with this program.  If not, see <https://www.gnu.org/licenses/>.
                -- -----------------------------------------------------------------------------
                with
                     parms as ( select
                                     nvl(:reports_dest_dir,'c:\temp')                                   reports_dest_dir
                                    ,case when instr(:reports_dest_dir,'\') > 0 then '\' else '/' end   slash
                                from dual)
                select
                     snap_id start_snap_id
                    ,to_char(end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  start_snap_date
                    ,db_name
                    ,instance_name
                    ,dbid
                    ,instance_number
                    ,reports_dest_dir
                    --,slash
                from (  select
                             di.db_name
                            ,di.instance_name
                            ,s.snap_id
                            ,lag(snap_id) over (partition by s.dbid,di.db_name,di.instance_number order by snap_id) as snap_id_prev
                            ,s.end_interval_time
                            ,di.dbid
                            ,di.instance_number
                        from dba_hist_snapshot s, dba_hist_database_instance di
                        where 1=1
                            and s.dbid                = di.dbid(+)
                            and s.instance_number     = di.instance_number(+)
                            and s.startup_time        = di.startup_time(+)
                    ) snaps,parms
                where snap_id_prev is not null
                order by end_interval_time ,instance_number, snap_id
                ]]></sql>
			<binds>
				<bind id="reports_dest_dir">
					<prompt><![CDATA[reports_dest_dir]]></prompt>
					<tooltip><![CDATA[reports_dest_dir]]></tooltip>
					<value><![CDATA[C:\temp]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="3232034d-015e-1000-8002-0b0e12972947" type="" style="Table" enable="true">
			<name><![CDATA[End Snap]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[
                            select
                                 s.snap_id end_snap_id
                                ,to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')  end_snap_date
                                ,di.db_name
                                ,di.instance_name
                                ,di.dbid
                                ,di.instance_number
                                ,:START_SNAP_ID start_snap_id
                                ,:START_SNAP_DATE  start_snap_date
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||:DBID||','||di.instance_number||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||:DBID||','||''''''||','||:START_SNAP_ID||','||s.snap_id||'));' ||
                                --    chr(10) || 'spool off' awr_global_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||di.instance_name||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||:DBID||','||di.instance_number||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_report_html
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_text
                                --,'set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off' ||
                                --    chr(10) || 'spool ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||'.'||'html;' ||
                                --    chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||:DBID||','||''''''||','||'to_date('''||:START_SNAP_DATE||''',''yyyy-mm-dd hh24:mi:ss'')'||','||'to_date('''||to_char(s.end_interval_time,'yyyy-mm-dd_hh24.mi.ss')||''',''yyyy-mm-dd hh24:mi:ss'')'||'));' ||
                                --    chr(10) || 'spool off' ash_global_report_html
                            from dba_hist_snapshot s, dba_hist_database_instance di
                            where 1=1
                                and s.dbid                = di.dbid(+)
                                and s.instance_number     = di.instance_number(+)
                                and s.startup_time        = di.startup_time(+)
                                and s.dbid                = :DBID
                                and s.instance_number     = :INSTANCE_NUMBER
                                and cast(s.end_interval_time as date) > to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss')
                            order by end_interval_time ,instance_name, snap_id
                            ]]></sql>
				<binds>
					<bind id="START_SNAP_ID">
						<prompt><![CDATA[START_SNAP_ID]]></prompt>
						<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_SNAP_DATE">
						<prompt><![CDATA[START_SNAP_DATE]]></prompt>
						<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DB_NAME">
						<prompt><![CDATA[DB_NAME]]></prompt>
						<tooltip><![CDATA[DB_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[Info]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                select
                                     :START_SNAP_ID start_snap_id
                                    ,:END_SNAP_ID end_snap_id
                                    ,:START_SNAP_DATE start_snap_date
                                    ,:END_SNAP_DATE end_snap_date
                                    ,:DB_NAME db_name
                                    ,:INSTANCE_NAME instance_name
                                    ,:INSTANCE_NUMBER instance_number
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  awr_txt
                                    --,'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' awr_html
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        awr_global_txt
                                    --,'awr_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       awr_global_html
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'  ash_txt
                                    --,'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;' ash_html
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'txt;'        ash_global_txt
                                    --,'ash_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||'html;'       ash_global_html
                                    from dual;
                    ]]></sql>
					<binds>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Table" enable="true">
				<name><![CDATA[SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
					<TYPE><![CDATA[horizontal]]></TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                SELECT
                                     sql_id
                                    ,plan_hash_value
                                    ,last_exec_start_time
                                    ,parsing_schema_name
                                    --,force_matching_signature
                                    ,executions
                                    --,elapsed_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   elapsed_time_sec
                                    ,to_char(case when executions > 0 then trunc(elapsed_time/1000000/executions,4) else 0 end,'99990.990')  avg_time_sec
                                    --,cpu_time
                                    ,to_char(round(elapsed_time/1000000,3),'9999990.990')   cpu_time_sec
                                    ,buffer_gets
                                    ,disk_reads
                                    ,direct_writes
                                    ,rows_processed
                                    ,fetches
                                    ,end_of_fetch_count
                                    ,substr(sql_text,1,40)  sql_text
                                    ,object_list
                                    --,bind_data
                                    ,module
                                    ,action
                                    ,optimizer_cost
                                    --,optimizer_env
                                    ,priority
                                    ,command_type
                                    ,first_load_time
                                    ,stat_period
                                    ,active_stat_period
                                    ,other
                                    --,sql_plan
                                    ,bind_list
                                    ,con_dbid
                                FROM table((dbms_sqltune.select_workload_repository (
                                    begin_snap          => :START_SNAP_ID,
                                    end_snap            => :END_SNAP_ID,
                                    basic_filter        => null,
                                    object_filter       => null,
                                    ranking_measure1    => 'elapsed_time',
                                    ranking_measure2    => null,
                                    ranking_measure3    => null,
                                    result_percentage   => null,
                                    result_limit        => 1000,
                                    attribute_list      => 'ALL',
                                    recursive_sql       => null,
                                    dbid                => :DBID)
                                    )) ;                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[Tuning task SQL AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off
                                select
                                    q'[
                                        variable sqlset_name    varchar2(60)
                                        variable task_name      varchar2(60)
                                        variable begin_snap     number
                                        variable end_snap       number
                                        variable dbid           number
                                        variable sqlset_limit   number
                                        variable time_limit     number
                                        exec :sqlset_name       := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :task_name         := 'adhoc_sts_]' || :START_SNAP_ID|| '_' || :END_SNAP_ID || q'[';
                                        exec :begin_snap        := ]' || :START_SNAP_ID || q'[;
                                        exec :end_snap          := ]' || :END_SNAP_ID || q'[;
                                        exec :dbid              := ]' || :DBID          || q'[;
                                        exec :sqlset_limit      := 1000;
                                        exec :time_limit        := 3600;
                                        declare
                                          l_cursor  dbms_sqltune.sqlset_cursor;
                                          l_sql_tune_task_id  varchar2(100);
                                        begin
                                            begin dbms_sqltune.drop_tuning_task (task_name => :task_name);exception when others then null;end;
                                            begin dbms_sqltune.drop_sqlset(sqlset_name => :sqlset_name);exception when others then null; end;
                                            dbms_sqltune.create_sqlset(sqlset_name => :sqlset_name, description  => 'AWR snapshots workload');
                                            open l_cursor for select value(p) from table (dbms_sqltune.select_workload_repository (begin_snap => :begin_snap,end_snap => :end_snap,basic_filter => null,object_filter => null,ranking_measure1 => null,ranking_measure2 => null,ranking_measure3 => null,result_percentage => null,result_limit => :sqlset_limit,dbid => :dbid)) p;
                                            dbms_sqltune.load_sqlset (sqlset_name => :sqlset_name, populate_cursor => l_cursor);
                                            l_sql_tune_task_id := dbms_sqltune.create_tuning_task (sqlset_name => :sqlset_name,scope => dbms_sqltune.scope_comprehensive,time_limit => :time_limit, --secondstask_name => :task_name,description => 'Tuning task for a SQL tuning set  '|| :sqlset_name);
                                            dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
                                            dbms_sqltune.execute_tuning_task(task_name => :task_name);
                                        end;
                                        /
                                        set long 100000 pagesize 1000 linesize 200
                                        select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;
                                    ]' sql_tuning_advisor
                                from dual
                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_report_html(:DBID,:INSTANCE_NUMBER,:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                    ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_report_html(:DBID,:INSTANCE_NUMBER,to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM view]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                select dbms_advisor.get_task_report('ADDM:'||:DBID||'_'||:INSTANCE_NUMBER||'_'||:END_SNAP_ID,'TEXT','ALL','ALL','SYS') as report  FROM    dual;                                                    set termout on heading on feedback off
                                spool off
                                set termout on heading on feedback off
                                prompt &filename
                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM run]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 1000000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM',task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'INSTANCE',         value => :INSTANCE_NUMBER);
                                exec dbms_advisor.execute_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report FROM    dual;
                             ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'awr_report_html' awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ASH All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;


                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'ash_report_html'    awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                    select 'addm_report_text'  awr_report from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_report_html' awr_report from dual union all
                                                select 'ash_report_html'            from dual union all
                                                select 'addm_report_text'    from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                prompt Running....
                                --AWR
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.awr_global_report_html(:DBID,'',:START_SNAP_ID,:END_SNAP_ID));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                --ASH
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||:DB_NAME||'.'||:INSTANCE_NAME||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.html' filename from dual;
                                spool &filename
                                select output from table(dbms_workload_repository.ash_global_report_html(:DBID,'',to_date(:START_SNAP_DATE,'yyyy-mm-dd hh24:mi:ss'),to_date(:END_SNAP_DATE,'yyyy-mm-dd_hh24.mi.ss')));
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                -ADDM
                                set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                column filename new_value filename
                                select :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||:DB_NAME||'.'||'global'||'.'||:START_SNAP_DATE||'--'||:END_SNAP_DATE||'.'||:START_SNAP_ID||'-'||:END_SNAP_ID||'.'||'txt' filename from dual;
                                exec dbms_advisor.delete_task(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                exec dbms_advisor.create_task(advisor_name => 'ADDM', task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',task_desc => 'ADDM advisor for snapshots '||:START_SNAP_ID||' to '||:END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'START_SNAPSHOT',   value => :START_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'END_SNAPSHOT',     value => :END_SNAP_ID);
                                exec dbms_advisor.set_task_parameter(task_name => 'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT',parameter => 'DB_ID',            value => :DBID);
                                exec dbms_advisor.execute_task(task_name =>  'ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT');
                                spool &filename
                                select dbms_advisor.get_task_report('ADDM_'||:START_SNAP_ID||'_'||:END_SNAP_ID||'_AWR_SNAPSHOT','TEXT','ALL') as report from dual;
                                spool off
                                set termout on heading on feedback off
                                prompt &filename

                                prompt All Reports Completed!

                        ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
			<display id="" type="" style="Script" enable="true">
				<name><![CDATA[ADDM + ASH + AWR RAC All]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[]]></drillclass>
				<CustomValues>
				</CustomValues>
				<query>
					<sql><![CDATA[
                                set echo off feedback off linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout on
                                --define variables
                                col create_sql_file new_value create_sql_file
                                select  :REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'create_reports.sql' create_sql_file from dual;

                                var date_format      varchar2(40)
                                exec :date_format := 'yyyy-mm-dd_hh24.mi.ss'


                                -- create sql file
                                spool "&CREATE_SQL_FILE"
                                prompt set echo off feedback on linesize 4000 long 100000 trimspool on pagesize 0 heading off time off timing off serveroutput on verify off termout off
                                with
                                    report_type as (
                                                select 'awr_global_report_html' awr_report from dual union all
                                                select 'ash_global_report_html'            from dual union all
                                                select 'addm_global_report_text'           from dual
                                                    ),
                                    snaps as
                                                (select
                                                    di.db_name  dbname
                                                    ,di.instance_name
                                                    ,s.snap_id
                                                    ,snap_id_prev
                                                    ,s.dbid
                                                    ,di.instance_number
                                                    ,to_char(s.begin_interval_time,:date_format) begin_interval_time
                                                    ,to_char(s.end_interval_time,:date_format)   end_interval_time
                                                    ,min(to_char(s.begin_interval_time,:date_format)) over (partition by rt.awr_report) min_begin_interval_time
                                                    ,max(to_char(s.end_interval_time,:date_format))   over (partition by rt.awr_report) max_end_interval_time
                                                    ,max(snap_id) over (partition by rt.awr_report)     max_snap_id
                                                    ,min(snap_id_prev) over(partition by rt.awr_report) min_snap_id
                                                    ,rt.awr_report
                                                from (  select dhs.*,lag(snap_id) over (order by snap_id) as snap_id_prev
                                                        from dba_hist_snapshot dhs
                                                        where instance_number = :INSTANCE_NUMBER
                                                            and cast(dhs.begin_interval_time as date) <= to_date(:END_SNAP_DATE,:date_format)
                                                            and cast(dhs.end_interval_time as date)   >= to_date(:START_SNAP_DATE,:date_format)
                                                            and dhs.snap_id between :START_SNAP_ID and :END_SNAP_ID
                                                      ) s
                                                      ,dba_hist_database_instance di, report_type rt
                                                where di.dbid                 = s.dbid
                                                    and di.instance_number    = s.instance_number
                                                    and di.startup_time       = s.startup_time
                                                    and snap_id_prev is not null
                                                )
                                select distinct
                                    case awr_report
                                        when 'awr_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_text('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_report_html('||dbid||','||instance_number||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_text('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'awr_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'awr_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.awr_global_report_html('||dbid||','||''''''||','||snap_id_prev||','||snap_id||'));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_report_text('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                            chr(10) || 'select output from table(dbms_workload_repository.ash_report_html('||dbid||','||instance_number||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                            chr(10) || 'spool off'
                                        when 'ash_global_report_text' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_text('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'ash_global_report_html' then
                                            'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'ash_report.'||dbname||'.'||'global'||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'html' ||
                                                chr(10) || 'select output from table(dbms_workload_repository.ash_global_report_html('||dbid||','||''''''||','||'to_date('''||begin_interval_time||''','''||:date_format||'''),'||'to_date('''||end_interval_time||''','''||:date_format||''')));' ||
                                                chr(10) || 'spool off'
                                        when 'addm_report_text' then
                                            'exec dbms_advisor.delete_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'exec dbms_advisor.create_task(advisor_name => ''ADDM'',task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',task_desc => '''||'ADDM advisor for snapshots '||snap_id_prev||' to '||snap_id||''');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''START_SNAPSHOT'',   value => '||snap_id_prev||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''END_SNAPSHOT'',     value => '||snap_id||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''DB_ID'',            value => '||dbid||');' ||
                                            chr(10) || 'exec dbms_advisor.set_task_parameter(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',parameter => ''INSTANCE'',         value => '||instance_number||');' ||
                                            chr(10) || 'exec dbms_advisor.execute_task(task_name => '''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''');' ||
                                            chr(10) || 'spool '||:REPORTS_DEST_DIR||case when instr(:REPORTS_DEST_DIR,'\') > 0 then '\' else '/' end||'addm_report.'||dbname||'.'||instance_name||'.'||begin_interval_time||'--'||end_interval_time||'.'||snap_id_prev||'-'||snap_id||'.'||'txt' ||
                                            chr(10) || 'select dbms_advisor.get_task_report('''||'ADDM_'||snap_id_prev||'_'||snap_id||'_AWR_SNAPSHOT'||''',''TEXT'',''ALL'') as report FROM    dual;' ||
                                            chr(10) || 'spool off'
                                    end  report
                                from (select dbname,instance_name,snap_id     ,snap_id_prev,begin_interval_time    ,end_interval_time    ,dbid,instance_number,awr_report from snaps
                                        union all
                                      select distinct dbname,instance_name,max_snap_id,min_snap_id  ,min_begin_interval_time,max_end_interval_time,dbid,instance_number,awr_report from snaps)
                                order by report
                                ;


                                spool off

                                -- execute sql file
                                @&CREATE_SQL_FILE
                                set termout on

                                prompt
                                prompt
                                prompt
                                prompt All Reports Completed!

                                                ]]></sql>
					<binds>
						<bind id="DB_NAME">
							<prompt><![CDATA[DB_NAME]]></prompt>
							<tooltip><![CDATA[DB_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NAME">
							<prompt><![CDATA[INSTANCE_NAME]]></prompt>
							<tooltip><![CDATA[INSTANCE_NAME]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_DATE">
							<prompt><![CDATA[START_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[START_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_DATE">
							<prompt><![CDATA[END_SNAP_DATE]]></prompt>
							<tooltip><![CDATA[END_SNAP_DATE]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="START_SNAP_ID">
							<prompt><![CDATA[START_SNAP_ID]]></prompt>
							<tooltip><![CDATA[START_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="END_SNAP_ID">
							<prompt><![CDATA[END_SNAP_ID]]></prompt>
							<tooltip><![CDATA[END_SNAP_ID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="DBID">
							<prompt><![CDATA[DBID]]></prompt>
							<tooltip><![CDATA[DBID]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
						<bind id="INSTANCE_NUMBER">
							<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
							<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
							<value><![CDATA[NULL_VALUE]]></value>
							<bracket><![CDATA[null]]></bracket>
						</bind>
					</binds>
				</query>
			</display>
		</display>
	</display>
	<display id="9d8d6974-0183-1000-8005-c0a83801a02f" type="" style="Chart" enable="true">
		<name><![CDATA[Masked-Devops Session History]]></name>
		<description><![CDATA[Active session history report, instance workload and sessions details.
]]></description>
		<tooltip><![CDATA[Active session history report, database workload chart]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<Y1AXIS_TITLE_TEXT><![CDATA[Active Sessions]]></Y1AXIS_TITLE_TEXT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y2AXIS_SCALE_MAXIMUM>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND><![CDATA[true]]></LEGEND>
			<SUBTITLE_TEXT><![CDATA[]]></SUBTITLE_TEXT>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[180.0]]></Y1AXIS_SCALE_MAXIMUM>
			<Y1AXIS_SCALE_INCREMENT_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_INCREMENT_AUTOMATIC>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<STYLE><![CDATA[Regatta]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<XAXIS_SCALE_MAXIMUM><![CDATA[70.0]]></XAXIS_SCALE_MAXIMUM>
			<TITLE_TEXT><![CDATA[]]></TITLE_TEXT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<XAXIS_TITLE_TEXT><![CDATA[Time]]></XAXIS_TITLE_TEXT>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<PLOT_DATATIPS_CUMULATIVE_VALUE><![CDATA[false]]></PLOT_DATATIPS_CUMULATIVE_VALUE>
			<XAXIS_TICK_LABEL_AUTO_ROTATE><![CDATA[true]]></XAXIS_TICK_LABEL_AUTO_ROTATE>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[1.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<SUBTITLE><![CDATA[false]]></SUBTITLE>
			<GRADIENT><![CDATA[true]]></GRADIENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<FOOTNOTE><![CDATA[false]]></FOOTNOTE>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<PLOT_DATALABELS><![CDATA[false]]></PLOT_DATALABELS>
			<XAXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></XAXIS_LOGARITHMIC_BASE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<GRID><![CDATA[true]]></GRID>
			<XAXIS_SCALE_INCREMENT><![CDATA[10.0]]></XAXIS_SCALE_INCREMENT>
			<Y1AXIS_SCALE_MINIMUM_AUTOMATIC><![CDATA[false]]></Y1AXIS_SCALE_MINIMUM_AUTOMATIC>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<XAXIS_TITLE><![CDATA[true]]></XAXIS_TITLE>
			<THREED><![CDATA[false]]></THREED>
			<FOOTNOTE_TEXT><![CDATA[]]></FOOTNOTE_TEXT>
			<TITLE><![CDATA[false]]></TITLE>
			<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration 
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
-- 
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
-- 
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash as    (select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p, snaps where p.sample_source=10 and snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id     ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select cast(start_date as timestamp) start_date, cast(end_date as timestamp) end_date, sample_source from parms) p        where p.sample_source=1  and sample_time >= start_date and sample_time <= end_date )
    ,hist as (  select
                     sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 sample_time_ft
                    ,case
                        when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                        when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                        when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                        when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                        when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                        when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                        when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                        when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                        when lower(parms.dim) = 'sql_id'                then ash.sql_id
                        when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                        when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                        when lower(parms.dim) = 'module'                then ash.module
                        when lower(parms.dim) = 'program'               then ash.program
                        when lower(parms.dim) = 'action'                then ash.action
                        when lower(parms.dim) = 'machine'               then ash.machine
                        when lower(parms.dim) = 'event'                 then ash.event
                        when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                        else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    end dim
                from ash cross join parms
                where 1=1
                    ------- additional filters
                    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
                    and ash.con_id          = nvl(parms.con_id, ash.con_id)
                    and ash.session_id      = nvl(parms.session_id, ash.session_id)
                    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
                    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
                    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
                    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
                    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
                    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
                    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
                    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
                    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)

        )
select /*+ NO_PARALLEL */
     to_char(slots.slot,'yyyy-mm-dd hh24:mi:ss') slot
    ,hist.dim
    ,count(hist.dim)*sample_source/inter active_sessions
from slots,hist,parms
where slots.slot = hist.sample_time_ft(+)
group by slots.slot, hist.dim,inter,sample_source
order by slots.slot,hist.dim]]></sql>
			<binds>
				<bind id="p_start_date">
					<prompt><![CDATA[start_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate-1 in that format]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_end_date">
					<prompt><![CDATA[end_date]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi   Default is sysdate in that format]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_interval">
					<prompt><![CDATA[interval in seconds]]></prompt>
					<tooltip><![CDATA[time slot in seconds, histogram width, in seconds, default 600]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_dim">
					<prompt><![CDATA[dimension]]></prompt>
					<tooltip><![CDATA[instance_number | con_id | user_id | session_sid | xid | sql_exec_id | sql_exec_id_plan | sql_exec_id_plan_oper | sql_id | current_obj# | module | program | action | machine | event | wait_class   Default wait_class]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[INST_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.inst_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_CON_ID">
					<prompt><![CDATA[CON_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.con_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SID">
					<prompt><![CDATA[SESSION_SID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sid]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_SERIAL#">
					<prompt><![CDATA[SESSION_SERIAL#]]></prompt>
					<tooltip><![CDATA[V$SESSION.serial#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.sql_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SESSION_TYPE">
					<prompt><![CDATA[SESSION_TYPE]]></prompt>
					<tooltip><![CDATA[FOREGROUND/BACKGROUND  default=both]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_USER_ID">
					<prompt><![CDATA[USER_ID]]></prompt>
					<tooltip><![CDATA[V$SESSION.user#]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MODULE">
					<prompt><![CDATA[MODULE]]></prompt>
					<tooltip><![CDATA[V$SESSION.module]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PROGRAM">
					<prompt><![CDATA[PROGRAM]]></prompt>
					<tooltip><![CDATA[V$SESSION.program]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_MACHINE">
					<prompt><![CDATA[MACHINE]]></prompt>
					<tooltip><![CDATA[V$SESSION.machine]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_WAIT_CLASS">
					<prompt><![CDATA[WAIT_CLASS]]></prompt>
					<tooltip><![CDATA[Administrative/Application/Cluster/Commit/Concurrency ...]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_PLSQL_ENTRY_OBJECT_ID">
					<prompt><![CDATA[PLSQL_ENTRY_OBJECT_ID]]></prompt>
					<tooltip><![CDATA[DBA_OBJECTS.object_id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_DBA_HIST_ONLY">
					<prompt><![CDATA[DBA_HIST_ONLY]]></prompt>
					<tooltip><![CDATA[yes/no  null=no, yes=only data from dba_hist_active_sess_history]]></tooltip>
					<value><![CDATA[yes]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Report Parms]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[List report parameters plus useful info about the instance and the slot selected.]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as (select /*+ materialize NO_PARALLEL */
                     ash.*
                    ,parms.inter
                    ,count(*)                       over ()  cnt_tot
                    ,count(distinct ash.session_id) over ()  cnt_sid
                    ,count(distinct ash.sql_id)     over ()  cnt_sql_id
                    ,count(distinct xid)            over ()  cnt_xid
                    ,count(distinct sql_exec_id)    over ()  cnt_exec_id
                    ,count(distinct in_parse)       over ()  cnt_in_parse
                    ,count(distinct in_hard_parse)  over ()  cnt_in_hard_parse
                    ,count(distinct in_sql_execution)      over ()  cnt_in_sql_execution
                    ,count(distinct in_plsql_execution)    over ()  cnt_in_plsql_execution
                    ,count(distinct ash.program)    over ()  cnt_program
                    ,count(distinct ash.module)     over ()  cnt_module
                    ,count(distinct ash.machine)    over ()  cnt_machine
                from ( select ash.snap_id ,ash.dbid ,ash.con_id,ash.instance_number ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                       select 0           ,null     ,con_id    ,inst_id             ,sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end
                     ) ash ,parms)
select 'start_date' parameter   , to_char(start_date,'yyyy-mm-dd hh24:mi')     value                          ,'----','sample source              ' info     ,case when sample_source = 1 then 'v$active_session_history' else 'dba_hist_active_sess_history' end info_value from parms  union all
select 'end_date                ',to_char(end_date,'yyyy-mm-dd hh24:mi')                                      ,'----','cpu count                  '          ,(select sp.value from v$parameter sp  where name = 'cpu_count')                                                from parms  union all
select 'dim                     ',dim                                                                         ,'----','memory_target              '          ,(select sp.value from v$parameter sp  where name = 'memory_target')                                            from parms  union all
select 'inter                   ',to_char(parms.inter)                                                        ,'----','memory_max_target          '          ,(select sp.value from v$parameter sp  where name = 'memory_max_target')                                        from parms  union all
select 'start slot              ',to_char(cast(:SLOT as date),'yyyy-mm-dd hh24:mi:ss')                        ,'----','sga_target                 '          ,(select sp.value from v$parameter sp  where name = 'sga_target')                                               from parms  union all
select 'end   slot              ',to_char(cast(:SLOT as date)+ parms.inter/24/60/60 ,'yyyy-mm-dd hh24:mi:ss') ,'----','sga_max_target             '          ,(select sp.value from v$parameter sp  where name = 'sga_max_target')                                           from parms  union all
select 'instance_number         ',to_char(parms.instance_number)                                              ,'----','pga_aggregate_target       '          ,(select sp.value from v$parameter sp  where name = 'pga_aggregate_target')                                     from parms  union all
select 'con_id                  ',parms.con_id                                                                ,'----','slot samples               '          ,(select to_char(cnt_tot)        from ash where rownum < 2)                                                     from parms union all
select 'session_id              ',to_char(parms.session_id)                                                   ,'----','slot sessions              '          ,(select to_char(cnt_sid)        from ash where rownum < 2)                                                     from parms union all
select 'session_serial#         ',to_char(parms.session_serial#)                                              ,'----','slot distinct sql count    '          ,(select to_char(cnt_sql_id)     from ash where rownum < 2)                                                     from parms union all
select 'sql_id                  ',parms.sql_id                                                                ,'----','slot transactions          '          ,(select to_char(cnt_xid)        from ash where rownum < 2)                                                     from parms union all
select 'session_type            ',parms.session_type                                                          ,'----','slot exec_id               '          ,(select to_char(cnt_exec_id)    from ash where rownum < 2)                                                     from parms union all
select 'user_id                 ',to_char(parms.user_id)                                                      ,'----','slot in_parse              '          ,(select to_char(cnt_in_parse)               from ash where rownum < 2)                                         from parms union all
select 'module                  ',parms.module                                                                ,'----','slot in_hard_parse         '          ,(select to_char(cnt_in_hard_parse)          from ash where rownum < 2)                                         from parms union all
select 'program                 ',parms.program                                                               ,'----','slot in_sql_execution      '          ,(select to_char(cnt_in_sql_execution)       from ash where rownum < 2)                                         from parms union all
select 'machine                 ',parms.machine                                                               ,'----','slot in_plsql_execution    '          ,(select to_char(cnt_in_plsql_execution) from ash where rownum < 2)                                             from parms union all
select 'wait_class              ',parms.wait_class                                                            ,'----','slot program               '          ,(select to_char(cnt_program) from ash where rownum < 2)                                                        from parms union all
select 'plsql_entry_object_id   ',:P_PLSQL_ENTRY_OBJECT_ID                                                    ,'----','slot module                '          ,(select to_char(cnt_module)  from ash where rownum < 2)                                                        from parms union all
select 'dba_hist_only           ',:P_DBA_HIST_ONLY                                                            ,'----','slot machine               '          ,(select to_char(cnt_machine) from ash where rownum < 2)                                                        from parms union all
select '----','----','----','----','----' from dual]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[Counts of the samples grouped by  slot dim event]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000)     total_wait_time_ms 
	,round(avg(ash.time_waited)  over (partition by ash.instance_number,ash.con_id,ash.event)/1000,2)   avg_wait_time_ms 
	,count(ash.sample_id)        over (partition by ash.instance_number,ash.con_id,ash.event)           cnt_event
	,count(*)                    over (partition by ash.instance_number,ash.con_id)                     cnt_ash_con
	,count(*)                    over ()                                                                cnt_ash_inst
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*) over ()=0 then 0 else trunc(count(ash.sample_id) over (partition by ash.instance_number,ash.con_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
	cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by cnt_event desc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DIM">
						<prompt><![CDATA[DIM]]></prompt>
						<tooltip><![CDATA[DIM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions all]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */
    --ash.sample_id
    to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')     sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    ,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.plsql_entry_object_id                            --Object ID of the top-most PL/SQL subprogram on the stack (or NULL if there is no PL/SQL subprogram on the stack)
    ,'SQLDEV:LINK:'||peoi.owner||':'||peoi.object_type||':'||peoi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' top_plsql
    --,ash.plsql_entry_subprogram_id
    ,preoi.procedure_name top_plsql_proc
    --,ash.plsql_object_id                                  --Object ID of the currently executing PL/SQL subprogram (or NULL if executing SQL)
    ,'SQLDEV:LINK:'||poi.owner||':'||poi.object_type||':'||poi.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' plsql
    --,ash.plsql_subprogram_id
    ,proi.procedure_name plsql_proc
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    ,ash.in_parse
    ,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,to_char(ash.pga_allocated/1024/1024,'FM999999999.90') pga_allocated_mb
    ,case when ash.temp_space_allocated != 0 then to_char(ash.temp_space_allocated/1024/1024,'FM999999999.90') else to_char(ash.temp_space_allocated) end temp_space_allocated_mb
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
        cross join  parms
        left  outer join cdb_users u            on ash.user_id = u.user_id and ash.con_id = u.con_id
        left  outer join gv$event_name e        on ash.instance_number = e.inst_id and ash.event_id = e.event_id
        left  outer join cdb_objects o          on ash.current_obj# = o.object_id and ash.con_id = o.con_id
        left  outer join cdb_objects peoi       on ash.plsql_entry_object_id = peoi.object_id and ash.con_id = peoi.con_id
        left  outer join cdb_procedures preoi   on ash.plsql_entry_object_id = preoi.object_id and ash.plsql_entry_subprogram_id = preoi.subprogram_id and ash.con_id = preoi.con_id
        left  outer join cdb_objects poi        on ash.plsql_object_id = poi.object_id and ash.con_id = poi.con_id
        left  outer join cdb_procedures proi    on ash.plsql_object_id = proi.object_id and ash.plsql_subprogram_id = proi.subprogram_id and ash.con_id = proi.con_id
        left  outer join gv$datafile f          on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
    ------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id      = nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by sample_time asc]]></sql>
				<binds>
					<bind id="p_start_date">
						<prompt><![CDATA[p_start_date]]></prompt>
						<tooltip><![CDATA[p_start_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_end_date">
						<prompt><![CDATA[p_end_date]]></prompt>
						<tooltip><![CDATA[p_end_date]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_interval">
						<prompt><![CDATA[p_interval]]></prompt>
						<tooltip><![CDATA[p_interval]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="p_dim">
						<prompt><![CDATA[p_dim]]></prompt>
						<tooltip><![CDATA[p_dim]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_CON_ID">
						<prompt><![CDATA[P_CON_ID]]></prompt>
						<tooltip><![CDATA[P_CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SID">
						<prompt><![CDATA[P_SESSION_SID]]></prompt>
						<tooltip><![CDATA[P_SESSION_SID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_SERIAL#">
						<prompt><![CDATA[P_SESSION_SERIAL#]]></prompt>
						<tooltip><![CDATA[P_SESSION_SERIAL#]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SQL_ID">
						<prompt><![CDATA[P_SQL_ID]]></prompt>
						<tooltip><![CDATA[P_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_SESSION_TYPE">
						<prompt><![CDATA[P_SESSION_TYPE]]></prompt>
						<tooltip><![CDATA[P_SESSION_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_USER_ID">
						<prompt><![CDATA[P_USER_ID]]></prompt>
						<tooltip><![CDATA[P_USER_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MODULE">
						<prompt><![CDATA[P_MODULE]]></prompt>
						<tooltip><![CDATA[P_MODULE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PROGRAM">
						<prompt><![CDATA[P_PROGRAM]]></prompt>
						<tooltip><![CDATA[P_PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_MACHINE">
						<prompt><![CDATA[P_MACHINE]]></prompt>
						<tooltip><![CDATA[P_MACHINE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_WAIT_CLASS">
						<prompt><![CDATA[P_WAIT_CLASS]]></prompt>
						<tooltip><![CDATA[P_WAIT_CLASS]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_PLSQL_ENTRY_OBJECT_ID">
						<prompt><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></prompt>
						<tooltip><![CDATA[P_PLSQL_ENTRY_OBJECT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_DBA_HIST_ONLY">
						<prompt><![CDATA[P_DBA_HIST_ONLY]]></prompt>
						<tooltip><![CDATA[P_DBA_HIST_ONLY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SLOT">
						<prompt><![CDATA[SLOT]]></prompt>
						<tooltip><![CDATA[SLOT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end)
select /*+ NO_PARALLEL */
	 :DIM dim
    --ash.sample_id
    ,to_char(ash.sample_time,'yyyy-mm-dd hh24:mi:ss') sample_time
    ,case when parms.sample_source = 1 then 'gv$' when parms.sample_source = 10 then 'dba_hist' else null end source
    --,ash.is_awr_sample
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.xid
    ,ash.sql_exec_id
    ,to_char(ash.sql_exec_start,'yyyy-mm-dd hh24:mi:ss')	 sql_exec_start
    ,ash.session_type
    --,ash.flags
    --,u.username
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
    --,ash.user_id
    --,ash.is_sqlid_current
    --,ash.sql_child_number
    ,ash.wait_class
    ,ash.event
    --,ash.sql_opcode
    ,ash.sql_opname
    --,ash.force_matching_signature
    ,ash.top_level_sql_id
    --,ash.top_level_sql_opcode
    ,ash.sql_plan_line_id
    ,ash.sql_plan_operation
    ,ash.sql_plan_options
    ,ash.plsql_entry_object_id
    ,ash.plsql_entry_subprogram_id
    ,ash.plsql_object_id
    ,ash.plsql_subprogram_id
    --,ash.qc_instance_id
    ,ash.qc_session_id
    ,ash.qc_session_serial#
    --,ash.px_flags
    --,ash.event
    --,ash.event_id
    ,ash.seq#
    ,ash.p1text
    ,ash.p1
    ,ash.p2text
    ,ash.p2
    ,ash.p3text
    ,ash.p3
    --,ash.wait_class
    --,ash.wait_class_id
    ,ash.wait_time
    ,ash.session_state
    ,ash.time_waited
    ,ash.blocking_session_status
    ,ash.blocking_session
    ,ash.blocking_session_serial#
    ,ash.blocking_inst_id
    ,ash.blocking_hangchain_info
    ,o.owner||'.'||o.object_name||'  '||o.subobject_name||'('||o.object_type||')' object
    ,'SQLDEV:LINK:'||owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
    ,'SQLDEV:LINK{#;#}'||USER||'#;#DATAFILE#;#'||f.name||'#;#oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' as datafile
    --,ash.current_obj#
    --,ash.current_file#
    ,ash.current_block#
    ,ash.current_row#
    --,ash.top_level_call#
    ,ash.top_level_call_name
    ,ash.consumer_group_id
    ,ash.remote_instance#
    --,ash.time_model
    --,ash.in_connection_mgmt
    --,ash.in_parse
    --,ash.in_hard_parse
    --,ash.in_sql_execution
    --,ash.in_plsql_execution
    --,ash.in_plsql_rpc
    --,ash.in_plsql_compilation
    --,ash.in_java_execution
    --,ash.in_bind
    --,ash.in_cursor_close
    --,ash.in_sequence_load
    --,ash.capture_overhead
    --,ash.replay_overhead
    --,ash.is_captured
    --,ash.is_replayed
    --,ash.service_hash
    ,ash.program
    ,ash.module
    ,ash.action
    ,ash.client_id
    ,ash.machine
    ,ash.port
    ,ash.ecid
    --,ash.dbreplay_file_id
    --,ash.dbreplay_call_counter
    --,ash.tm_delta_time
    --,ash.tm_delta_cpu_time
    --,ash.tm_delta_db_time
    --,ash.delta_time
    --,ash.delta_read_io_requests
    --,ash.delta_write_io_requests
    --,ash.delta_read_io_bytes
    --,ash.delta_write_io_bytes
    --,ash.delta_interconnect_io_bytes
    ,ash.pga_allocated
    ,ash.temp_space_allocated
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    cross join	parms
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
    left  outer join gv$event_name e	on ash.instance_number = e.inst_id and ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
    left  outer join gv$datafile f		on ash.instance_number = f.inst_id and ash.current_file# = f.file#
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by sample_time asc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Sessions by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
	,ash.event
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,ash.session_id         sid
    ,ash.session_serial#    serial#
    ,'SQLDEV:LINK:'||USER||':USER:'||u.username||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' username
	,ash.machine
	,ash.program
	,ash.module
	,count(distinct sql_exec_id)  over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_exec_id
	,count(ash.session_id)        over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)   cnt_sid
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(ash.session_id) over (partition by ash.instance_number,ash.con_id,ash.session_id,ash.session_serial#,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_users u		on ash.user_id = u.user_id and ash.con_id = u.con_id
	cross join parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)         cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                            cnt_ash_con
   	,count(*)                       over ()                                                                                       cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top SQL by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,ash.event
    ,ash.sql_id
    ,ash.sql_plan_hash_value
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)           over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) parallel_samples
    ,count(distinct sql_exec_id)    over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) executions
	,round(sum(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)     over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/1000,2) avg_wait_time_ms 
    ,count(ash.sql_id)              over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event) cnt_sql_id
    ,count(case when ash.in_parse = 'Y'           then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_parse
    ,count(case when ash.in_hard_parse = 'Y'      then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_hparse
    ,count(case when ash.in_sql_execution = 'Y'   then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_sql_exec
    ,count(case when ash.in_plsql_execution = 'Y' then 1 else null end) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value)  in_plsql_exec
	,count(*)                       over (partition by ash.instance_number,ash.con_id)                                    cnt_ash_con
   	,count(*)                       over ()                                                                               cnt_ash_inst
    ,case	 when count(*) over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case	 when count(*) over ()=0 then 0 else trunc(count(ash.sql_id) over (partition by ash.instance_number,ash.con_id,ash.sql_id,ash.sql_plan_hash_value,ash.event)/count(*) over ()*100) end load_pct_inst
    ,nvl((select to_char(substr(sql_fulltext,1,1000)) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select to_char(substr(sql_text,1,1000)) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash cross join	parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
    and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM dim
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id)      cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,subobject_name
	,object_type
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000)          total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event)/1000,2)        avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)  cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                        cnt_ash_con
	,count(*)               over ()                                                                   cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event)/count(*) over ()*100) end load_pct_inst
from ash
    cross join	parms
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Objects by dim/event/plan]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM dim
    ,ash.event
    ,'SQLDEV:LINK:'||USER||':USER:'||o.owner||':oracle.dbtools.raptor.dba.navigator.Drill.DBADrillLink' owner
	,'SQLDEV:LINK:'||o.owner||':'||o.object_type||':'||o.object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' object_name
    ,o.subobject_name
    ,o.object_type
    ,ash.current_obj#
    ,sql_opname
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_plan_operation	
    ,sql_plan_options	
    ,ash.instance_number    inst
    ,ash.con_id             con
	,round(sum(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000)   total_wait_time_ms 
	,round(avg(ash.time_waited)         over (partition by ash.current_obj#,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/1000,2) avg_wait_time_ms 
	,count(o.object_id)     over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)    cnt_object
	,count(*)               over (partition by ash.instance_number,ash.con_id)                  cnt_ash_con
	,count(*)               over ()                                                             cnt_ash_inst
	,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
	,case  when count(*)    over ()=0 then 0 else trunc(count(o.object_id) over (partition by ash.instance_number,ash.con_id,o.object_id,ash.event,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top Plan Line by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
     ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/object by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_plan_line
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.current_obj#) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[Top plan line/event by dim]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[-- Author      : Masked DevOps
with
     parms as ( select nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi')) end_date,nvl(to_number(:p_interval),600) inter
                , :p_dim dim, :P_INST_ID instance_number, :P_CON_ID con_id ,:P_SESSION_SID session_id, :P_SESSION_SERIAL# session_serial#,:P_SQL_ID sql_id,:P_SESSION_TYPE session_type, to_number(:P_USER_ID) user_id,:P_MODULE module, :P_PROGRAM program
                , :P_MACHINE machine, :P_WAIT_CLASS wait_class, :P_PLSQL_ENTRY_OBJECT_ID plsql_entry_object_id, (case when nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) < sysdate-1 or lower(:P_DBA_HIST_ONLY) = 'yes' then 10  else 1 end) sample_source
                from dual)
    ,slots as ( select (start_date+(level-1)/24/60/60*inter) as slot from parms connect by (level-1) <= (end_date - start_date)*24*60*60/inter)
    ,snaps as ( select snap.dbid,snap.instance_number,snap.snap_id from dba_hist_snapshot snap cross join parms where not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date) and snap.instance_number = nvl(parms.instance_number, snap.instance_number))
    ,ash   as ( select ash.snap_id ,ash.dbid ,ash.instance_number ,ash.con_id, sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from dba_hist_active_sess_history ash,(select start_date, end_date, inter, sample_source from parms) p, snaps where snaps.dbid = ash.dbid and snaps.instance_number = ash.instance_number and snaps.snap_id = ash.snap_id and sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 10 then :SLOT else null end and sample_time >= start_date and sample_time <= end_date union all
                select 0           ,null     ,inst_id             ,con_id    , sample_id ,sample_time ,session_id ,session_serial# ,session_type ,flags ,user_id ,sql_id ,is_sqlid_current ,sql_child_number ,sql_opcode ,sql_opname ,force_matching_signature ,top_level_sql_id ,top_level_sql_opcode ,sql_plan_hash_value ,sql_plan_line_id ,sql_plan_operation ,sql_plan_options ,sql_exec_id ,sql_exec_start ,plsql_entry_object_id ,plsql_entry_subprogram_id ,plsql_object_id ,plsql_subprogram_id ,qc_instance_id ,qc_session_id ,qc_session_serial# ,px_flags ,event ,event_id ,seq# ,p1text ,p1 ,p2text ,p2 ,p3text ,p3 ,wait_class ,wait_class_id ,wait_time ,session_state ,time_waited ,blocking_session_status ,blocking_session ,blocking_session_serial# ,blocking_inst_id ,blocking_hangchain_info ,current_obj# ,current_file# ,current_block# ,current_row# ,top_level_call# ,top_level_call_name ,consumer_group_id ,xid ,remote_instance# ,time_model ,in_connection_mgmt ,in_parse ,in_hard_parse ,in_sql_execution ,in_plsql_execution ,in_plsql_rpc ,in_plsql_compilation ,in_java_execution ,in_bind ,in_cursor_close ,in_sequence_load ,capture_overhead ,replay_overhead ,is_captured ,is_replayed ,service_hash ,program ,module ,action ,client_id ,machine ,port ,ecid ,dbreplay_file_id ,dbreplay_call_counter ,tm_delta_time ,tm_delta_cpu_time ,tm_delta_db_time ,delta_time ,delta_read_io_requests ,delta_write_io_requests ,delta_read_io_bytes ,delta_write_io_bytes ,delta_interconnect_io_bytes ,pga_allocated ,temp_space_allocated  from gv$active_session_history    ash,(select start_date, end_date, inter, sample_source from parms) p        where                                                                                                           sample_time - mod((cast(sample_time as date) - start_date)*24*60*60,inter)/24/60/60 = case when p.sample_source = 1  then :SLOT else null end and sample_time >= start_date and sample_time <= end_date)
select /*+ NO_PARALLEL */ distinct
	 :DIM
    ,ash.event
    ,ash.sql_id
    ,sql_plan_hash_value	
    ,sql_plan_line_id	
    ,sql_opname
    ,sql_plan_operation	
    ,sql_plan_options
    ,ash.instance_number    inst
    ,ash.con_id             con
    ,count(qc_session_id)   over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) parallel_samples
    ,count(*)               over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_event
	,count(*)               over (partition by ash.instance_number,ash.con_id)                                      cnt_ash_con
	,count(*)               over ()                                                                                 cnt_ash_inst
    ,case  when count(*)    over (partition by ash.instance_number,ash.con_id)=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over (partition by ash.instance_number,ash.con_id)*100) end load_pct_con
    ,case  when count(*)    over ()=0 then 0 else trunc(count(*) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event)/count(*) over ()*100) end load_pct_inst
    ,count(distinct ash.current_obj#) over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) cnt_objects
    ,max('SQLDEV:LINK:'||owner||':'||object_type||':'||object_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink') over (partition by ash.instance_number,ash.con_id,ash.sql_id,sql_opname,sql_plan_hash_value,sql_plan_line_id,sql_plan_operation,sql_plan_options,ash.event) object
    ,'/*set pages 0 lines 250*/ select * from table(dbms_xplan.display_awr( '''||ash.sql_id||''','''||sql_plan_hash_value||''',null ,''advanced''));'  display_awr
    ,nvl((select dbms_lob.substr(sql_fulltext,1000) from gv$sqlstats sqlt where sqlt.sql_id = ash.sql_id and rownum < 2),(select dbms_lob.substr(sql_text,1000) from dba_hist_sqltext hs where hs.sql_id = ash.sql_id and rownum < 2)) sql_fulltext
from ash
    left  outer join v$event_name e		on ash.event_id = e.event_id
    left  outer join cdb_objects o      on ash.current_obj# = o.object_id and ash.con_id = o.con_id
	cross join		 parms
where 1=1
	------- additional filters
    and ash.instance_number = nvl(parms.instance_number, ash.instance_number)
    and ash.con_id          = nvl(parms.con_id, ash.con_id)
    and ash.session_id		= nvl(parms.session_id, ash.session_id)
    and ash.session_serial# = nvl(parms.session_serial#, ash.session_serial#)
    and ((parms.sql_id                  is not null and parms.sql_id                   = ash.sql_id                )  or  parms.sql_id                 is null)
    and ((parms.plsql_entry_object_id   is not null and parms.plsql_entry_object_id    = ash.plsql_entry_object_id )  or  parms.plsql_entry_object_id  is null)
    and ((parms.user_id                 is not null and parms.user_id                  = ash.user_id               )  or  parms.user_id                is null)
    and ((parms.session_type            is not null and parms.session_type             = ash.session_type          )  or  parms.session_type           is null)
    and ((parms.module                  is not null and parms.module                   = ash.module                )  or  parms.module                 is null)
    and ((parms.program                 is not null and parms.program                  = ash.program               )  or  parms.program                is null)
    and ((parms.machine                 is not null and parms.machine                  = ash.machine               )  or  parms.machine                is null)
    and ((parms.wait_class              is not null and parms.wait_class               = ash.wait_class            )  or  parms.wait_class             is null)
	and :DIM =	case
                    when lower(parms.dim) = 'instance_number'       then to_char(ash.instance_number)
                    when lower(parms.dim) = 'con_id'                then to_char(ash.con_id)
                    when lower(parms.dim) = 'user_id'               then to_char(ash.user_id)
                    when lower(parms.dim) = 'session_sid'           then ash.session_id||'.'||ash.session_serial#
                    when lower(parms.dim) = 'xid'                   then rawtohex(ash.xid)
                    when lower(parms.dim) = 'sql_exec_id'           then to_char(ash.sql_exec_id)
                    when lower(parms.dim) = 'sql_exec_id_plan'      then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)
                    when lower(parms.dim) = 'sql_exec_id_plan_oper' then to_char(ash.sql_exec_id)||'.'||to_char(ash.sql_plan_hash_value)||'.'||to_char(ash.sql_plan_line_id)||'.'||ash.sql_plan_operation||'.'||ash.sql_plan_options
                    when lower(parms.dim) = 'sql_id'                then ash.sql_id
                    when lower(parms.dim) = 'plsql_entry_object_id' then to_char(ash.plsql_entry_object_id)
                    when lower(parms.dim) = 'current_obj#'          then to_char(ash.current_obj#)
                    when lower(parms.dim) = 'module'                then ash.module
                    when lower(parms.dim) = 'program'               then ash.program
                    when lower(parms.dim) = 'action'                then ash.action
                    when lower(parms.dim) = 'machine'               then ash.machine
                    when lower(parms.dim) = 'event'                 then ash.event
                    when lower(parms.dim) = 'wait_class'            then case when session_state = 'ON CPU'  then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
                    else                                            case when session_state = 'ON CPU'   then session_state when session_state = 'WAITING' then ash.wait_class else 'WAIT' end
				end
order by load_pct_inst desc]]></sql>
			</query>
		</display>
		<display id="" type="" style="Table" enable="true">
			<name><![CDATA[ASH text]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
     parms as ( select 
                     nvl(to_number(:p_interval),600)                              inter
                    ,cast(:SLOT as date)                                          start_date_slot
                    ,cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 end_date_slot
                    ,sys_context('USERENV', 'DB_NAME')                            db_name
                    ,sys_context('USERENV', 'INSTANCE_NAME')                      instance_name
                    ,sys_context('USERENV', 'INSTANCE')                           instance_number
                    ,(select nvl(dbid,(select dbid from v$database)) from dba_hist_active_sess_history where sample_time between cast(:SLOT as date)  and cast(:SLOT as date)+nvl(to_number(:p_interval),600)/24/60/60 and rownum < 2) dbid
               from dual)
select '<!-- '|| 'ash_report'||'.'||db_name||'.'||instance_name||'.'||to_char(start_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'--'||to_char(end_date_slot,'yyyy-mm-dd_hh24.mi.ss')||'.'||'txt' ||' -->' output from parms
union all
select output from parms,table(dbms_workload_repository.ash_report_text(dbid,instance_number,start_date_slot,end_date_slot))]]></sql>
			</query>
		</display>
	</display>
	<display id="bf1da0e3-0183-1000-8023-c0a838012a96" type="" style="Table" enable="true">
		<name><![CDATA[Masked-Devops SQL History]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[SQL_ID history, response time, plans, tuning]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select
              nvl(to_date(:p_start_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate-23/24,'hh')) start_date
             ,nvl(to_date(:p_end_date,'yyyy-mm-dd hh24:mi'),trunc(sysdate,'mi'))         end_date
             ,nvl(:p_sql_id,'SQL_ID must be specified')                                  sql_id
             ,to_number(:P_CON_ID)                                                       con_id
             ,:P_REPORTS_DIR                                                             reports_dir
             ,:P_SQLT_DIR                                                                sqlt_dir
          from dual)
select /*+ NO_PARALLEL */
     instance_number                                                            inst
    ,s.con_id                                                                   con
    ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day')                     end_snap
    ,snap_id                                                                    snap
    ,con_name
    ,s.sql_id
    ,plan_hash_value
    ,count(distinct  plan_hash_value)      over (partition by s.sql_id )          plans    -- sql_id/plans total
    ,sql_profile
    ,to_char(round(elapsed_time_delta/1000000,3),'9999990.990')                 tot_time_sec
    ,executions_delta                                                           executions
    ,to_char(case when executions_delta > 0 then trunc(elapsed_time_delta       /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_time_sec
    --,to_char(case when executions_delta > 0 then lag(trunc(elapsed_time_delta   /1000000/executions_delta,4))   over (partition by s.sql_id order by begin_interval_time) else null end,'9999990.990')     avg_time_sec_prev
    ,to_char(case when executions_delta > 0 then round(cpu_time_delta           /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_cpu_sec
    ,to_char(case when executions_delta > 0 then round(iowait_delta             /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_iowait_sec
    ,to_char(case when executions_delta > 0 then round(apwait_delta             /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_application_sec
    ,to_char(case when executions_delta > 0 then round(ccwait_delta             /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_concurrency_sec
    ,to_char(case when executions_delta > 0 then round(clwait_delta             /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_cluster_sec
    ,to_char(case when executions_delta > 0 then round(plsexec_time_delta       /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_plsql_sec
    ,to_char(case when executions_delta > 0 then round(javexec_time_delta       /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_java_sec
    ,case when executions_delta > 0 then round(disk_reads_delta                 /executions_delta,3)    else 0 end   avg_disk_reads
    ,case when executions_delta > 0 then round(buffer_gets_delta                /executions_delta,3)    else 0 end   avg_buffer_gets
    ,case when executions_delta > 0 then round(rows_processed_delta             /executions_delta,3)    else 0 end   avg_rows_processed
    ,case when executions_delta > 0 then round(sorts_delta                      /executions_delta,3)    else 0 end   avg_sorts
    ,case when executions_delta > 0 then round(fetches_delta                    /executions_delta,3)    else 0 end   avg_fetches
    ,version_count                                                              cursors
    ,parsing_schema_name
    ,substr(sql_text,1,1000)                                                    sql_text
    ,utl_raw.cast_to_varchar2(bind_data)                                        bind_data
    ,module
    ,action
    ,dbid
    ,s.con_id
    ,con_dbid
    ,instance_number
    ,instance_number                                                            inst_id
    ,end_interval_time
    ,begin_interval_time
    ,parms.reports_dir
    ,parms.sqlt_dir
    ,parms.start_date                                                           p_start_date
    ,parms.end_date                                                             p_end_date
    ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day')                     end_interval_time_char
    ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss day')                   begin_interval_time_char
from (
        select s.snap_id,s.instance_number,s.con_id, c.name con_name, s.con_dbid, s.sql_id,null,s.plan_hash_value,                           s.sql_profile,begin_interval_time,end_interval_time, executions_delta,elapsed_time_delta,cpu_time_delta,iowait_delta,     apwait_delta,         ccwait_delta,         clwait_delta,     plsexec_time_delta,javexec_time_delta,disk_reads_delta,buffer_gets_delta,rows_processed_delta,s.sorts_delta,s.fetches_delta,s.parsing_schema_name,      t.sql_text  ,s.dbid,s.version_count,s.bind_data,module,action
        from dba_hist_sqlstat s
            cross join parms
            join dba_hist_snapshot snap on s.snap_id = snap.snap_id and s.dbid = snap.dbid and s.instance_number = snap.instance_number -- pk=snap_id dbid
                and s.sql_id =  case when parms.sql_id is not null then parms.sql_id else s.sql_id end
                and s.con_id =  case when parms.con_id is not null then parms.con_id else s.con_id end
                and not (snap.begin_interval_time > parms.end_date or snap.end_interval_time < parms.start_date)
            join dba_hist_sqltext t     on s.sql_id = t.sql_id and s.dbid = t.dbid and s.con_dbid = t.con_dbid
            join (select con_id,name from gv$containers) c on s.con_id = c.con_id
        union all
        select 0 snap_id,s.inst_id        ,s.con_id, c.name con_name, s.con_dbid,s.sql_id,s.last_active_child_address,s.plan_hash_value,null as sql_profile, s.last_active_time ,null,             executions,      elapsed_time,      cpu_time,      user_io_wait_time,application_wait_time,concurrency_wait_time,cluster_wait_time,plsql_exec_time,   java_exec_time,    disk_reads,      buffer_gets,      rows_processed,      sorts,        fetches,        null as parsing_schema_name,sql_fulltext,null,  s.version_count,null,null,null
        from gv$sqlstats s cross join parms
            join (select con_id,name from gv$containers) c on s.con_id = c.con_id
        where s.sql_id =  case when parms.sql_id is not null then parms.sql_id else s.sql_id end and s.con_id =  case when parms.con_id is not null then parms.con_id else s.con_id end
    ) s cross join parms
order by s.sql_id,s.begin_interval_time]]></sql>
			<binds>
				<bind id="p_start_date">
					<prompt><![CDATA[p_start_date]]></prompt>
					<tooltip><![CDATA[p_start_date]]></tooltip>
					<value><![CDATA[2022-09-25 14:00]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_end_date">
					<prompt><![CDATA[p_end_date]]></prompt>
					<tooltip><![CDATA[p_end_date]]></tooltip>
					<value><![CDATA[2022-09-25 23:59]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="p_sql_id">
					<prompt><![CDATA[p_sql_id]]></prompt>
					<tooltip><![CDATA[p_sql_id]]></tooltip>
					<value><![CDATA[c13sma6rkr27c]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_CON_ID">
					<prompt><![CDATA[P_CON_ID]]></prompt>
					<tooltip><![CDATA[Container id]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_REPORTS_DIR">
					<prompt><![CDATA[P_REPORTS_DIR]]></prompt>
					<tooltip><![CDATA[Path where the AWR ans ASH scripts will be created]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_SQLT_DIR">
					<prompt><![CDATA[P_SQLT_DIR]]></prompt>
					<tooltip><![CDATA[Path for the SQLT installation]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sql fulltext]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 'gv$sqlstats' dict_view, null dbid,sql_fulltext	   from gv$sqlstats where inst_id = :INSTANCE_NUMBER and sql_id = :SQL_ID and plan_hash_value = :PLAN_HASH_VALUE
union all
select 'dba_hist_sqltext' dict_view,dbid, sql_text	from dba_hist_sqltext where sql_id = :SQL_ID and rownum < 2]]></sql>
				<binds>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[chart hist avg_time]]></name>
			<description><![CDATA[History of the everage execution time per plan in the container]]></description>
			<tooltip><![CDATA[History of the everage execution time per plan in the container]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<Y1AXIS_TITLE_TEXT><![CDATA[Average time milliseconds]]></Y1AXIS_TITLE_TEXT>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y2AXIS_TITLE><![CDATA[true]]></Y2AXIS_TITLE>
				<Y1AXIS_BASE_LINE_VALUE><![CDATA[0.0]]></Y1AXIS_BASE_LINE_VALUE>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<DATA_MAP_COLUMNS><![CDATA[\]]></DATA_MAP_COLUMNS>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
				<Y2AXIS_TITLE_TEXT><![CDATA[Number of Executions]]></Y2AXIS_TITLE_TEXT>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<DATA_MAP_COLNAMES><![CDATA[\,"AVG_TIME_MILLISEC","AVG_TIME_SEC","END_SNAP_TIME","EXECUTIONS","PLAN_HASH_VALUE"]]></DATA_MAP_COLNAMES>
				<DATA_MAP_SERIES><![CDATA[\]]></DATA_MAP_SERIES>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<DATA_MAP_COUNT><![CDATA[0]]></DATA_MAP_COUNT>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<XAXIS_TITLE><![CDATA[false]]></XAXIS_TITLE>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<DATA_MAP_VALUES><![CDATA[\]]></DATA_MAP_VALUES>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<XAXIS_TITLE_TEXT><![CDATA[]]></XAXIS_TITLE_TEXT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
    snaps as ( select snaps.begin_interval_time,snaps.end_interval_time,snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps
                where not (snaps.begin_interval_time > :P_END_DATE or snaps.end_interval_time < :P_START_DATE) and snaps.instance_number = :INSTANCE_NUMBER)
select /*+ NO_PARALLEL */
     end_interval_time
    ,plan_hash_value
    ,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta/1000000/executions_delta,4)  else 0 end,'99990.990')   avg_time_sec
    --,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta/1000/executions_delta,4)     else 0 end,'99990.990')   avg_time_millisec
    --,case when executions_delta > 0 or executions_delta is not null         then executions_delta else 0 end                                                     executions
from (
        select begin_interval_time, end_interval_time, s.sql_id, s.plan_hash_value, executions_delta,elapsed_time_delta,s.version_count
        from snaps snap
            left outer join dba_hist_sqlstat s on snap.snap_id = s.snap_id and snap.dbid = s.dbid and snap.instance_number = s.instance_number -- pk=snap_id dbid
                and s.sql_id = :SQL_ID
                and s.con_id = :CON_ID
        )
order by end_interval_time,plan_hash_value]]></sql>
				<binds>
					<bind id="P_END_DATE">
						<prompt><![CDATA[P_END_DATE]]></prompt>
						<tooltip><![CDATA[P_END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_START_DATE">
						<prompt><![CDATA[P_START_DATE]]></prompt>
						<tooltip><![CDATA[P_START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[chart hist execs]]></name>
			<description><![CDATA[History of the  number of executions by plan in the container]]></description>
			<tooltip><![CDATA[History of the  number of executions by plan in the container]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<Y1AXIS_TITLE_TEXT><![CDATA[Number of executions]]></Y1AXIS_TITLE_TEXT>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y2AXIS_TITLE><![CDATA[true]]></Y2AXIS_TITLE>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<DATA_MAP_COLUMNS><![CDATA[\]]></DATA_MAP_COLUMNS>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
				<Y2AXIS_TITLE_TEXT><![CDATA[Number of Executions]]></Y2AXIS_TITLE_TEXT>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<DATA_MAP_COLNAMES><![CDATA[\,"AVG_TIME_MILLISEC","AVG_TIME_SEC","END_SNAP","EXECUTIONS","PLAN_HASH_VALUE"]]></DATA_MAP_COLNAMES>
				<DATA_MAP_SERIES><![CDATA[\]]></DATA_MAP_SERIES>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<DATA_MAP_COUNT><![CDATA[0]]></DATA_MAP_COUNT>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<XAXIS_TITLE><![CDATA[false]]></XAXIS_TITLE>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<DATA_MAP_VALUES><![CDATA[\]]></DATA_MAP_VALUES>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<XAXIS_TITLE_TEXT><![CDATA[]]></XAXIS_TITLE_TEXT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
    snaps as ( select snaps.begin_interval_time,snaps.end_interval_time,snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps
                where not (snaps.begin_interval_time > :P_END_DATE or snaps.end_interval_time < :P_START_DATE) and snaps.instance_number = :INSTANCE_NUMBER)
select /*+ NO_PARALLEL */
     end_interval_time
    ,plan_hash_value
    --,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta/1000000/executions_delta,4)  else 0 end,'99990.990')   avg_time_sec
    --,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta/1000/executions_delta,4)     else 0 end,'99990.990')   avg_time_millisec
    ,case when executions_delta > 0 or executions_delta is not null         then executions_delta else 0 end                                                     executions
from (
        select begin_interval_time, end_interval_time, s.sql_id, s.plan_hash_value, executions_delta,elapsed_time_delta,s.version_count
        from snaps snap
            left outer join dba_hist_sqlstat s on snap.snap_id = s.snap_id and snap.dbid = s.dbid and snap.instance_number = s.instance_number -- pk=snap_id dbid
                and s.sql_id = :SQL_ID
                and s.con_id = :CON_ID
        )
order by end_interval_time,plan_hash_value]]></sql>
				<binds>
					<bind id="P_END_DATE">
						<prompt><![CDATA[P_END_DATE]]></prompt>
						<tooltip><![CDATA[P_END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_START_DATE">
						<prompt><![CDATA[P_START_DATE]]></prompt>
						<tooltip><![CDATA[P_START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[chart hist avg_all]]></name>
			<description><![CDATA[History of the  datails of time spent for the plan in the container]]></description>
			<tooltip><![CDATA[History of the  datails of time spent for the plan in the container]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<Y1AXIS_TITLE_TEXT><![CDATA[Sum avg times by plan]]></Y1AXIS_TITLE_TEXT>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y2AXIS_TITLE><![CDATA[true]]></Y2AXIS_TITLE>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<DATA_MAP_COLUMNS><![CDATA[\]]></DATA_MAP_COLUMNS>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
				<Y2AXIS_TITLE_TEXT><![CDATA[Number of Executions]]></Y2AXIS_TITLE_TEXT>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<DATA_MAP_COLNAMES><![CDATA[\,"AVG_VAL","END_INTERVAL_TIME","VALUE"]]></DATA_MAP_COLNAMES>
				<DATA_MAP_SERIES><![CDATA[\]]></DATA_MAP_SERIES>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<DATA_MAP_COUNT><![CDATA[0]]></DATA_MAP_COUNT>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<XAXIS_TITLE><![CDATA[false]]></XAXIS_TITLE>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<DATA_MAP_VALUES><![CDATA[\]]></DATA_MAP_VALUES>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_TITLE><![CDATA[true]]></Y1AXIS_TITLE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<XAXIS_TITLE_TEXT><![CDATA[]]></XAXIS_TITLE_TEXT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[with
    snaps as ( select snaps.begin_interval_time,snaps.end_interval_time,snaps.dbid,snaps.instance_number,snaps.snap_id from dba_hist_snapshot snaps
                where not (snaps.begin_interval_time > :P_END_DATE or snaps.end_interval_time < :P_START_DATE) and snaps.instance_number = :INSTANCE_NUMBER)
select end_interval_time,avg_val,value
from (
    select /*+ NO_PARALLEL */
         end_interval_time
        ,plan_hash_value
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta   /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_time_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(elapsed_time_delta   /1000/executions_delta,4)       else 0 end,'99990.990')  avg_time_millisec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(cpu_time_delta       /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_cpu_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(iowait_delta         /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_iowait_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(apwait_delta         /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_application_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(ccwait_delta         /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_concurrency_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(clwait_delta         /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_cluster_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(plsexec_time_delta   /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_plsql_sec
        ,to_char(case when executions_delta > 0 or executions_delta is not null then round(javexec_time_delta   /1000000/executions_delta,4)    else 0 end,'99990.990')  avg_java_sec
    from (
            select begin_interval_time, end_interval_time, s.sql_id, s.plan_hash_value, executions_delta,elapsed_time_delta,s.version_count
                    ,cpu_time_delta,iowait_delta,apwait_delta,ccwait_delta,clwait_delta,plsexec_time_delta,javexec_time_delta
            from snaps snap
                left outer join dba_hist_sqlstat s on snap.snap_id = s.snap_id and snap.dbid = s.dbid and snap.instance_number = s.instance_number -- pk=snap_id dbid
                    and s.sql_id = :SQL_ID
                    and s.con_id = :CON_ID
            )
    ) unpivot (value  for avg_val in (avg_cpu_sec,avg_iowait_sec,avg_application_sec,avg_concurrency_sec,avg_cluster_sec,avg_plsql_sec,avg_java_sec))
order by end_interval_time]]></sql>
				<binds>
					<bind id="P_END_DATE">
						<prompt><![CDATA[P_END_DATE]]></prompt>
						<tooltip><![CDATA[P_END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_START_DATE">
						<prompt><![CDATA[P_START_DATE]]></prompt>
						<tooltip><![CDATA[P_START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[gv$sql]]></name>
			<description><![CDATA[Records in gv$sq]]></description>
			<tooltip><![CDATA[Records in gv$sq]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */
	--,sql_text
	--,sql_fulltext
	sql_id
	,child_number
	,plan_hash_value
	,sql_profile
	,sql_plan_baseline
	,executions
	,to_char(last_active_time,'yyyy-mm-dd hh24:mi:ss') last_active_time
	,first_load_time
	,parsing_schema_name
	,exact_matching_signature
	,is_obsolete
	,is_bind_sensitive
	,is_bind_aware
	,is_shareable
	,program_id
	,sharable_mem
	,persistent_mem
	,runtime_mem
	,sorts
	,loaded_versions
	,open_versions
	,users_opening
	,fetches
	,px_servers_executions
	,end_of_fetch_count
	,users_executing
	,loads
	,invalidations
	,parse_calls
	,disk_reads
	,direct_writes
	,buffer_gets
	,application_wait_time
	,concurrency_wait_time
	,cluster_wait_time
	,user_io_wait_time
	,plsql_exec_time
	,java_exec_time
	,rows_processed
	,command_type
	,optimizer_mode
	,optimizer_cost
	,optimizer_env
	,optimizer_env_hash_value
	,parsing_user_id
	,parsing_schema_id
	,kept_versions
	,address
	,type_chk_heap
	,hash_value
	,old_hash_value
	,service
	,service_hash
	,module
	,module_hash
	,action
	,action_hash
	,serializable_aborts
	,outline_category
	,cpu_time
	,elapsed_time
	,outline_sid
	,child_address
	,sqltype
	,remote
	,object_status
	,literal_hash_value
	,last_load_time
	,child_latch
	,sql_patch
	,program_line#
	,force_matching_signature
	,bind_data
	,typecheck_mem
	,io_cell_offload_eligible_bytes
	,io_interconnect_bytes
	,physical_read_requests
	,physical_read_bytes
	,physical_write_requests
	,physical_write_bytes
	,optimized_phy_read_requests
	,locked_total
	,pinned_total
	,io_cell_uncompressed_bytes
	,io_cell_offload_returned_bytes
from gv$sql where inst_id = :INSTANCE_NUMBER and sql_id = :SQL_ID
order by child_number]]></sql>
				<binds>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[binds]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
     sql_plan         as (select ' ' view_name ,to_char(child_number)  ,to_char(bind_pos),to_char(bind_type)  ,bind_name     ,case when c.bind_type = 1 then utl_raw.cast_to_varchar2(c.bind_data) when c.bind_type = 2 then to_char(utl_raw.cast_to_number(c.bind_data)) when c.bind_type = 96 or c.bind_type = 23 then to_char(utl_raw.cast_to_varchar2(c.bind_data)) else 'Not printable try with DBMS_XPLAN.DISPLAY_CURSOR' end bind_data,to_char(p.timestamp,'yyyy-mm-dd hh24:mi:ss')  from gv$sql_plan p,xmltable ( '/*/peeked_binds/bind' passing xmltype(p.other_xml)columns bind_name varchar2(100) path '/bind/@nam',bind_pos number path '/bind/@pos',bind_type number path '/bind/@dty',bind_data raw(2000) path '/bind' ) c where 1=1 and p.other_xml is not null and p.inst_id = :INST_ID and p.sql_id = :SQL_ID  order by child_number, c.bind_pos)
    ,sql_bind_capture as (select ' ' view_name ,to_char(child_number)  ,to_char(position),datatype_string     ,name          ,value_string,to_char(last_captured,'yyyy-mm-dd hh24:mi:ss')      from gv$sql_bind_capture   where inst_id = 1   and sql_id = :SQL_ID  order by child_number, position)
    ,sql              as (select ' ' view_name ,to_char(child_number)  ,to_char(position),datatype_string     ,name          ,value_string,to_char(last_active_time,'yyyy-mm-dd hh24:mi:ss')   from gv$sql,table(dbms_sqltune.extract_binds(bind_data)) where inst_id = :INST_ID and sql_id = :SQL_ID order by child_number, position)
    ,hist_sqlstat     as (select ' ' view_name ,null                   ,to_char(position),datatype_string     ,name          ,value_string ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') from dba_hist_sqlstat dhs join dba_hist_snapshot snap on dhs.snap_id = snap.snap_id  and dhs.instance_number = snap.instance_number cross join table(dbms_sqltune.extract_binds(bind_data)) where end_interval_time > sysdate - 1 and dhs.sql_id = :SQL_ID and dhs.instance_number = :INST_ID order by end_interval_time,position)
    ,hist_sqlbind     as (select ' ' view_name ,null                   ,to_char(position),datatype_string     ,name          ,value_string ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') from dba_hist_sqlbind dhs join dba_hist_snapshot snap on dhs.snap_id = snap.snap_id  and dhs.instance_number = snap.instance_number and dhs.dbid = snap.dbid where  dhs.sql_id = :SQL_ID and dhs.instance_number = :INST_ID order by end_interval_time,dhs.position)
select 'GV$SQL_PLAN peeked'                  view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql_plan                       union all                                                                  
select 'GV$SQL_BIND_CAPTURE'                 view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql_bind_capture               union all                                                                  
select 'GV$SQL'                              view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from sql                            union all                                                                  
select 'DBA_HIST_SQLSTAT'                    view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from hist_sqlstat                   union all                                                                  
select /*+ NO_PARALLEL */ 'DBA_HIST_SQLBIND' view_name  ,'=======' child_number,'=======' position,'=======' datatype,'=======' name,'=======' value,'=======' datetime from dual  union all
select * from hist_sqlbind]]></sql>
				<binds>
					<bind id="INST_ID">
						<prompt><![CDATA[INST_ID]]></prompt>
						<tooltip><![CDATA[INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[exec]]></name>
			<description><![CDATA[Script to test the sql execution]]></description>
			<tooltip><![CDATA[Script to test the sql execution]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set linesize 20000 heading off pages 0 feedback off heading off long 100000 longchunksize 1000000
col sql_text for a10000 word_wrapped
select 'set linesize 20000 pages 10000 long 100000' from dual;
select 'alter session set statistics_level = all;' from dual;
select 'alter session set current_schema = '||:PARSING_SCHEMA_NAME||';' from dual;
select '--NLS_DATE_FORMAT='||sys_context('USERENV','NLS_DATE_FORMAT') nls_date_format from dual;
select '--alter session set nls_date_format =''yyyy-mm-dd hh24:mi:ss'';' from dual;
prompt
prompt
select '--Declare bind variables' from dual;
select 'variable '||ltrim(name,':')||' '||case when datatype_string = 'DATE' then 'VARCHAR2  ---DATE' else datatype_string end
from  dba_hist_sqlbind hsb
where hsb.sql_id = :SQL_ID and snap_id = :SNAP
order by last_captured,position;
prompt
select '--Exec bind variables' from dual;
select /*+ NO_PARALLEL */ 'exec '||name||' := '||
case sys.anydata.gettypename(value_anydata)
		when null				then	'null'
		when 'SYS.BDOUBLE'		then	to_char(sys.anydata.accessbdouble(value_anydata))
		--when 'SYS.BFILE'		  then	  sys.anydata.AccessBfile(value_anydata)
		when 'SYS.BFLOAT'		then	to_char(sys.anydata.accessbfloat(value_anydata))
		--when 'SYS.BLOB'		  then	  sys.anydata.AccessBlob(value_anydata)
		when 'SYS.CHAR'			then	''''||sys.anydata.accesschar(value_anydata)||''''
		when 'SYS.CLOB'			then	to_char(sys.anydata.accessclob(value_anydata))
		when 'SYS.DATE'			then	 ''''||to_char(sys.anydata.accessdate(value_anydata), 'yyyy-mm-dd hh24:mi:ss')||'''' ||'		--to_date('||name||',''yyyy-mm-dd hh24:mi:ss'')'
		--when 'SYS.INTERVALYM'	  then	  sys.anydata.AccessIntervalYM(value_anydata)
		--when 'SYS.INTERVALDS'	  then	  sys.anydata.AccessIntervalDS(value_anydata)
		--when 'SYS.NCHAR'		  then	  sys.anydata.AccessNchar(value_anydata)
		--when 'SYS.NCLOB'		  then	  sys.anydata.AccessNClob(value_anydata)
		when 'SYS.NUMBER'		then	to_char(sys.anydata.accessnumber(value_anydata))
		--when 'SYS.NVARCHAR2'	  then	  sys.anydata.AccessNVarchar2(value_anydata)
		--when 'SYS.RAW'		  then	  sys.anydata.AccessRaw(value_anydata)
		when 'SYS.TIMESTAMP'	then	''''||to_char(sys.anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss')||''''||'		  --to_timestamp('||name||',''yyyy-mm-dd hh24:mi:ss'')'
		when 'SYS.TIMESTAMPLTZ' then	to_char(sys.anydata.AccessTimestampLTZ(value_anydata),'yyyy-mm-dd hh24:mi:ss')
		when 'SYS.TIMESTAMPTZ'	then	to_char(sys.anydata.AccessTimestampTZ(value_anydata),'yyyy-mm-dd hh24:mi:ss')
		--when 'SYS.UROWID'		  then	  sys.anydata.AccessURowid(value_anydata)
		when 'SYS.VARCHAR'		then	''''||sys.anydata.accessvarchar(value_anydata)||''''
		when 'SYS.VARCHAR2'		then	''''||sys.anydata.accessvarchar2(value_anydata)||''''
		else 'null'
	end || '     --last_captured='|| to_char(last_captured,'yyyy-mm-dd hh24:mi:ss') ||', position='||position
from  dba_hist_sqlbind hsb
where sql_id = :SQL_ID and snap_id = :SNAP and instance_number = :INST and dbid = :DBID and hsb.con_id = :CON_ID
order by last_captured,position;
prompt
prompt
select '--SQL text' from dual;
select sql_text||';' sql_text
from dba_hist_sqltext t
where t.sql_id = :SQL_ID and t.dbid = :DBID and rownum < 2;
prompt
prompt
select 'select * from table(dbms_xplan.display_cursor(null,null,''allstats last +peeked_binds +alias +bytes''));' from dual;
select 'select * from table(dbms_xplan.display_cursor('''||:SQL_ID||''',null,''advanced''));' from dual;
select 'select * from table(dbms_xplan.display_awr('''||:SQL_ID||''',null,null,''advanced''));' from dual;

prompt
prompt
prompt]]></sql>
				<binds>
					<bind id="PARSING_SCHEMA_NAME">
						<prompt><![CDATA[PARSING_SCHEMA_NAME]]></prompt>
						<tooltip><![CDATA[PARSING_SCHEMA_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INST">
						<prompt><![CDATA[INST]]></prompt>
						<tooltip><![CDATA[INST]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[display awr]]></name>
			<description><![CDATA[dbms_xplan.display_awr]]></description>
			<tooltip><![CDATA[dbms_xplan.display_awr]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[--select * from table(dbms_xplan.display_awr( :SQL_ID,:PLAN_HASH_VALUE,:DBID,'advanced'));
--select 'select * from table(dbms_xplan.display_awr('''||:SQL_ID||''', '||:PLAN_HASH_VALUE||', '||:DBID||', ''advanced''));' "Run in the pdb" from dual;
set serveroutput on size unlimited
set lines 10000
declare
    l_cursor        pls_integer;
    l_reports       dbms_sql.varchar2_table;   
    l_output        varchar2(1000);   
    l_rows          number;
begin
    l_cursor := dbms_sql.open_cursor(security_level => 2);
    dbms_sql.parse( c => l_cursor,
                        statement     => 'select plan_table_output output from table(dbms_xplan.display_awr( :SQL_ID,:PLAN_HASH_VALUE,:DBID,''advanced''))',
                        language_flag => dbms_sql.native,
                        container     => :CON_NAME);
    dbms_sql.bind_variable(l_cursor, ':SQL_ID', :SQL_ID);                   
    dbms_sql.bind_variable(l_cursor, ':PLAN_HASH_VALUE', :PLAN_HASH_VALUE);                   
    dbms_sql.bind_variable(l_cursor, ':DBID', :DBID);                   
    l_rows := dbms_sql.execute(c => l_cursor);
    dbms_sql.define_column(l_cursor, 1, l_output, 1000); 
    loop 
        if dbms_sql.fetch_rows(l_cursor) > 0 then 
            -- get column values of the row 
            dbms_sql.column_value(l_cursor, 1, l_output); 
            dbms_output.put_line(l_output); 
        else 
            -- no more rows 
            exit; 
        end if; 
    end loop;  
    dbms_sql.close_cursor(c => l_cursor);
END;
/]]></sql>
				<binds>
					<bind id="CON_NAME">
						<prompt><![CDATA[CON_NAME]]></prompt>
						<tooltip><![CDATA[CON_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[display cursor]]></name>
			<description><![CDATA[dbms_xplan.display_cursor]]></description>
			<tooltip><![CDATA[dbms_xplan.display_cursor]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select * from table(dbms_xplan.display_cursor( :SQL_ID,:CHILD_NUMBER,'advanced'))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CHILD_NUMBER">
						<prompt><![CDATA[CHILD_NUMBER]]></prompt>
						<tooltip><![CDATA[CHILD_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[load sql_plan_baseline]]></name>
			<description><![CDATA[Script to load the plan selected in the SQL Baseline]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set linesize 20000 heading off pages 0 feedback off heading off long 100000 longchunksize 1000000
col sql_text for a10000 word_wrapped
select '--!!!Create baseline first to have the steps to modify/export.!!!'||chr(10)||chr(10) from dual;


select
	'set serveroutput on;'||chr(10)||
	'exec dbms_sqltune.drop_sqlset(sqlset_name=>'''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''');'||chr(10)||
	'exec dbms_sqltune.create_sqlset(sqlset_name => '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''', description => '':SNAP='||:SNAP||',:SQL_ID='||:SQL_ID||',:PLAN_HASH_VALUE='||:PLAN_HASH_VALUE||''');'||chr(10)||
	'declare'||chr(10)||
	chr(9)||'cur       sys_refcursor;'||chr(10)||
	chr(9)||'l_plan    pls_integer;'||chr(10)||
	'begin	'||chr(10)||
	chr(9)||'open cur for select value(p) from table(dbms_sqltune.select_workload_repository(begin_snap=> '||to_char(:SNAP-1)||',end_snap => '||:SNAP||',basic_filter => ''sql_id = '''''||:SQL_ID||''''' or plan_hash_value = '''''||:PLAN_HASH_VALUE||''''''',attribute_list=>''ALL'', dbid => '||:DBID||') ) p;'||chr(10)||
	chr(9)||'dbms_sqltune.load_sqlset( sqlset_name=> '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''', populate_cursor=>cur);'||chr(10)||
	chr(9)||'close cur;'||chr(10)||
	chr(9)||'execute immediate ''alter session set tracefile_identifier=load_plans_from_sqlset'';'||chr(10)||
	chr(9)||'dbms_spm.configure(''spm_tracing'',1); -- trace on'||chr(10)||
    chr(9)||'l_plan := dbms_spm.load_plans_from_sqlset(sqlset_name => '''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||''',basic_filter=>''plan_hash_value = '''''||:PLAN_HASH_VALUE||''''''');'||chr(10)||
	chr(9)||'dbms_spm.configure(''spm_tracing'',0); -- trace off'||chr(10)||
	chr(9)||'dbms_output.put_line(''Plans Loaded: '' || l_plan);'||chr(10)||
	'end;'||chr(10)||
	'/'||chr(10)
    sql_text
from dual;

select 'select * from table(dbms_sqltune.select_sqlset('''||:SNAP||'.'||:SQL_ID||'.'||:PLAN_HASH_VALUE||'''));'||chr(10) sql_text from dual; 
select 'select * from   dba_sql_plan_baselines;'||chr(10) sql_text from dual;

select
    '-- If replace with a hinted plan run:'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    'variable l_rc number'||chr(10)||
    'exec :l_rc := dbms_spm.load_plans_from_cursor_cache(sql_id => ''xxxxx'',plan_hash_value => ''000000'',sql_handle => '''||sql_handle||''',fixed => ''YES'' );'||chr(10)||
    'print :l_rc'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    'exec :l_rc := dbms_spm.drop_sql_plan_baseline (sql_handle => '''||sql_handle||''',plan_name  => '''||plan_name||''');'||chr(10)||
    'print :l_rc'||chr(10)||
    'select sql_handle,plan_name,origin,enabled,accepted,fixed from dba_sql_plan_baselines where signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id='''||:SQL_ID||''');'||chr(10)||
    chr(10)
from dba_sql_plan_baselines, (select :SQL_ID sql_id from dual) sql
where 1=1 
and (  signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sqlstats where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql_monitor where sql_id=sql.sql_id)
    );
    
    
select
    '-- If export baseline run:'||chr(10)||
    '--SOURCE'||chr(10)||
    'exec dbms_spm.create_stgtab_baseline(''STGTAB'', ''SYSTEM'');'||chr(10)||
    'variable l_rc number'||chr(10)||
    'exec :l_rc := dbms_spm.pack_stgtab_baseline(''STGTAB'', ''SYSTEM'', sql_handle => '''||sql_handle||''', plan_name => '''||plan_name||''' );'||chr(10)||
    'print :l_rc'||chr(10)||
    'create or replace directory DPDIR as ''/oraback/Adhoc/exports'';'||chr(10)||
    'expdp \''/ as sysdba\'' TABLES=system.stgtab  dumpfile=${ORACLE_SID}.stgtab.$(date ''+%Y-%m-%d_%H%M%S'').dmp  logfile=${ORACLE_SID}.stgtab.$(date ''+%Y-%m-%d_%H%M%S'').log directory=dpdir'||chr(10)||
    'scp /oraback/Adhoc/exports/NWMU.stgtab.2016-06-13_113507.dmp  v06summ5t:/oraback/Adhoc/exports'||chr(10)||
    'drop table system.stgtab;'||chr(10)||
    '--TARGET'||chr(10)||
    'create or replace directory DPDIR as ''/oraback/Adhoc/exports'';'||chr(10)||
    'impdp \''/ as sysdba\'' TABLES=system.stgtab  dumpfile=ORCL.stgtab.YYYY-MM-DD_HH24MISS.dmp  logfile=${ORACLE_SID}.stgtab.import.$(date ''+%Y-%m-%d_%H%M%S'').log directory=dpdir'||chr(10)||
    'var x number;'||chr(10)||
    'exec :x := dbms_spm.unpack_stgtab_baseline(''STGTAB'', ''SYSTEM'');'||chr(10)||
    chr(10)
from dba_sql_plan_baselines, (select :SQL_ID sql_id from dual) sql
where 1=1 
and (  signature in (select dbms_sqltune.sqltext_to_signature(sql_text) from dba_hist_sqltext where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sqlstats where sql_id=sql.sql_id)
    or signature in (select exact_matching_signature from gv$sql_monitor where sql_id=sql.sql_id)
    );]]></sql>
				<binds>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[sql_profile hint]]></name>
			<description><![CDATA[Hint of the SQL Profile]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */ hint
from (select p.name, p.signature, p.category,
			 row_number() over (partition by sd.signature, sd.category order by sd.signature) row_num,
			 extractValue(value(t), '/hint') hint
	  from sys.sqlobj$data sd, dba_sql_profiles p, table(xmlsequence(extract(xmltype(sd.comp_data),'/outline_data/hint'))) t
	  where sd.obj_type = 1
	  and p.signature = sd.signature
	  and p.name like nvl(:SQL_PROFILE,name)
)]]></sql>
				<binds>
					<bind id="SQL_PROFILE">
						<prompt><![CDATA[SQL_PROFILE]]></prompt>
						<tooltip><![CDATA[SQL_PROFILE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[load sql_profile]]></name>
			<description><![CDATA[Script to create a SQL Profile with dbms_sqltune and load]]></description>
			<tooltip><![CDATA[Script to create a SQL Profile with dbms_sqltune and load]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select	/*+ NO_PARALLEL */  																		chr(10)||
'--ORA-13786 -> run as sysdba'||chr(10)||
'set serveroutput on echo on'||chr(10)||
'variable tuning_task varchar2(100)																 '||chr(10)||
'variable sql_id	  varchar2(100)																 '||chr(10)||
'variable profile	  varchar2(100)																 '||chr(10)||
'exec :tuning_task := ''tuning_task_'||:SQL_ID||''';											 '||chr(10)||
'exec :profile	   := ''profile_'||:SQL_ID||''';												 '||chr(10)||
'exec :SQL_ID	   := '''||:SQL_ID||''';														 '||chr(10)||
'-- drop tuning task'||chr(10)||
'exec begin dbms_sqltune.drop_tuning_task(task_name => :tuning_task); exception when others then null; end;'||chr(10)||
'-- drop sql profile'||chr(10)||
'--exec dbms_sqltune.drop_sql_profile (name => :profile, ignore => true);						 '||chr(10)||
'-- create tuning task																			 '||chr(10)||
'begin																							 '||chr(10)||
'  :tuning_task := dbms_sqltune.create_tuning_task (											 '||chr(10)||
case when :SNAP > 0 then '						   begin_snap  => '||(:SNAP -1)||', end_snap => '||:SNAP||','||chr(10) else null end ||
'						   sql_id	   => :sql_id,												 '||chr(10)||
'						   scope	   => dbms_sqltune.scope_comprehensive,						 '||chr(10)||
'						   time_limit  => 60,													 '||chr(10)||
'						   task_name   => :tuning_task,											 '||chr(10)||
'						   description => ''Tuning task for statement ''||:SQL_ID||''.'');		 '||chr(10)||
'  dbms_output.put_line(''sql_tune_task_id: '' || :tuning_task);								 '||chr(10)||
'  dbms_sqltune.execute_tuning_task(:tuning_task);												 '||chr(10)||
'  dbms_output.put_line(:tuning_task);															 '||chr(10)||
'end;																							 '||chr(10)||
'/																								 '||chr(10)||
'set long 80000 pages 1000 line 200																 '||chr(10)||
'col report format a130																			 '||chr(10)||
'select dbms_sqltune.report_tuning_task(:tuning_task) report from dual;									'||chr(10)||
'select rat.attr1 from sys.wri$_adv_tasks tsk, sys.wri$_adv_rationale rat where tsk.name = :tuning_task and rat.task_id = tsk.id ;'||chr(10)||
'begin																							 '||chr(10)||
'	 dbms_sqltune.accept_sql_profile( task_name => :tuning_task,								 '||chr(10)||
'									 task_owner =>	sys_context(''USERENV'', ''SESSION_USER''),	 '||chr(10)||
'									 name => :profile,											 '||chr(10)||
'									 description => ''profile for '||:SQL_ID||''',				 '||chr(10)||
'									 --category => ''TEST'',									 '||chr(10)||
'									 replace => TRUE,											 '||chr(10)||
'									 force_match => TRUE,										 '||chr(10)||
'									 profile_type => DBMS_SQLTUNE.PX_PROFILE					 '||chr(10)||
'	 );																							 '||chr(10)||
'end;																							 '||chr(10)||
'/																								 '||chr(10)||
'col created for a30																			 '||chr(10)||
'select name,status,created from dba_sql_profiles where name = :profile;						 '||chr(10)||
																									chr(10)	  load_profile
from dual]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[stats]]></name>
			<description><![CDATA[Tables and indexes statistics]]></description>
			<tooltip><![CDATA[Tables and indexes statistics]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with 
     parms as (select :SQL_ID sql_id from dual)
    ,plans as (select distinct hsp.sql_id,hsp.plan_hash_value,hsp.con_id from dba_hist_sql_plan hsp ,parms where hsp.sql_id = parms.sql_id  union all select distinct vsp.sql_id,vsp.plan_hash_value,vsp.con_id from gv$sql_plan vsp,parms where vsp.sql_id = parms.sql_id)
select  
     p.plan_hash_value
    ,p.id plan_id
    ,p.object# object_id
    ,p.object_owner
    ,p.object_name
    ,p.operation ||'  '||p.options operation_options
    --,p.object_type
    ,case when p.object_type like 'INDEX%' then p.object_type||'('||idx.table_name||')' else p.object_type end object_type
    ,case when p.object_type like 'TABLE%' then to_char(tbl.last_analyzed,'yyyy-mm-dd hh24:mi:ss') when p.object_type like 'INDEX%' then to_char(idx.last_analyzed,'yyyy-mm-dd hh24:mi:ss') else null end last_analyzed
    ,case when p.object_type like 'TABLE%' then tbl.num_rows when p.object_type like 'INDEX%' then idx.num_rows else null end num_rows
    ,case when p.object_type like 'INDEX%' then idx.distinct_keys else null end idx_distinct_keys
    ,case when p.object_type like 'TABLE%' then round((tbl.blocks+tbl.empty_blocks)*8192/1024/1024) else null end  size_mb 
    ,case when p.object_type like 'TABLE%' then round((tbl.empty_blocks)*8192/1024/1024) else null end  empty_mb 
    ,case when p.object_type like 'TABLE%' then round((tbl.blocks*8192/1024/1024) - (tbl.num_rows*tbl.avg_row_len/1024/1024)) else null end empty_below_hwm_mb
from (select hsp.sql_id,hsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,hsp.con_id from dba_hist_sql_plan hsp ,plans  where hsp.sql_id = plans.sql_id and hsp.plan_hash_value = plans.plan_hash_value and hsp.con_id = plans.con_id
      union
      select vsp.sql_id,vsp.plan_hash_value,timestamp,id,object#,object_owner,object_name,object_type,operation,options,vsp.con_id from gv$sql_plan vsp,plans         where vsp.sql_id = plans.sql_id and vsp.plan_hash_value = plans.plan_hash_value and vsp.con_id = plans.con_id
      ) p
         left  outer join cdb_tables tbl    on p.object_owner = tbl.owner and p.object_name  = tbl.table_name and p.con_id  = tbl.con_id and  p.object_type like 'TABLE%'
         left  outer join cdb_indexes idx   on p.object_owner = idx.owner and p.object_name  = idx.index_name and p.con_id  = idx.con_id and  p.object_type like 'INDEX%'
where 1=1 
    and p.object_name is not null
    and p.plan_hash_value = :PLAN_HASH_VALUE
order by sql_id,plan_hash_value,id]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[tables_stats_cols]]></name>
			<description><![CDATA[Tables column statistics]]></description>
			<tooltip><![CDATA[Tables column statistics]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with 
    function raw_to_num(i_raw raw) return number        is m_n number;          begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_float(i_raw raw) return float       is m_n float;           begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_date(i_raw raw) return date         is m_n date;            begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
    function raw_to_varchar2(i_raw raw) return varchar2 is m_n varchar2(10000); begin dbms_stats.convert_raw_value(i_raw,m_n); return m_n; end;
select 
     p.plan_hash_value
    ,p.id plan_id
    ,p.object# object_id
    ,p.object_owner
    ,p.object_name
    ,p.operation ||'  '||p.options                          operation_options
	--,to_char(t.last_analyzed,'yyyy-mm-dd hh24:mi:ss')       tbl_last_analyzed
	,to_char(tbls.last_analyzed,'yyyy-mm-dd hh24:mi:ss')    last_analyzed
    ,tbls.column_name
	,tbls.histogram
    ,t.num_rows                                             tbl_num_rows
	,tbls.num_distinct
	,tbls.num_nulls
	,tbls.num_buckets
	,tbls.density
    ,t.avg_row_len
	,tbls.avg_col_len
	--,tbls.user_stats
    ,case tbc.data_type when 'VARCHAR2' then to_char(raw_to_varchar2(tbls.low_value))  when 'DATE' then to_char(raw_to_date(tbls.low_value),'yyyy-mm-dd hh24:mi:ss')  when 'NUMBER' then to_char(raw_to_num(tbls.low_value)) when 'FLOAT' then to_char(raw_to_float(tbls.low_value)) end low_value
	--,tbls.low_value
    ,case tbc.data_type when 'VARCHAR2' then to_char(raw_to_varchar2(tbls.high_value))  when 'DATE' then to_char(raw_to_date(tbls.high_value),'yyyy-mm-dd hh24:mi:ss')  when 'NUMBER' then to_char(raw_to_num(tbls.high_value)) when 'FLOAT' then to_char(raw_to_float(tbls.high_value)) end high_value
	--,tbls.high_value
	--,tbls.sample_size
	--,tbls.global_stats
from  dba_hist_sql_plan p 
    left  outer join cdb_tables t                   on p.object_owner = t.owner    and p.object_name = t.table_name      and p.con_id   = t.con_id  
    left  outer join cdb_tab_columns tbc            on t.owner = tbc.owner         and t.table_name = tbc.table_name     and t.con_id   = tbc.con_id  
    left  outer join cdb_tab_col_statistics tbls    on tbc.owner = tbls.owner      and tbc.table_name = tbls.table_name  and tbc.column_name = tbls.column_name and tbc.con_id  = tbls.con_id
where 1=1 
    and p.dbid = :DBID
    and p.con_dbid = :CON_DBID
    and p.con_id = :CON_ID
    and p.sql_id = :SQL_ID
    and p.plan_hash_value = :PLAN_HASH_VALUE
    --and p.dbid = 2780785463
    --and p.con_dbid = 2832289441
    --and p.con_id = 3
    --and p.sql_id= 'c13sma6rkr27c'
    --and p.plan_hash_value = 2569993617    
    and p.object# is not null
order by p.position,tbc.owner,tbc.table_name,tbc.column_name]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[indexes]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select /*+ NO_PARALLEL */ distinct
     p.position plan_position
    ,i.table_owner
    ,i.table_name
    ,i.owner index_owner
    ,i.index_name
    ,i.index_type
    ,i.partitioned
    ,c.column_name
    ,c.column_position
    ,p.options
    ,p.access_predicates
    ,p.filter_predicates
    ,i.blevel
    ,i.leaf_blocks
    ,i.distinct_keys
    ,i.avg_leaf_blocks_per_key
    ,i.avg_leaf_blocks_per_key
    ,i.avg_data_blocks_per_key
    ,i.clustering_factor
    ,i.status
    ,i.num_rows
    ,i.sample_size
    ,to_char(i.last_analyzed,'yyyy-mm-dd hh24:mi:ss') last_analyzed
from  dba_hist_sql_plan p 
    join cdb_indexes i      on p.object_name = i.index_name and p.object_owner = i.owner and p.con_id = i.con_id
    join cdb_ind_columns c  on i.index_name  = c.index_name and i.owner = c.index_owner  and i.con_id = c.con_id
where 1=1 
    and p.dbid = :DBID
    and p.con_dbid = :CON_DBID
    and p.con_id = :CON_ID
    and p.sql_id=:SQL_ID
    and p.plan_hash_value = :PLAN_HASH_VALUE
order by p.position,i.table_owner,i.table_name,i.index_name,c.column_position,c.column_name]]></sql>
				<binds>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_DBID">
						<prompt><![CDATA[CON_DBID]]></prompt>
						<tooltip><![CDATA[CON_DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[stats_history]]></name>
			<description><![CDATA[Statistic history]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with hsp as (	select /*+ no_merge */ distinct object_owner,object_name,object#
				from  dba_hist_sql_plan
				where dbid = :DBID and con_dbid = :CON_DBID and con_id = :CON_ID and sql_id = :SQL_ID and plan_hash_value = :PLAN_HASH_VALUE and object# is not null),
	 st	 as (	select obj#,savtime,rowcnt from sys.wri$_optstat_ind_history si
				union all
				select obj#,savtime,rowcnt from sys.wri$_optstat_tab_history st)
select /*+ leading(hsp st o) NO_PARALLEL */
	 hsp.object_owner
	,hsp.object_name
	,hsp.object#
	--,o.object_type
	,to_char (savtime,'yyyy-mm-dd hh24:mi:ss') savtime
	,rowcnt
from hsp
	 left outer join  st			on hsp.object# = st.obj#
	 --left outer join  cdb_objects o on hsp.object# = o.object_id
order by hsp.object_owner,hsp.object_name,savtime]]></sql>
				<binds>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_DBID">
						<prompt><![CDATA[CON_DBID]]></prompt>
						<tooltip><![CDATA[CON_DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[AWR reports]]></name>
			<description><![CDATA[Create AWR and ASH reports for the SQL_ID]]></description>
			<tooltip><![CDATA[Create AWR and ASH reports for the SQL_ID]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set trimspool on
set pages 10000
set linesize 1000
set long 1000000
set longchunksize 1000000
set feedback off
set heading off
set sqlprompt ''
set echo off verify off time off timing off
select 'Open the file paths below in a browser.' from dual;
select 'Reports creation in progress...' from dual;
set termout off
col reports_dest_dir new_value reports_dest_dir
select nvl(:REPORTS_DEST_DIR,'c:\temp')  reports_dest_dir  from dual;

col slash new_value slash
select case when instr('&REPORTS_DEST_DIR.','\') > 0 then '\' else '/' end   slash from dual;

col awr_report new_value awr_report
col ash_report new_value ash_report
select
     '&REPORTS_DEST_DIR.&SLASH.'||'awr_sql_report.'||:SNAP||'-'||to_char(:SNAP - 1)||'.html'  awr_report
    ,'&REPORTS_DEST_DIR.&SLASH.'||'ash_sql_report.'||:SNAP||'-'||to_char(:SNAP - 1)||'.html'  ash_report
from dual;
    

spool &AWR_REPORT
select * from table(dbms_workload_repository.awr_sql_report_html(:DBID, :INSTANCE_NUMBER, :SNAP -1, :SNAP, :SQL_ID));
spool off

set termout off
spool &ASH_REPORT
select * from table(dbms_workload_repository.ash_global_report_html(:DBID, :INSTANCE_NUMBER, to_date(:BEGIN_INTERVAL_TIME_CHAR,'yyyy-mm-dd hh24:mi:ss day'), to_date(:END_INTERVAL_TIME_CHAR,'yyyy-mm-dd hh24:mi:ss day'), l_sql_id=> :SQL_ID));
spool off

set termout on heading on
select	'&AWR_REPORT'  as "AWR Report" from dual;
select	'&ASH_REPORT'  as "ASH Report" from dual;]]></sql>
				<binds>
					<bind id="REPORTS_DEST_DIR">
						<prompt><![CDATA[REPORTS_DEST_DIR]]></prompt>
						<tooltip><![CDATA[REPORTS_DEST_DIR]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="BEGIN_INTERVAL_TIME_CHAR">
						<prompt><![CDATA[BEGIN_INTERVAL_TIME_CHAR]]></prompt>
						<tooltip><![CDATA[BEGIN_INTERVAL_TIME_CHAR]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_INTERVAL_TIME_CHAR">
						<prompt><![CDATA[END_INTERVAL_TIME_CHAR]]></prompt>
						<tooltip><![CDATA[END_INTERVAL_TIME_CHAR]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[SQLT]]></name>
			<description><![CDATA[Code to run SQLT scripts for the SQL_ID]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set trimspool on
set pages 10000
set linesize 1000
set long 1000000
set longchunksize 1000000
set feedback off
set heading off
set sqlprompt ''
set echo off verify off time off timing off
set termout off

col sqlt_dir new_value sqlt_dir
select nvl(:P_SQLT_DIR,'/home/oracle/sqlt')  sqlt_dir  from dual;

col slash new_value slash
select case when instr('&SQLT_DIR.','\') > 0 then '\' else '/' end   slash from dual;

set termout on
select '
--Connect as the parsing_shema_name and run SQLT scripts
sqlplus /nolog
DEFINE SCHEMA = '||:PARSING_SCHEMA_NAME||'
DEFINE SCHEMA_PWD = xxxxx
DEFINE SQL_ID = '||:SQL_ID||'
DEFINE TNS = <TNS_ENTRY>
DEFINE SQLTXPLAIN_PWD = xxxxx
grant sqlt_user_role to '||'&'||'SCHEMA;
grant execute on dbms_export_extension to '||'&'||'SCHEMA;
connect '||'&'||'SCHEMA/'||'&'||'SCHEMA_PWD@'||'&'||'TNS
@&SQLT_DIR.&SLASH.run&SLASH.sqlhc.sql
@&SQLT_DIR.&SLASH.run&SLASH.sqltxtract.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD
@&SQLT_DIR.&SLASH.run&SLASH.sqltxecute.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD
@&SQLT_DIR.&SLASH.run&SLASH.sqltxtrxec.sql  '||'&'||'SQL_ID  '||'&'||'SQLTXPLAIN_PWD  @--sqltxtrxec.sql [SQL_ID]|[HASH_VALUE] [sqltxplain_password]
@&SQLT_DIR.&SLASH.utl&SLASH.coe_load_sql_baseline.sql
@&SQLT_DIR.&SLASH.utl&SLASH.coe_load_sql_profile.sql
@&SQLT_DIR.&SLASH.utl&SLASH.coe_xfr_sql_profile.sql       
'
from dual;]]></sql>
				<binds>
					<bind id="P_SQLT_DIR">
						<prompt><![CDATA[P_SQLT_DIR]]></prompt>
						<tooltip><![CDATA[P_SQLT_DIR]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PARSING_SCHEMA_NAME">
						<prompt><![CDATA[PARSING_SCHEMA_NAME]]></prompt>
						<tooltip><![CDATA[PARSING_SCHEMA_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[dbms_sqltune]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set pagesize 0 lines 200 long 1000000 heading off feedback off sqlprompt '' trimspool on trim on echo off verify off time off timing off
set termout off
col snap                new_value snap
col sql_id              new_value sql_id
col dbid                new_value dbid
col plan_hash_value     new_value plan_hash_value
col con_name            new_value con_name

select
     :SNAP                    SNAP
    ,:SQL_ID                  SQL_ID
    ,:DBID                    DBID
    ,:PLAN_HASH_VALUE         PLAN_HASH_VALUE
    ,:CON_NAME                CON_NAME
from dual;;

set termout on


PROMPT  --dbms_sqltune.create_tuning_task
PROMPT   --To be run on the container with the snapshots
PROMPT   set serveroutput on size unlimited
PROMPT   variable sql_id          varchar2(13)
PROMPT   variable task_name       varchar2(60)
PROMPT   variable plan_hash_value number
PROMPT   variable begin_snap      number
PROMPT   variable end_snap        number
PROMPT   variable dbid            number
PROMPT   variable con_name        varchar2(128)
PROMPT   exec :sql_id             := '&SQL_ID';;
PROMPT   exec :task_name          := '&SQL_ID'||'_tuning_task';;
PROMPT   exec :begin_snap         := &SNAP - 1;;
PROMPT   exec :end_snap           := &SNAP;;
PROMPT   exec :plan_hash_value    := &PLAN_HASH_VALUE;;
PROMPT   exec :dbid               := &DBID;;
PROMPT   exec :con_name           := '&CON_NAME';;
PROMPT   declare
PROMPT       l_sql_tune_task_id  varchar2(100);;
PROMPT   begin
PROMPT       begin dbms_sqltune.drop_tuning_task (task_name => :task_name); exception when others then null;end;;
PROMPT       l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT                             begin_snap  => :begin_snap,
PROMPT                             end_snap    => :end_snap,
PROMPT                             sql_id      => :sql_id,
PROMPT                             --con_name    => :con_name, only if using container snapshots
PROMPT                             scope       => dbms_sqltune.scope_comprehensive,
PROMPT                             dbid        => :DBID,
PROMPT                             time_limit  => 300,
PROMPT                             task_name   => :task_name,
PROMPT                             description => 'Tuning task for statement '||:sql_id||' in AWR.');;
PROMPT   --    l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
PROMPT   --                          sql_id      => :sql_id,
PROMPT   --                          plan_hash_value => :plan_hash_value,
PROMPT   --                          --con_name    => :con_name, only if using container snapshots
PROMPT   --                          scope       => dbms_sqltune.scope_comprehensive,
PROMPT   --                          time_limit  => 300,
PROMPT   --                          task_name   => :task_name,
PROMPT   --                          description => 'Tuning task for statement '||:sql_id||' in Shared pool.');;
PROMPT       dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);;
PROMPT       dbms_output.put_line('task_name: ' || :task_name);;
PROMPT       dbms_sqltune.execute_tuning_task(task_name => :task_name);;
PROMPT   end;;
PROMPT   /
PROMPT   set long 1000000 pagesize 10000 linesize 2000
PROMPT   select dbms_sqltune.report_tuning_task(:task_name) as recommendations from dual;;]]></sql>
				<binds>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PLAN_HASH_VALUE">
						<prompt><![CDATA[PLAN_HASH_VALUE]]></prompt>
						<tooltip><![CDATA[PLAN_HASH_VALUE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_NAME">
						<prompt><![CDATA[CON_NAME]]></prompt>
						<tooltip><![CDATA[CON_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[dbms_advisor]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set pagesize 0 lines 200 long 1000000 heading off feedback off sqlprompt '' trimspool on trim on echo off verify off time off timing off
set termout off
col sql_id              new_value sql_id
col con_name            new_value con_name
col parsing_schema_name new_value parsing_schema_name

select
     :SNAP                    SNAP
    ,:SQL_ID                  SQL_ID
    ,:CON_NAME                CON_NAME
    ,:PARSING_SCHEMA_NAME     PARSING_SCHEMA_NAME
    ,:CON_NAME                CON_NAME
from dual;
set termout on

PROMPT   --To be run on the container where it was parsed
select  '--&CON_NAME' from dual;
PROMPT   variable task_name      varchar2(60)
PROMPT   variable sql_id         varchar2(13)
PROMPT   variable username       varchar2(30)
PROMPT   exec :sql_id            := '&SQL_ID';;
PROMPT   exec :task_name         := '&SQL_ID'||'_access_advisor';;
PROMPT   exec :username          := '&PARSING_SCHEMA_NAME';;
PROMPT   declare
PROMPT     l_sql_id          varchar2(13) := :sql_id;;
PROMPT     l_task_name       varchar2(60) := :task_name;;
PROMPT     l_sql_fulltext    clob;;
PROMPT     l_advisor_name    varchar2(30) := dbms_advisor.sqlaccess_advisor;;
PROMPT   begin
PROMPT     begin dbms_advisor.delete_task(l_task_name); exception when others then null; end;;
PROMPT     select sql_text     into  l_sql_fulltext from dba_hist_sqltext where sql_id = l_sql_id and rownum < 2;;
PROMPT     dbms_advisor.quick_tune(l_advisor_name, l_task_name,l_sql_fulltext,:username);;
PROMPT   end;;
PROMPT   /
PROMPT   --read report
PROMPT   set lines 130
PROMPT   col execution_end   for a22
PROMPT   col advisor_name    for a20
PROMPT   col task_name       for a30
PROMPT   col command         for a20
PROMPT   col message         for a20
PROMPT   col action_message  for a40
PROMPT   select
PROMPT       to_char(dat.execution_end,'yyyy-mm-dd hh24:mi:ss') execution_end
PROMPT       ,dat.task_name
PROMPT       ,dat.advisor_name
PROMPT       ,daf.type                               finding_type
PROMPT       ,daf.impact
PROMPT       ,dar.rank
PROMPT       ,dar.type                               reccomendation_type
PROMPT       ,dar.benefit
PROMPT       ,'Message : ' ||daf.message             message
PROMPT       ,'Command To correct: ' ||daa.command   command
PROMPT       ,'Action Message : ' ||daa.message      action_message
PROMPT   from cdb_advisor_tasks dat,cdb_advisor_findings daf ,cdb_advisor_actions daa,cdb_advisor_recommendations dar
PROMPT   where 1=1
PROMPT       and dat.owner = daf.owner(+)
PROMPT       and dat.task_id = daf.task_id(+)
PROMPT       and dat.con_id = daf.con_id(+)
PROMPT       and daf.task_id = dar.task_id(+)
PROMPT       and daf.finding_id = dar.finding_id(+)
PROMPT       and daf.con_id = dar.con_id(+)
PROMPT       and dat.task_id = daa.task_id(+)
PROMPT       and dat.con_id = daa.con_id(+)
PROMPT       and dar.rec_id = daa.rec_id(+)
PROMPT       and dar.con_id = daa.con_id(+)
PROMPT       and dat.task_name = :task_name
PROMPT   order by  dat.execution_end
PROMPT   ;;]]></sql>
				<binds>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CON_NAME">
						<prompt><![CDATA[CON_NAME]]></prompt>
						<tooltip><![CDATA[CON_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PARSING_SCHEMA_NAME">
						<prompt><![CDATA[PARSING_SCHEMA_NAME]]></prompt>
						<tooltip><![CDATA[PARSING_SCHEMA_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR sqltune sql_id]]></name>
			<description><![CDATA[dbms_sqltune.select_workload_repository output for the SQL_ID]]></description>
			<tooltip><![CDATA[dbms_sqltune.select_workload_repository output for the SQL_ID]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     sql_id
    ,plan_hash_value
    --,force_matching_signature
    --,substr(sql_text,1,40)  sql_text
    --,object_list
    --,bind_data
    ,parsing_schema_name
    --,elapsed_time
    ,to_char(round(elapsed_time/1000000,3),'9999990.990') elapsed_time_ms
    ,executions
    ,to_char(case when executions > 0 then round(elapsed_time/1000000/executions,3)	else null end,'999999990.990') elapsed_time_avg_ms
    --,cpu_time
    ,to_char(round(cpu_time/1000000,3),'9999990.990') cpu_time_ms
    ,buffer_gets
    ,disk_reads
    ,direct_writes
    ,rows_processed
    ,fetches
    ,end_of_fetch_count
    ,module
    ,action
    ,optimizer_cost
    --,optimizer_env
    --,priority
    --,command_type
    ,first_load_time
    ,stat_period
    ,active_stat_period
    ,other
    --,sql_plan
    --,bind_list
    ,con_dbid
    ,last_exec_start_time
FROM table((dbms_sqltune.select_workload_repository (
    begin_snap          => :SNAP - 1,
    end_snap            => :SNAP,
    basic_filter        => 'sql_id='''||:SQL_ID||'''',    --'sql_id='''||'bxycjsjr7uuh5'||'''', 'parsing_schema_name <> ''SYS''',
    object_filter       => null,                                --Currently not supported.
    ranking_measure1    => 'elapsed_time',                      --ranking_measure(n) Defines an ORDER BY clause on the selected SQL.
    ranking_measure2    => null,
    ranking_measure3    => null,
    result_percentage   => null,                                --Specifies a filter that picks the top n% according to the supplied ranking measure.
    result_limit        => 10000000,
    attribute_list      => 'ALL',                               -- SQL statement attributes to return in the result. BASIC TYPICAL  ALL 
    recursive_sql       => null,                                --Specifies the filter that includes recursive SQL in the SQL tuning set (HAS_RECURSIVE_SQL) or excludes it (NO_RECURSIVE_SQL).
    dbid                => :DBID)
    ))]]></sql>
				<binds>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[AWR sqltune all]]></name>
			<description><![CDATA[dbms_sqltune.select_workload_repository output for all SQLs in the snapshot]]></description>
			<tooltip><![CDATA[dbms_sqltune.select_workload_repository output for all SQLs in the snapshot]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     sql_id
    ,plan_hash_value
    --,force_matching_signature
    --,substr(sql_text,1,40)  sql_text
    --,object_list
    --,bind_data
    ,parsing_schema_name
    --,elapsed_time
    ,to_char(round(elapsed_time/1000000,3),'9999990.990') elapsed_time_ms
    ,executions
    ,to_char(case when executions > 0 then round(elapsed_time/1000000/executions,3)	else null end,'999999990.990') elapsed_time_avg_ms
    --,cpu_time
    ,to_char(round(cpu_time/1000000,3),'9999990.990') cpu_time_ms
    ,buffer_gets
    ,disk_reads
    ,direct_writes
    ,rows_processed
    ,fetches
    ,end_of_fetch_count
    ,module
    ,action
    ,optimizer_cost
    --,optimizer_env
    --,priority
    --,command_type
    ,first_load_time
    ,stat_period
    ,active_stat_period
    ,other
    --,sql_plan
    --,bind_list
    ,con_dbid
    ,last_exec_start_time
FROM table((dbms_sqltune.select_workload_repository (
    begin_snap          => :SNAP - 1,
    end_snap            => :SNAP,
    --basic_filter        => 'sql_id='''||:SQL_ID||'''',    --'sql_id='''||'bxycjsjr7uuh5'||'''', 'parsing_schema_name <> ''SYS''',
    object_filter       => null,                                --Currently not supported.
    ranking_measure1    => 'elapsed_time',                      --ranking_measure(n) Defines an ORDER BY clause on the selected SQL.
    ranking_measure2    => null,
    ranking_measure3    => null,
    result_percentage   => null,                                --Specifies a filter that picks the top n% according to the supplied ranking measure.
    result_limit        => 10000000,
    attribute_list      => 'ALL',                               -- SQL statement attributes to return in the result. BASIC TYPICAL  ALL 
    recursive_sql       => null,                                --Specifies the filter that includes recursive SQL in the SQL tuning set (HAS_RECURSIVE_SQL) or excludes it (NO_RECURSIVE_SQL).
    dbid                => :DBID)
    ))]]></sql>
				<binds>
					<bind id="SNAP">
						<prompt><![CDATA[SNAP]]></prompt>
						<tooltip><![CDATA[SNAP]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DBID">
						<prompt><![CDATA[DBID]]></prompt>
						<tooltip><![CDATA[DBID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="c2aaeb77-0183-1000-8043-c0a838012a96" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops Advisor Reports]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
select
	owner
	,task_id
	,task_name
	,description
	,advisor_name
	,to_char(created,'yyyy-mm-dd hh24:mi:ss') created
	,to_char(last_modified,'yyyy-mm-dd hh24:mi:ss') last_modified
	,parent_task_id
	,parent_rxec_id
	,last_execution
	,execution_type
	,execution_type#
	,execution_description
	,to_char(execution_start,'yyyy-mm-dd hh24:mi:ss') execution_start
	,to_char(execution_end,'yyyy-mm-dd hh24:mi:ss') execution_end
	,status
	,status_message
	,pct_completion_time
	,progress_metric
	,metric_units
	,activity_counter
	,recommendation_count
	,error_message
	,source
	,how_created
	,read_only
	,system_task
	,advisor_id
	,status#
from dba_advisor_tasks
order by execution_start desc]]></sql>
		</query>
		<display id="null" type="" style="Script" enable="true">
			<name><![CDATA[report]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
			</CustomValues>
			<query>
				<sql><![CDATA[set echo off feedback on linesize 4000 long 1000000 trimspool on pagesize 0 heading off time off timing off serveroutput on feedback off
select dbms_advisor.get_task_report(:TASK_NAME,'TEXT','ALL','ALL' ,:OWNER) as report FROM	dual;]]></sql>
				<binds>
					<bind id="TASK_NAME">
						<prompt><![CDATA[TASK_NAME]]></prompt>
						<tooltip><![CDATA[TASK_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_findings]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_findings
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_recommendations]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_recommendations
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_rationale]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_rationale
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_actions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_actions
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_objects]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_objects
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_parameters]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_parameters
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_commands]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_commands
where task_id = :TASK_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[dba_advisor_executions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select *
from dba_advisor_executions
where task_id = :TASK_ID]]></sql>
				<binds>
					<bind id="TASK_ID">
						<prompt><![CDATA[TASK_ID]]></prompt>
						<tooltip><![CDATA[TASK_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="c786578f-0183-1000-8054-c0a838012a96" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops AWR Events]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
		  from dual)
select
     wait_class
    ,event#
    ,name
    ,parameter1
    ,parameter2
    ,parameter3
    ,display_name
    ,con_id
    ,parms.start_date
    ,parms.end_date         end_date
    ,parms.instance_number
from v$event_name
    cross join parms
order by wait_class_id,name]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Event History]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day') end_interval_time
    ,instance_number
    ,event_name
    ,wait_class
    ,time_waited_ms
    ,avg_wait_ms
from (select end_interval_time
        ,instance_number
        ,event_name
        ,wait_class
        ,(total_waits - total_waits_prev) total_waits
        ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
        ,round(case when (total_waits - total_waits_prev) > 0 then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000  else 0 end,2)  avg_wait_ms
      from (
            select 
               end_interval_time
              ,event.instance_number
              ,event_name
              ,lag(event_name) over (order by event.instance_number,event_name,end_interval_time) event_name_prev
              ,lag(event.instance_number) over (order by event.instance_number,event_name,end_interval_time) instance_number_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event.instance_number,event_name,end_interval_time) total_waits_prev
              ,time_waited_micro 
              ,lag(time_waited_micro)   over (order by event.instance_number,event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event event 
                join dba_hist_snapshot snap on event.dbid = snap.dbid and event.instance_number = snap.instance_number and event.snap_id = snap.snap_id and event_name = :NAME
            where 1=1
                and snap.end_interval_time between :START_DATE and :END_DATE
                and snap.instance_number = :INSTANCE_NUMBER
        ) last
      where event_name =event_name_prev
        and instance_number = instance_number_prev
      order by end_interval_time desc, time_waited_ms desc
     )
order by end_interval_time,instance_number]]></sql>
				<binds>
					<bind id="NAME">
						<prompt><![CDATA[NAME]]></prompt>
						<tooltip><![CDATA[NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[Event Hist avg chart]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[BAR_VERT_CLUST]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
    ,event_name
    ,avg_wait_ms
from (select end_interval_time
        ,instance_number
        ,event_name
        ,wait_class
        ,(total_waits - total_waits_prev) total_waits
        ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
        ,round(case when (total_waits - total_waits_prev) > 0 then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000  else 0 end,2)  avg_wait_ms
      from (
            select 
               end_interval_time
              ,event.instance_number
              ,event_name
              ,lag(event_name) over (order by event.instance_number,event_name,end_interval_time) event_name_prev
              ,lag(event.instance_number) over (order by event.instance_number,event_name,end_interval_time) instance_number_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event.instance_number,event_name,end_interval_time) total_waits_prev
              ,time_waited_micro 
              ,lag(time_waited_micro)   over (order by event.instance_number,event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event event 
                join dba_hist_snapshot snap on event.dbid = snap.dbid and event.instance_number = snap.instance_number and event.snap_id = snap.snap_id and event_name = :NAME
            where 1=1
                and snap.end_interval_time between :START_DATE and :END_DATE
                and snap.instance_number = :INSTANCE_NUMBER
           ) last
      where event_name =event_name_prev
        and instance_number = instance_number_prev
      order by end_interval_time desc, time_waited_ms desc
)
order by end_interval_time,instance_number]]></sql>
				<binds>
					<bind id="NAME">
						<prompt><![CDATA[NAME]]></prompt>
						<tooltip><![CDATA[NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[Event Hist tot chart]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[BAR_VERT_CLUST]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[with
parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE')) instance_number
		  from dual)
select 
     to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') end_interval_time
    ,event_name
    ,time_waited_ms/1000  time_waited_seconds
from (select end_interval_time
        ,instance_number
        ,event_name
        ,wait_class
        ,(total_waits - total_waits_prev) total_waits
        ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
        ,round(case when (total_waits - total_waits_prev) > 0 then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000  else 0 end,2)  avg_wait_ms
      from (
            select 
               end_interval_time
              ,event.instance_number
              ,event_name
              ,lag(event_name) over (order by event.instance_number,event_name,end_interval_time) event_name_prev
              ,lag(event.instance_number) over (order by event.instance_number,event_name,end_interval_time) instance_number_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event.instance_number,event_name,end_interval_time) total_waits_prev
              ,time_waited_micro 
              ,lag(time_waited_micro)   over (order by event.instance_number,event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event event 
                join dba_hist_snapshot snap on event.dbid = snap.dbid and event.instance_number = snap.instance_number and event.snap_id = snap.snap_id and event_name = :NAME
            where 1=1
                and snap.end_interval_time between :START_DATE and :END_DATE
                and snap.instance_number = :INSTANCE_NUMBER
           ) last
      where event_name =event_name_prev
        and instance_number = instance_number_prev
      order by end_interval_time desc, time_waited_ms desc
)
order by end_interval_time,instance_number]]></sql>
				<binds>
					<bind id="P_START_DATE">
						<prompt><![CDATA[P_START_DATE]]></prompt>
						<tooltip><![CDATA[P_START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_END_DATE">
						<prompt><![CDATA[P_END_DATE]]></prompt>
						<tooltip><![CDATA[P_END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="P_INST_ID">
						<prompt><![CDATA[P_INST_ID]]></prompt>
						<tooltip><![CDATA[P_INST_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="NAME">
						<prompt><![CDATA[NAME]]></prompt>
						<tooltip><![CDATA[NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="START_DATE">
						<prompt><![CDATA[START_DATE]]></prompt>
						<tooltip><![CDATA[START_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="END_DATE">
						<prompt><![CDATA[END_DATE]]></prompt>
						<tooltip><![CDATA[END_DATE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
	</display>
	<display id="bf0b005e-0183-1000-8013-c0a838012a96" type="" style="Table" enable="true">
		<name><![CDATA[Masked Devops I/O]]></name>
		<description><![CDATA[Block RW response time,IOPS, Throughput, Redologs I/O
control file parallel write           15  millisenconds
control file sequential read        20  millisenconds
db file parallel read                  20  millisenconds
db file scattered read               20  millisenconds
db file sequential read             20  millisenconds
direct path read Read               20  millisenconds
direct path read temp               20  millisenconds
direct path write                      15  millisenconds
direct path write temp              15  millisenconds
log file parallel write                15  millisenconds
cell smart table scan               1   millisenconds
cell single block physical read     1   millisenconds
cell multiblock physical read       6   millisenconds]]></description>
		<tooltip><![CDATA[Block RW response time,IOPS, Throughput, Redologs I/O]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Masked DevOps
-- Date        : Jan 2012
-- Version     : 0.1
--
-- SQL Developer report for database administration
-- Copyright (C) 2022  Emanuele Moccia
-- masked.devops@yahoo.com
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.
-- -----------------------------------------------------------------------------
with
parms as (select
             nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
            ,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)      end_date
            ,nvl(:P_INST_ID,sys_context('USERENV', 'INSTANCE'))          instance_number
          from dual)
select
     end_interval_time
    ,to_char(round(max(decode(event_name,'db file scattered read',avg_wait_ms,null)),2),'99999990.990')           db_file_scat_read
    ,to_char(round(max(decode(event_name,'db file sequential read',avg_wait_ms,null)),2),'99999990.990')          db_file_seq_read
    ,to_char(round(max(decode(event_name,'db file parallel read',avg_wait_ms,null)),2),'99999990.990')            db_file_paral_read
    ,to_char(round(max(decode(event_name,'direct path read',avg_wait_ms,null)),2),'99999990.990')                 drct_path_read_Read
    ,to_char(round(max(decode(event_name,'direct path read temp',avg_wait_ms,null)),2),'99999990.990')            drct_path_read_temp
    ,to_char(round(max(decode(event_name,'direct path write',avg_wait_ms,null)),2),'99999990.990')                drct_path_write
    ,to_char(round(max(decode(event_name,'direct path write temp',avg_wait_ms,null)),2),'99999990.990')           drct_path_write_temp
    ,to_char(round(max(decode(event_name,'log file parallel write',avg_wait_ms,null)),2),'99999990.990')          log_file_paral_write
    ,to_char(round(max(decode(event_name,'control file parallel write',avg_wait_ms,null)),2),'99999990.990')      ctrl_file_parallel_write
    ,to_char(round(max(decode(event_name,'control file sequential read',avg_wait_ms,null)),2),'99999990.990')     ctrl_file_seq_read
    ,to_char(round(max(decode(event_name,'cell smart table scan',avg_wait_ms,null)),2),'99999990.990')            cell_smart_table_scan_1_ms
    ,to_char(round(max(decode(event_name,'cell single block physical read',avg_wait_ms,null)),2),'99999990.990')  cell_sngl_blk_phys_read
    ,to_char(round(max(decode(event_name,'cell multiblock physical read',avg_wait_ms,null)),2),'99999990.990')    cell_mltblk_phys_read
    ,max(parms.instance_number)               inst_id
    ,max(start_date)                          start_date
    ,max(end_date)                            end_date
from (select end_interval_time
            ,event_name
            ,wait_class
            ,(total_waits - total_waits_prev) total_waits
            ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
            ,round(case when (total_waits - total_waits_prev) > 0
                  then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000
                  else 0
                  end,2)  avg_wait_ms
      from (
            select
               to_char(end_interval_time,'yyyy-mm-dd hh24 day') end_interval_time
              ,event_name
              ,lag(event_name) over (order by event_name,end_interval_time) event_name_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event_name,end_interval_time) total_waits_prev
              ,time_waited_micro
              ,lag(time_waited_micro) over (order by event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event se join dba_hist_snapshot snap on se.dbid = snap.dbid  and se.instance_number = snap.instance_number  and se.snap_id = snap.snap_id
                cross join parms
            where 1=1
                and snap.end_interval_time between parms.start_date and parms.end_date
                and snap.instance_number = parms.instance_number
            ) se1
      where event_name = event_name_prev
      order by end_interval_time desc, time_waited_ms desc
    ) se2, parms
group by end_interval_time
order by end_interval_time asc]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[yyyy-mm-dd hh24:mi]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_INST_ID">
					<prompt><![CDATA[P_INST_ID]]></prompt>
					<tooltip><![CDATA[P_INST_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[IOPS]]></name>
			<description><![CDATA[IOPS - (Input/Output Operations Per Second) -  This is the sum of Physical Read Total IO Requests and Physical Write Total IO Requests ]]></description>
			<tooltip><![CDATA[IOPS - (Input/Output Operations Per Second) -  This is the sum of Physical Read Total IO Requests and Physical Write Total IO Requests ]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[--Doc ID 2206831.1
select
     end_interval_time
    ,metric_name
    ,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
from dba_hist_sysmetric_summary stat 
    join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
where 1=1 
    and snap.end_interval_time between :START_DATE and :END_DATE
    and stat.metric_name in ('Physical Read Total IO Requests Per Sec', 'Physical Write Total IO Requests Per Sec')
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[Throughput]]></name>
			<description><![CDATA[This is the sum of Physical read total bytes and Physical write total bytes]]></description>
			<tooltip><![CDATA[This is the sum of Physical read total bytes and Physical write total bytes]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[210.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Default]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[--Doc ID 2206831.1
select
     end_interval_time
    ,metric_name
    ,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
from dba_hist_sysmetric_summary stat 
    join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
where 1=1 
    and snap.end_interval_time between :START_DATE and :END_DATE
    and stat.metric_name in ('Physical Read Total Bytes Per Sec', 'Physical Write Total Bytes Per Sec')
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[IOPS Data]]></name>
			<description><![CDATA[IOPS - (Input/Output Operations Per Second) -  This is the sum of Physical Read Total IO Requests and Physical Write Total IO Requests ]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[--Doc ID 2206831.1
select
     end_interval_time
    ,metric_name
    ,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
from dba_hist_sysmetric_summary stat 
    join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
where 1=1 
    and snap.end_interval_time between :START_DATE and :END_DATE
    and stat.metric_name in ('Physical Read Total IO Requests Per Sec', 'Physical Write Total IO Requests Per Sec')
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Throughput Data]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[IOPS, Throughput, Redolog stats]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[--Doc ID 2206831.1
select
     end_interval_time
    ,metric_name
    ,average/case when metric_unit = 'Milliseconds' then 1000 when metric_unit = 'CentiSeconds Per Second' then 100 else 1 end average
from dba_hist_sysmetric_summary stat 
    join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
where 1=1 
    and snap.end_interval_time between :START_DATE and :END_DATE
    and stat.metric_name in ('Physical Read Total Bytes Per Sec', 'Physical Write Total Bytes Per Sec')
order by end_interval_time]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[System Statistics redologs]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss day')                       end_interval_time
      --,instance_number
      ,round((redo_write_time*10)/redo_writes,2)                                    avg_write_time_ms
      ,user_commits                                     
      ,trunc(redo_write_time*10/1000)                                               redo_write_time_tot_sec 
      ,round((redo_blocks_written*(select max(blocksize) from v$log)/1024/1024))    redo_blocks_written_mb
      ,round(redo_size/1024/1024)                                                   redo_size_mb
      ,redo_writes
      ,round((redo_blocks_written*(select max(blocksize) from v$log)/1024)/redo_writes) avg_block_written_kb
from (select         
           end_interval_time
          ,instance_number
          ,max(decode(stat_name,'redo blocks written',value,null))               redo_blocks_written
          ,max(decode(stat_name,'redo buffer allocation retries',value,null))    redo_buffer_allocation_retries
          ,max(decode(stat_name,'redo entries',value,null))                      redo_entries
          ,max(decode(stat_name,'redo log space requests',value,null))           redo_log_space_requests
          ,max(decode(stat_name,'redo log space wait time',value,null))          redo_log_space_wait_time
          ,max(decode(stat_name,'redo log switch interrupts',value,null))        redo_log_switch_interrupts
          ,max(decode(stat_name,'redo ordering marks',value,null))               redo_ordering_marks
          ,max(decode(stat_name,'redo write time',value,null))                   redo_write_time
          ,max(decode(stat_name,'redo writes',value,null))                       redo_writes
          ,max(decode(stat_name,'redo synch writes',value,null))                 redo_synch_writes
          ,max(decode(stat_name,'redo synch time',value,null))                   redo_synch_time
          ,max(decode(stat_name,'redo size',value,null))                         redo_size
          ,max(decode(stat_name,'redo wastage',value,null))                      redo_wastage
          ,max(decode(stat_name,'user commits',value,null))                      user_commits
      from (select instance_number,end_interval_time,stat_name,(value - value_prev)  value
                   ,trunc(((value - value_prev))/3600,2)             per_second
            from (
                  select end_interval_time
                    ,stat.instance_number
                    ,stat_name
                    ,lag(stat_name) over (order by stat.instance_number,stat_name,end_interval_time)     stat_name_prev
                    ,lag(value)     over (order by stat.instance_number,stat_name,end_interval_time)     value_prev
                    ,lag(stat.instance_number)     over (order by stat.instance_number,stat_name,end_interval_time)     instance_number_prev
                    ,value
                  from dba_hist_sysstat stat join dba_hist_snapshot snap on stat.dbid = snap.dbid and stat.instance_number = snap.instance_number and stat.snap_id = snap.snap_id
                  where 1=1 
                    and snap.end_interval_time between :START_DATE and :END_DATE
            )
            where stat_name=stat_name_prev and instance_number = instance_number_prev
      )
      group by instance_number,end_interval_time
      order by end_interval_time,instance_number 
)
order by end_interval_time,instance_number]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[Num block requests]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
     end_interval_time
    ,max(decode(event_name,'db file scattered read',total_waits,null))          db_file_scat_read
    ,max(decode(event_name,'db file sequential read',total_waits,null))         db_file_seq_read
    ,max(decode(event_name,'db file parallel read',total_waits,null))           db_file_paral_read
    ,max(decode(event_name,'direct path read',total_waits,null))                drct_path_read_Read
    ,max(decode(event_name,'direct path read temp',total_waits,null))           drct_path_read_temp
    ,max(decode(event_name,'direct path write',total_waits,null))               drct_path_write
    ,max(decode(event_name,'direct path write temp',total_waits,null))          drct_path_write_temp
    ,max(decode(event_name,'log file parallel write',total_waits,null))         log_file_paral_write
    ,max(decode(event_name,'control file parallel write',total_waits,null))     ctrl_file_parallel_write
    ,max(decode(event_name,'control file sequential read',total_waits,null))    ctrl_file_seq_read
    ,max(decode(event_name,'cell smart table scan',total_waits,null))           cell_smart_table_scan_1_ms
    ,max(decode(event_name,'cell single block physical read',total_waits,null)) cell_sngl_blk_phys_read
    ,max(decode(event_name,'cell multiblock physical read',total_waits,null))   cell_mltblk_phys_read
from (select end_interval_time
            ,event_name
            ,wait_class
            ,(total_waits - total_waits_prev) total_waits
            ,(time_waited_micro - time_waited_micro_prev)/1000 time_waited_ms
            ,round(case when (total_waits - total_waits_prev) > 0
                  then (time_waited_micro - time_waited_micro_prev)/((total_waits - total_waits_prev))/1000
                  else 0
                  end,2)  avg_wait_ms
      from (
            select
               to_char(end_interval_time,'yyyy-mm-dd hh24 day') end_interval_time
              ,event_name
              ,lag(event_name) over (order by event_name,end_interval_time) event_name_prev
              ,wait_class
              ,total_waits
              ,lag(total_waits) over (order by event_name,end_interval_time) total_waits_prev
              ,time_waited_micro
              ,lag(time_waited_micro) over (order by event_name,end_interval_time) time_waited_micro_prev
            from dba_hist_system_event se join dba_hist_snapshot snap on se.dbid = snap.dbid  and se.instance_number = snap.instance_number  and se.snap_id = snap.snap_id
            where 1=1
                and snap.end_interval_time between :START_DATE and :END_DATE
                and snap.instance_number = :INST_ID
            ) se1
      where event_name = event_name_prev
      order by end_interval_time desc, time_waited_ms desc
    ) se2
group by end_interval_time
order by end_interval_time asc]]></sql>
			</query>
		</display>
	</display>
	<display id="cd38c652-0183-1000-8073-c0a838012a96" type="" style="Chart" enable="true">
		<name><![CDATA[Masked Devops Storage Tablespace growth]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
			<Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
			<Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
			<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
			<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
			<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
			<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
			<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
			<Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
			<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
			<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
			<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
			<TYPE><![CDATA[BAR_VERT_STACK]]></TYPE>
			<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
			<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
			<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
			<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
			<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
			<STYLE><![CDATA[Default]]></STYLE>
			<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
			<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
			<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
			<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
			<Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
			<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
			<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
			<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
		</CustomValues>
		<query>
			<sql><![CDATA[-- -----------------------------------------------------------------------------
-- Author      : Emanuele Moccia
-- Date        : Jan 2012
-- Version     : 0.1
-- -----------------------------------------------------------------------------
with
    parms as (select 
			 nvl(to_date(:P_START_DATE,'yyyy-mm-dd hh24:mi'),sysdate-1)  start_date
			,nvl(to_date(:P_END_DATE,'yyyy-mm-dd hh24:mi'),sysdate)	     end_date
			,nvl(:CON_ID,sys_context('USERENV', 'CON_ID'))               con_id  
		  from dual),
    db_sizes as (
                select 
                     hs.begin_interval_time
                    ,tsu.con_id
                    ,tablespace_name
                    ,round(sum((tsu.tablespace_size*dt.block_size)/1024/1024/1024),2)	  size_gb
                    ,round(sum((tsu.tablespace_usedsize*dt.block_size)/1024/1024/1024),2) used_gb
                from cdb_hist_tbspc_space_usage tsu
           			join dba_hist_snapshot hs           on tsu.dbid = hs.dbid and tsu.snap_id = hs.snap_id
                    join cdb_hist_tablespace_stat ts    on tsu.tablespace_id = ts.ts# and tsu.dbid = ts.dbid and tsu.snap_id = ts.snap_id and tsu.con_id = ts.con_id
                    join cdb_tablespaces dt             on ts.tsname = dt.tablespace_name and ts.con_id = dt.con_id
                    cross join parms
                where tsu.con_id = parms.con_id
                group by hs.begin_interval_time,tsu.con_id,tablespace_name
                )
select
     begin_interval_time
    ,tablespace_name
    ,size_gb
    --,used_gb
    ,con_id
from ( select
            trunc(begin_interval_time,'dd') begin_interval_time
            ,con_id
            ,tablespace_name
            ,max(size_gb)	 size_gb
            ,max(used_gb)	 used_gb
        from db_sizes
        group by begin_interval_time, con_id, tablespace_name
	) 
        --unpivot (value for sz in (size_gb,used_gb))
order by begin_interval_time]]></sql>
			<binds>
				<bind id="P_START_DATE">
					<prompt><![CDATA[P_START_DATE]]></prompt>
					<tooltip><![CDATA[P_START_DATE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="P_END_DATE">
					<prompt><![CDATA[P_END_DATE]]></prompt>
					<tooltip><![CDATA[P_END_DATE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="CON_ID">
					<prompt><![CDATA[CON_ID]]></prompt>
					<tooltip><![CDATA[CON_ID]]></tooltip>
					<value><![CDATA[3]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[db datafiles]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
  f.tablespace_name
  ,f.status
  ,f.file_name
  ,f.bytes/(1024*1024)														 size_mb
  ,decode(f.maxbytes,0,f.bytes,f.maxbytes)/(1024*1024)						 max_mb
  ,trunc(s.free/(1024*1024))												 free_mb
  ,trunc((decode(f.maxbytes,0,bytes,f.maxbytes)-f.bytes)/(1024*1024))		 ext_mb
  ,trunc((s.free+decode(f.maxbytes,0,bytes,f.maxbytes)-f.bytes)/(1024*1024)) free_tot_mb
  ,f.autoextensible															 ext
  ,trunc(f.increment_by*t.block_size/(1024*1024),3)							 next_mb
  ,'alter database datafile '''||f.file_name||'''  autoextend on next '||f.increment_by*t.block_size/(1024*1024)||'M maxsize '||f.maxbytes/(1024*1024)||'M;' extend
  ,'alter database datafile '''||f.file_name||'''  resize '||f.maxbytes/(1024*1024)||'M;' resize
  ,'alter tablespace '||f.tablespace_name ||' add datafile '''||f.file_name||''' size '||f.maxbytes/(1024*1024)||'M autoextend on next '||f.increment_by*t.block_size/(1024*1024)||'M maxsize '||f.maxbytes/(1024*1024)||'M;' new
from cdb_data_files f
        join cdb_tablespaces t on f.tablespace_name = t.tablespace_name and f.con_id = t.con_id
        left outer join (select con_id, file_id, sum(bytes) free from cdb_free_space where con_id = :CON_ID group by con_id,file_id) s on f.file_id = s.file_id and f.con_id = s.con_id
where 1=1
  and f.con_id = :CON_ID    
order by f.tablespace_name,f.file_name;]]></sql>
				<binds>
					<bind id="CON_ID">
						<prompt><![CDATA[CON_ID]]></prompt>
						<tooltip><![CDATA[CON_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[tablespace datafiles]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select
  f.tablespace_name
  ,f.status
  ,f.file_name
  ,f.bytes/(1024*1024)														 size_mb
  ,decode(f.maxbytes,0,f.bytes,f.maxbytes)/(1024*1024)						 max_mb
  ,trunc(s.free/(1024*1024))												 free_mb
  ,trunc((decode(f.maxbytes,0,bytes,f.maxbytes)-f.bytes)/(1024*1024))		 ext_mb
  ,trunc((s.free+decode(f.maxbytes,0,bytes,f.maxbytes)-f.bytes)/(1024*1024)) free_tot_mb
  ,f.autoextensible															 ext
  ,trunc(f.increment_by*t.block_size/(1024*1024),3)							 next_mb
  ,'alter database datafile '''||f.file_name||'''  autoextend on next '||f.increment_by*t.block_size/(1024*1024)||'M maxsize '||f.maxbytes/(1024*1024)||'M;' extend
  ,'alter database datafile '''||f.file_name||'''  resize '||f.maxbytes/(1024*1024)||'M;' resize
  ,'alter tablespace '||f.tablespace_name ||' add datafile '''||f.file_name||''' size '||f.maxbytes/(1024*1024)||'M autoextend on next '||f.increment_by*t.block_size/(1024*1024)||'M maxsize '||f.maxbytes/(1024*1024)||'M;' new
from cdb_data_files f
        join cdb_tablespaces t on f.tablespace_name = t.tablespace_name and f.con_id = t.con_id
        left outer join (select con_id, file_id, sum(bytes) free from cdb_free_space where con_id = :CON_ID group by con_id,file_id) s on f.file_id = s.file_id and f.con_id = s.con_id
where 1=1
  and f.tablespace_name = :TABLESPACE_NAME
  and f.con_id = :CON_ID
order by f.tablespace_name,f.file_name;]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[tablespace segments]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select s.segment_name
	,s.segment_type
	,s.tablespace_name
	,round(s.bytes/1024/1024) MB
	,s.blocks
	,'SQLDEV:LINK:'||s.owner||':'||s.segment_type||':'||segment_name||':oracle.dbtools.raptor.controls.grid.DefaultDrillLink' link
	,'(select * from  table(dbms_space.object_growth_trend('''||s.owner||''','''||s.segment_name||''','''||s.segment_type||'''));' trend
from cdb_segments s
where 1=1
	and s.tablespace_name  = :TABLESPACE_NAME
    and s.con_id = :CON_ID]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[db size]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select 'datafiles' type,trunc(sum(f.bytes)/1014/1024) total_mb,trunc(sum(s.free)/1014/1024) free_mb
from cdb_data_files f
        join cdb_tablespaces t on f.tablespace_name = t.tablespace_name and f.con_id = t.con_id
        left outer join (select con_id, file_id, sum(bytes) free from cdb_free_space where con_id = :CON_ID group by con_id,file_id) s on f.file_id = s.file_id and f.con_id = s.con_id
where 1=1
    and f.con_id = :CON_ID
union all
select 'tempfiles',trunc(sum(BYTES)/1014/1024),0 from cdb_temp_files where con_id = :CON_ID
union all
select 'logfiles',trunc(sum(BYTES)/1014/1024),0 from v$log]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Table" enable="true">
			<name><![CDATA[tablespace growth]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<TYPE><![CDATA[horizontal]]></TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[select tablespace_name
    ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss')   end_interval_time
    ,trunc(tablespace_size/1024/1024*dt.block_size)      size_mb
    ,trunc(tablespace_usedsize/1024/1024*dt.block_size)  used_mb  
    ,trunc(tablespace_maxsize/1024/1024*dt.block_size)   maxsize_mb
from cdb_hist_tbspc_space_usage tsu
    join dba_hist_snapshot hs           on tsu.dbid = hs.dbid and tsu.snap_id = hs.snap_id
    join cdb_hist_tablespace_stat ts    on tsu.tablespace_id = ts.ts# and tsu.dbid = ts.dbid and tsu.snap_id = ts.snap_id and tsu.con_id = ts.con_id
    join cdb_tablespaces dt             on ts.tsname = dt.tablespace_name and ts.con_id = dt.con_id
where 1=1 
    and tablespace_name = :TABLESPACE_NAME
    and tsu.con_id = :CON_ID
order by end_interval_time,tablespace_name]]></sql>
			</query>
		</display>
		<display id="null" type="" style="Chart" enable="true">
			<name><![CDATA[tablespace growth chart]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[]]></drillclass>
			<CustomValues>
				<PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
				<Y1AXIS_SCALE_INCREMENT><![CDATA[30.0]]></Y1AXIS_SCALE_INCREMENT>
				<Y2AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y2AXIS_SCALE_MAXIMUM>
				<Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
				<Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
				<LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
				<LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
				<XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
				<DATA_MAP_COLUMNS><![CDATA[\,"END_INTERVAL_TIME"]]></DATA_MAP_COLUMNS>
				<Y1AXIS_SCALE_MAXIMUM><![CDATA[180.0]]></Y1AXIS_SCALE_MAXIMUM>
				<XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
				<XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
				<Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
				<TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
				<GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
				<PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
				<FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
				<XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
				<DATA_MAP_COLNAMES><![CDATA[\,"END_INTERVAL_TIME","SIZE_GB","TABLESPACE_NAME"]]></DATA_MAP_COLNAMES>
				<DATA_MAP_SERIES><![CDATA[\,"TABLESPACE_NAME"]]></DATA_MAP_SERIES>
				<Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
				<STYLE><![CDATA[Regatta]]></STYLE>
				<TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
				<Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
				<Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
				<DATA_MAP_VALUES><![CDATA[\,"SIZE_GB"]]></DATA_MAP_VALUES>
				<Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
				<Y2AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y2AXIS_SCALE_INCREMENT>
				<PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
				<Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
				<SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
			</CustomValues>
			<query>
				<sql><![CDATA[select 
     trunc(end_interval_time,'dd') end_interval_time
    ,tablespace_name
    ,max(round(tablespace_size/1024/1024/1024*dt.block_size,2)) size_gb
from cdb_hist_tbspc_space_usage tsu
    join dba_hist_snapshot hs           on tsu.dbid = hs.dbid and tsu.snap_id = hs.snap_id
    join cdb_hist_tablespace_stat ts    on tsu.tablespace_id = ts.ts# and tsu.dbid = ts.dbid and tsu.snap_id = ts.snap_id and tsu.con_id = ts.con_id
    join cdb_tablespaces dt             on ts.tsname = dt.tablespace_name and ts.con_id = dt.con_id
where 1=1 
    and tablespace_name = :TABLESPACE_NAME
    and tsu.con_id = :CON_ID
group by tablespace_name,trunc(end_interval_time,'dd')
order by end_interval_time,tablespace_name]]></sql>
			</query>
		</display>
	</display>
</folder>
</displays>